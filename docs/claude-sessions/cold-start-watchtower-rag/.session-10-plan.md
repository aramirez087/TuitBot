# Session 10 — Mode-Aware Validation: Implementation Plan

## Mission

Validate that source selection behaves correctly across desktop, self-host, and cloud deployment modes. Run all quality gates, perform a manual shakeout for each mode, fix any regressions, and issue a corrected go/no-go recommendation in the updated validation report.

---

## Current State Analysis

### What Sessions 08–09 Delivered

1. **Session 08** added `DeploymentMode` (Desktop/SelfHost/Cloud) and `DeploymentCapabilities` to `tuitbot-core`, wired into `AppState`, exposed via `GET /api/runtime/status`, with 20 unit tests and config validation rejecting `local_fs` in cloud mode.

2. **Session 09** wired capabilities into the frontend: a new `runtime.ts` store with dual-fetch strategy, capability-gated UI in `ContentSourcesSection.svelte` and `SourcesStep.svelte`, and 2 new server tests for the unauthenticated `GET /api/settings/status` endpoint.

### Key Code Locations

| Component | File | Purpose |
|-----------|------|---------|
| DeploymentMode enum | `crates/tuitbot-core/src/config/types.rs:517–601` | Mode + capabilities + `allows_source_type()` |
| Config validation | `crates/tuitbot-core/src/config/validation.rs:249–260` | Rejects `local_fs` in cloud on save |
| AppState | `crates/tuitbot-server/src/state.rs` | Holds `deployment_mode` field |
| Server main | `crates/tuitbot-server/src/main.rs:145–177` | Reads deployment_mode, starts Watchtower |
| Runtime status | `crates/tuitbot-server/src/routes/runtime.rs` | Returns mode + capabilities (auth required) |
| Config status | `crates/tuitbot-server/src/routes/settings.rs:113–121` | Returns mode + capabilities (no auth) |
| Watchtower startup | `crates/tuitbot-server/src/main.rs:158–177` | Filters sources with `watch && path.is_some()` |
| Watchtower loop | `crates/tuitbot-core/src/automation/watchtower/mod.rs:314–398` | Splits into local_fs and google_drive sources |
| Tauri sidecar | `dashboard/src-tauri/src/lib.rs:77–92` | AppState construction (no deployment_mode field set) |
| Runtime store | `dashboard/src/lib/stores/runtime.ts` | Dual-fetch capabilities with desktop defaults |
| Settings UI | `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte` | Capability-gated source options |
| Onboarding UI | `dashboard/src/lib/components/onboarding/SourcesStep.svelte` | Capability-gated onboarding source step |
| Onboarding page | `dashboard/src/routes/onboarding/+page.svelte` | Submit handler builds config payload |
| API types | `dashboard/src/lib/api.ts` | ConfigStatus, DeploymentCapabilities types |
| API tests | `crates/tuitbot-server/tests/api_tests.rs:923–993` | 2 tests for config_status capabilities |
| Core tests | `crates/tuitbot-core/src/config/tests.rs` | 20 tests for deployment mode |

### Known Gap: Tauri AppState Missing `deployment_mode`

**Critical finding:** In `dashboard/src-tauri/src/lib.rs:77–92`, the `AppState` construction does NOT include a `deployment_mode` field. The struct has `deployment_mode: DeploymentMode` (added in Session 08), but the Tauri sidecar relies on the `Default` implementation, which is `Desktop`. This is actually correct behavior since Tauri IS the desktop app — but it should be verified and documented as an intentional omission, not an accident.

### Known Gap: Watchtower Startup Doesn't Filter by Deployment Mode

In `crates/tuitbot-server/src/main.rs:158–163`, the Watchtower startup logic filters sources by `s.watch && s.path.is_some()` but does NOT check deployment mode. A cloud server with pre-existing `local_fs` sources in config would attempt to start the Watchtower for those sources. Per the deployment-capability-matrix.md design document (section "Pre-existing Config Migration / Cloud"), the Watchtower should **skip** incompatible sources with a structured log warning.

---

## Task Breakdown and Order of Operations

### Phase 1: Quality Gates (diagnostic — no code changes)

**Step 1.1: Run Rust quality gates**

```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

Record results. If any gate fails, identify the regression source (likely from Session 09 changes) and note the fix needed in Phase 2.

**Step 1.2: Run dashboard quality gate**

```bash
cd dashboard && npm run check
```

Record result. Note any type errors or warnings.

**Step 1.3: Run dashboard build to verify production readiness**

```bash
cd dashboard && npm run build
```

This catches additional issues that `svelte-check` alone might miss (e.g., import resolution).

### Phase 2: Fix Any Regressions

Based on Phase 1 results, fix any compilation errors, test failures, or lint warnings. Expected: likely clean since Session 09 reported all gates passing. If regressions exist, fix in order: fmt → clippy → tests → svelte-check.

### Phase 3: Watchtower Deployment Mode Guard

**Step 3.1: Add deployment-mode filtering to Watchtower startup in server main.rs**

**File:** `crates/tuitbot-server/src/main.rs`

**Current code (lines 158–163):**
```rust
let watchtower_cancel = {
    let watch_sources: Vec<_> = content_sources
        .sources
        .iter()
        .filter(|s| s.watch && s.path.is_some())
        .collect();
```

**Change:** Add deployment mode filtering. Sources whose type is incompatible with the deployment mode should be skipped with a structured log warning.

```rust
let watchtower_cancel = {
    let watch_sources: Vec<_> = content_sources
        .sources
        .iter()
        .filter(|s| {
            if !deployment_mode.allows_source_type(&s.source_type) {
                tracing::warn!(
                    source_type = %s.source_type,
                    deployment_mode = %deployment_mode,
                    "skipping content source incompatible with deployment mode"
                );
                return false;
            }
            s.watch && (s.path.is_some() || s.folder_id.is_some())
        })
        .collect();
```

**Rationale:** This implements the "skip local_fs sources in cloud mode with structured log warning" from the Session 08/09 open items. Also fixes a secondary issue: the existing filter `s.path.is_some()` would miss Google Drive sources that have `folder_id` but no `path`.

**Design decision:** Filter at startup, not inside WatchtowerLoop. The loop is deployment-unaware by design (it's L3 Autopilot layer — it receives already-validated config). The server is the right boundary for deployment policy enforcement.

**Step 3.2: Also add deployment-mode filtering inside WatchtowerLoop::run()**

**File:** `crates/tuitbot-core/src/automation/watchtower/mod.rs`

Although the server already filters, the WatchtowerLoop should be defensive. In `run()` (line 314), the local_sources and remote_sources filtering already partitions by `source_type`, which is the correct behavior. No changes needed here unless we want belt-and-suspenders logging. **Decision: no change needed** — the WatchtowerLoop naturally ignores unsupported source types because it only processes `local_fs` and `google_drive`. Unknown source types are simply not collected.

### Phase 4: Manual Shakeout — Three Deployment Scenarios

This phase is a code-review-based validation (not interactive testing), since we're running in a CI-like environment. For each scenario, trace the code path from server startup through frontend rendering.

**Step 4.1: Desktop with Native Picker**

Trace the full path:
1. **Server startup:** `main.rs` — `deployment_mode` defaults to `Desktop` (from config or Default).
2. **AppState construction:** `deployment_mode: DeploymentMode::Desktop` stored.
3. **Tauri sidecar:** `lib.rs` — AppState uses struct default, which is `Desktop`. Correct.
4. **`GET /api/runtime/status`:** Returns `deployment_mode: "desktop"`, capabilities with all `true`.
5. **`GET /api/settings/status`:** Same capabilities returned without auth. Correct.
6. **`runtime.ts` store:** `loadCapabilities()` → tries `api.runtime.status()` (succeeds in desktop since auth token available via Tauri) → sets all capabilities to `true`.
7. **`ContentSourcesSection.svelte`:** `canLocalFs=true`, `canNativePicker=true`, `canManualPath=true`, `canGoogleDrive=true`. Both "Local Folder" and "Google Drive" options shown. Browse button visible.
8. **`SourcesStep.svelte` (onboarding):** Same capability flags. Both options shown. Browse button visible.
9. **Config validation:** `local_fs` allowed in Desktop mode. PATCH saves succeed.
10. **Watchtower startup:** `allows_source_type("local_fs")` returns `true`. Sources not filtered. Watcher starts normally.

**Expected result:** Full experience. All features available.

**Step 4.2: Self-Host Browser with Manual Local Path**

Trace:
1. **Server startup:** `TUITBOT_DEPLOYMENT_MODE=self_host` → `DeploymentMode::SelfHost`.
2. **Capabilities:** `local_folder: true`, `manual_local_path: true`, `google_drive: true`, `inline_ingest: true`, `file_picker_native: false`.
3. **`GET /api/settings/status`:** Returns SelfHost capabilities (no auth needed for onboarding).
4. **`runtime.ts` store:** For onboarding (no auth token), `api.runtime.status()` fails, falls back to `api.settings.configStatus()`, which returns SelfHost capabilities. Correct.
5. **Settings UI:** `canLocalFs=true`, `canNativePicker=false`, `canManualPath=true`. "Local Folder" option shown, Browse button hidden, text input shown with hint "Enter the full server-side path to your content folder." Correct.
6. **Onboarding UI:** Same behavior — no Browse button, manual path entry only.
7. **Config validation:** `local_fs` allowed in SelfHost. Saves succeed.
8. **Watchtower:** `allows_source_type("local_fs")` returns `true`. Sources not filtered.

**Expected result:** Local folder with manual path entry. No native picker. Google Drive available.

**Step 4.3: Cloud with Connector-Only Source Selection**

Trace:
1. **Server startup:** `TUITBOT_DEPLOYMENT_MODE=cloud` → `DeploymentMode::Cloud`.
2. **Capabilities:** `local_folder: false`, `manual_local_path: false`, `google_drive: true`, `inline_ingest: true`, `file_picker_native: false`.
3. **`GET /api/settings/status`:** Returns Cloud capabilities.
4. **`runtime.ts` store:** Loads cloud capabilities.
5. **Settings UI:** `canLocalFs=false`. "Local Folder" option NOT shown in dropdown. `.capability-notice` banner displayed: "Local folder sources are not available in cloud deployments." If a pre-existing `local_fs` source is loaded, `$effect` auto-switches to `google_drive`. Correct.
6. **Onboarding UI:** `canLocalFs=false`. Only "Google Drive" shown. Capability hint displayed. Correct.
7. **Config validation:** `local_fs` rejected via `allows_source_type()`. PATCH returns validation error with field path and message. Correct.
8. **Init (onboarding save):** Same validation — `local_fs` rejected. But auto-switch `$effect` prevents this from ever being submitted.
9. **Watchtower startup (with Phase 3 fix):** Pre-existing `local_fs` sources filtered with warning log. Only `google_drive` sources start. Correct.

**Expected result:** Only Google Drive and manual ingest. Local folder completely hidden. Pre-existing local_fs configs skipped at runtime.

**Step 4.4: Verify pre-existing local_fs config in cloud mode**

This is the critical edge case:
1. User starts on Desktop, configures `local_fs` source in `config.toml`.
2. User migrates to Cloud deployment (`TUITBOT_DEPLOYMENT_MODE=cloud`).
3. **On startup:** Server loads config. Watchtower skips `local_fs` sources (Phase 3 fix). Server starts normally.
4. **On `GET /api/settings`:** Returns full config including `local_fs` source. Frontend auto-switches display to `google_drive`.
5. **On `PATCH /api/settings`:** If user tries to save with `local_fs` still present, validation rejects with clear error. User must change to `google_drive` or remove the source.
6. **Config preservation:** `local_fs` entries in TOML file are NOT deleted by the server — consistent with design doc.

### Phase 5: Update Documentation

**Step 5.1: Update `docs/roadmap/cold-start-watchtower-rag/validation-report.md`**

The existing report covers Sessions 01–07. Update to include Sessions 08–09 deployment mode work:

- Add new section: "Deployment Mode Source Capabilities (Sessions 08–09)"
- Add quality gate results from Phase 1
- Add manual validation results from Phase 4
- Update test coverage table with new tests (20 core + 2 server = 22 new)
- Update unresolved risks table
- Issue corrected go/no-go recommendation

Key additions to the report:
- **New test coverage:** 22 tests covering deployment mode enum, capabilities, validation, env vars, and API endpoints
- **Three-mode validation:** Desktop / SelfHost / Cloud paths all verified
- **Edge case coverage:** Pre-existing local_fs config in cloud mode handled gracefully
- **Watchtower guard:** Incompatible sources skipped at startup with structured logging

**Step 5.2: Review `docs/architecture.md` for accuracy**

Verify the deployment modes section (lines 109–119) accurately reflects current implementation. Currently correct — no changes expected.

**Step 5.3: Review `docs/configuration.md` for accuracy**

Verify the deployment mode section (lines 82–104) and content sources section (lines 216–268) are accurate. Currently correct — no changes expected.

### Phase 6: Write Handoff

**Step 6.1: Create `docs/roadmap/cold-start-watchtower-rag/session-10-handoff.md`**

Include:
- Summary of what was validated and fixed
- Quality gate results
- Manual validation results for all three deployment modes
- Any remaining open items
- Go/no-go recommendation
- Files changed

### Phase 7: Final Quality Gates

Re-run all quality gates after any code changes from Phase 2–3:

```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
cd dashboard && npm run check
```

---

## Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| `crates/tuitbot-server/src/main.rs` | Modify | Add deployment-mode filter to Watchtower startup (lines 158–163) |
| `docs/roadmap/cold-start-watchtower-rag/validation-report.md` | Modify | Update with deployment-mode validation results and go/no-go |
| `docs/roadmap/cold-start-watchtower-rag/session-10-handoff.md` | Create | Session handoff document |

Optional (only if Phase 1 reveals regressions):
| File | Action | Purpose |
|------|--------|---------|
| Various | Modify | Fix any regressions found during quality gates |

---

## Key Design Decisions

### 1. Watchtower guard lives in server main.rs, not in WatchtowerLoop

**Decision:** Filter incompatible sources at server startup, before passing config to WatchtowerLoop.

**Rationale:** The WatchtowerLoop is in tuitbot-core (L3 Autopilot). It receives already-validated configuration and doesn't know about deployment modes. The server is the deployment boundary — it owns the `DeploymentMode` and should enforce it. This follows the existing pattern where the server is a thin layer that does routing, serialization, and policy enforcement, while core stays deployment-unaware.

**Alternative considered:** Adding `DeploymentMode` as a parameter to `WatchtowerLoop::new()`. Rejected because it breaks the layering — core shouldn't depend on deployment concepts.

### 2. Pre-existing local_fs configs are preserved, not deleted

**Decision:** When a cloud server encounters `local_fs` sources in config, it skips them at runtime but does NOT modify the TOML file.

**Rationale:** Config preservation allows easy migration back to self-host. Deleting entries would be destructive and surprising. This is consistent with the design doc in `deployment-capability-matrix.md`.

### 3. Tauri not setting deployment_mode explicitly is correct

**Decision:** Document that Tauri's AppState using `Default::default()` for `deployment_mode` (which is `Desktop`) is intentional, not a bug.

**Rationale:** Tauri IS the desktop app. Setting it explicitly would be redundant. The Default implementation on the enum ensures backward compatibility.

### 4. Code-review-based validation instead of interactive testing

**Decision:** Validate deployment scenarios by tracing code paths, not by running the full app in each mode.

**Rationale:** The session runs in a CI-like environment without a display server for Tauri or browser interaction. The code paths are deterministic and well-covered by existing tests. The trace-based approach is more thorough than interactive testing because it covers every branch, not just the happy path.

---

## Risks and Mitigations

| Risk | Severity | Mitigation |
|------|----------|------------|
| Watchtower startup filter change could break existing source filtering | Low | The change only adds an additional filter predicate. Existing `watch && path.is_some()` logic preserved. Also extends to include `folder_id.is_some()` for Google Drive, which is a bugfix. |
| Frontend auto-switch `$effect` could create infinite loop | Low | Already guarded by `sourceType === 'local_fs'` check. Only triggers once. Verified in code review. |
| Dual-fetch fallback in runtime.ts could mask server errors | Low | Fallback chain is: auth endpoint → unauth endpoint → desktop defaults. Each step is appropriate for its context. |
| Config with local_fs in cloud mode could confuse users | Medium | Addressed by: (1) UI auto-switches away from local_fs, (2) capability-notice banner explains why, (3) validation rejects saves, (4) Watchtower skips with log warning. |

---

## Verification Steps

1. **Unit test coverage:** 20 core deployment mode tests + 2 server API tests already pass.
2. **Watchtower guard test:** After Phase 3 change, verify existing tests still pass (the change only adds filtering, doesn't break existing paths).
3. **Code trace validation:** Phase 4 traces each deployment scenario end-to-end through server, API, store, and UI components.
4. **Quality gates:** Run all four gates before and after changes.
5. **Documentation review:** Verify architecture.md and configuration.md match implementation.

---

## Exact Order of Operations

1. Run quality gates (Phase 1) — record baseline
2. Fix any regressions (Phase 2) — if needed
3. Add Watchtower deployment-mode guard in `main.rs` (Phase 3.1)
4. Run quality gates again — verify no regressions from Phase 3
5. Perform code-trace validation for all three deployment modes (Phase 4)
6. Update `validation-report.md` (Phase 5.1)
7. Review `architecture.md` and `configuration.md` (Phase 5.2–5.3)
8. Create `session-10-handoff.md` (Phase 6)
9. Final quality gate run (Phase 7) — confirm clean exit
