# Session 05 Implementation Plan — Source Picker and Local Vault UX

## Overview

Add desktop and dashboard UX for selecting, saving, and inspecting a local content-source folder for the Watchtower. Desktop users get a native folder picker via the Tauri dialog plugin; browser/LAN users get a manual path text input fallback. The chosen path round-trips cleanly through the config API (`GET/PATCH /api/settings`).

---

## Key Design Decisions

### D1: No new API endpoints needed
The existing `GET /api/settings` already serializes the full `Config` (including `content_sources` since Session 02), and `PATCH /api/settings` merges arbitrary JSON patches into the TOML file. Content sources already round-trip through these endpoints. The only work is on the frontend TypeScript types and UI components.

**Rationale:** Adding a bespoke `/api/settings/sources` endpoint would duplicate logic that `merge_patch_and_parse` already handles generically. Keep the server layer thin per CLAUDE.md.

### D2: Sources step is optional in onboarding
The content sources step will be inserted after "Language" (index 5) but before "Validate" (shifts to index 6). `canAdvance()` returns `true` unconditionally for this step — users who have no vault can skip it. The submit payload only includes `content_sources` when a path is provided.

**Rationale:** Vault configuration is not required for core functionality. Forcing users to configure it during onboarding would block non-Obsidian users.

### D3: Tauri folder picker via `tauri-plugin-dialog`
Desktop users get a "Browse" button that invokes `@tauri-apps/plugin-dialog`'s `open()` function with `directory: true` directly from the Svelte component using dynamic import. No custom Tauri command is needed — the dialog plugin exposes the folder picker directly from the JS SDK.

**Rationale:** The `@tauri-apps/plugin-dialog` JS API exposes `open({ directory: true })` which returns the selected path as a string. This avoids needing a custom Rust command in `lib.rs`. The dynamic import pattern (`await import('@tauri-apps/plugin-dialog')`) gracefully fails in browser context, matching the existing `StorageSection.svelte` pattern for `@tauri-apps/plugin-autostart`.

### D4: Fixing the lib.rs compile gap
`AppState` was extended in Session 03 with `watchtower_cancel` and `content_sources` fields, but `dashboard/src-tauri/src/lib.rs` was not updated. This must be fixed first — it's a compile blocker. We'll add `watchtower_cancel: None` and `content_sources: ContentSourcesConfig::default()`.

### D5: Settings section is the primary surface, onboarding is secondary
The settings page gets a full `ContentSourcesSection.svelte` with path input, browse button, and toggles for watch/loop-back. The onboarding step is a simpler version (just path + browse). After onboarding, users manage sources through settings.

---

## Files to Create

| File | Purpose |
|------|---------|
| `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte` | Settings section with path input, Browse button (Tauri-only), watch/loop-back toggles |
| `dashboard/src/lib/components/onboarding/SourcesStep.svelte` | Onboarding step for vault path selection |
| `docs/roadmap/cold-start-watchtower-rag/session-05-handoff.md` | Session handoff document |

## Files to Modify

| File | Modification |
|------|-------------|
| `dashboard/src-tauri/Cargo.toml` | Add `tauri-plugin-dialog = "2.0.0-rc"` dependency |
| `dashboard/src-tauri/src/lib.rs` | (1) Register dialog plugin; (2) Fix `AppState` construction — add `watchtower_cancel: None`, `content_sources: ContentSourcesConfig::default()` |
| `dashboard/src-tauri/capabilities/default.json` | Add `"dialog:allow-open"` permission |
| `dashboard/package.json` | Add `"@tauri-apps/plugin-dialog": "^2.0.0-rc"` to dependencies |
| `dashboard/src/lib/api.ts` | Add `content_sources` field to `TuitbotConfig` interface |
| `dashboard/src/lib/stores/onboarding.ts` | Add `vault_path`, `vault_watch`, `vault_loop_back` fields |
| `dashboard/src/routes/onboarding/+page.svelte` | Add Sources step (index 5), import `SourcesStep`, include `content_sources` in submit payload |
| `dashboard/src/routes/(app)/settings/+page.svelte` | Add Sources nav item (with `FolderOpen` icon) + import/render `ContentSourcesSection` |
| `crates/tuitbot-core/src/config/types.rs` | No changes needed — `ContentSourcesConfig` and `ContentSourceEntry` already exist |
| `crates/tuitbot-server/src/routes/settings.rs` | No changes needed — generic `PATCH` already handles `content_sources` |

---

## Order of Operations

### Phase 1: Fix compile blocker (Rust)

#### Step 1.1: Update `dashboard/src-tauri/Cargo.toml`
Add `tauri-plugin-dialog`:
```toml
tauri-plugin-dialog = "2.0.0-rc"
```

#### Step 1.2: Update `dashboard/src-tauri/src/lib.rs`
1. Add `use tuitbot_core::config::ContentSourcesConfig;` import.
2. Register the dialog plugin: `.plugin(tauri_plugin_dialog::init())` after the other plugins.
3. Fix `AppState` construction — add missing fields:
```rust
Arc::new(AppState {
    // ... existing fields ...
    circuit_breaker: None,
    watchtower_cancel: None,
    content_sources: ContentSourcesConfig::default(),
})
```

#### Step 1.3: Update `dashboard/src-tauri/capabilities/default.json`
Add to permissions array:
```json
"dialog:allow-open"
```

#### Step 1.4: Verify Rust compiles
```bash
cargo fmt --all && cargo fmt --all --check
cargo clippy --workspace -- -D warnings
RUSTFLAGS="-D warnings" cargo test --workspace
```

### Phase 2: Frontend types and dependencies

#### Step 2.1: Update `dashboard/package.json`
Add `@tauri-apps/plugin-dialog`:
```json
"@tauri-apps/plugin-dialog": "^2.0.0-rc"
```

Then run `npm install` in the dashboard directory.

#### Step 2.2: Update `dashboard/src/lib/api.ts`
Add `content_sources` to `TuitbotConfig` interface (after `schedule`):
```typescript
content_sources: {
    sources: Array<{
        source_type: string;
        path: string | null;
        watch: boolean;
        file_patterns: string[];
        loop_back_enabled: boolean;
    }>;
};
```

### Phase 3: Settings section (primary surface)

#### Step 3.1: Create `ContentSourcesSection.svelte`
Location: `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte`

Structure:
- Import `SettingsSection`, `FolderOpen` icon from lucide, settings stores.
- Show the first configured source path (read from `$draft?.content_sources?.sources?.[0]?.path`).
- Text input for manual path entry (always available).
- "Browse" button that uses dynamic import of `@tauri-apps/plugin-dialog` to call `open({ directory: true, title: 'Select content source folder' })`. Hidden gracefully in browser context via `isTauri` state set in `onMount`.
- Toggle for `watch` (real-time file watching).
- Toggle for `loop_back_enabled` (write metadata back to source files).
- `file_patterns` display (read-only in v1, shows defaults `*.md, *.txt`).
- Use `updateDraft()` with paths like `content_sources.sources` to update the full sources array.

Key implementation detail — when the user sets a path, we construct the full `ContentSourceEntry` and set it as a single-element sources array:
```typescript
function updateSourcePath(path: string) {
    const current = $draft?.content_sources?.sources?.[0];
    updateDraft('content_sources', {
        sources: [{
            source_type: current?.source_type ?? 'local_fs',
            path: path || null,
            watch: current?.watch ?? true,
            file_patterns: current?.file_patterns ?? ['*.md', '*.txt'],
            loop_back_enabled: current?.loop_back_enabled ?? true,
        }]
    });
}
```

The browse handler:
```typescript
let isTauri = $state(false);

onMount(async () => {
    try {
        await import('@tauri-apps/plugin-dialog');
        isTauri = true;
    } catch {
        // Not in Tauri
    }
});

async function browseFolder() {
    try {
        const { open } = await import('@tauri-apps/plugin-dialog');
        const selected = await open({
            directory: true,
            title: 'Select content source folder'
        });
        if (selected) {
            updateSourcePath(selected as string);
        }
    } catch {
        // Dialog cancelled or not available
    }
}
```

#### Step 3.2: Update settings page
In `dashboard/src/routes/(app)/settings/+page.svelte`:
1. Import `FolderOpen` from `lucide-svelte`.
2. Import `ContentSourcesSection` from `./ContentSourcesSection.svelte`.
3. Add to `sections` array (after `storage`, before `lan`):
   ```typescript
   { id: 'sources', label: 'Sources', icon: FolderOpen }
   ```
4. Add `<ContentSourcesSection />` in the sections rendering area, between `<StorageSection />` and `<LanAccessSection />`.

### Phase 4: Onboarding step

#### Step 4.1: Update onboarding store
In `dashboard/src/lib/stores/onboarding.ts`:
1. Add fields to `OnboardingData` interface:
   ```typescript
   vault_path: string;
   vault_watch: boolean;
   vault_loop_back: boolean;
   ```
2. Add defaults to initial state and `reset()`:
   ```typescript
   vault_path: '',
   vault_watch: true,
   vault_loop_back: true,
   ```

#### Step 4.2: Create `SourcesStep.svelte`
Location: `dashboard/src/lib/components/onboarding/SourcesStep.svelte`

A simplified version of the settings section:
- Title: "Content Source (Optional)"
- Description explaining Obsidian vault / notes folder purpose.
- Text input for folder path.
- "Browse" button (Tauri-only, same dynamic import pattern).
- Checkbox toggles for watch and loop-back (defaulting to true).
- "Skip" guidance text: "You can configure this later in Settings."
- Uses `onboardingData.updateField()` to update vault fields.

#### Step 4.3: Update onboarding page
In `dashboard/src/routes/onboarding/+page.svelte`:
1. Import `SourcesStep`.
2. Update `STEPS` array to insert 'Sources' at index 5:
   ```typescript
   const STEPS = ['Welcome', 'X API', 'Business', 'LLM', 'Language', 'Sources', 'Validate', 'Review'];
   ```
3. Add `case 5: return true;` to `canAdvance()` (sources step is optional).
4. Update existing `case 5` (Validation) to `case 6`, and `case 6` (Review) to `case 7`.
5. Add `{:else if currentStep === 5} <SourcesStep />` in the step rendering section.
6. Shift existing step render conditions: Validate becomes `currentStep === 6`, Review becomes `currentStep === 7`.
7. In `submit()`, include `content_sources` in the config payload when `data.vault_path` is non-empty:
   ```typescript
   if (data.vault_path) {
       config.content_sources = {
           sources: [{
               source_type: 'local_fs',
               path: data.vault_path,
               watch: data.vault_watch,
               file_patterns: ['*.md', '*.txt'],
               loop_back_enabled: data.vault_loop_back,
           }]
       };
   }
   ```

### Phase 5: Testing and validation

#### Step 5.1: Config round-trip test (Rust)
Verify the existing test `content_sources_config_serde_roundtrip` in `crates/tuitbot-core/src/config/tests.rs` covers:
- TOML → Config → JSON → TOML with `content_sources.sources` populated.
- Empty sources list round-trips correctly.
- Path with `~` expansion is preserved in serialization.

If additional test coverage is needed, add a test that validates the JSON patch flow matches what the frontend sends:
```rust
#[test]
fn content_sources_json_patch_roundtrip() {
    // Simulate the JSON the frontend would send via PATCH
    let patch = serde_json::json!({
        "content_sources": {
            "sources": [{
                "source_type": "local_fs",
                "path": "~/notes/vault",
                "watch": true,
                "file_patterns": ["*.md", "*.txt"],
                "loop_back_enabled": true
            }]
        }
    });
    // Parse through Config to verify it deserializes correctly
    let config: Config = serde_json::from_value(patch).unwrap();
    assert_eq!(config.content_sources.sources.len(), 1);
    assert_eq!(config.content_sources.sources[0].path.as_deref(), Some("~/notes/vault"));
}
```

#### Step 5.2: Frontend type-check
```bash
cd dashboard && npm run check
```

#### Step 5.3: Full CI checklist
```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
cd dashboard && npm run check
```

### Phase 6: Handoff document

Create `docs/roadmap/cold-start-watchtower-rag/session-05-handoff.md` with:
- Summary of what was built.
- Desktop-only vs browser behavior table.
- Known limitations (v1: single source, file_patterns read-only in UI).
- Next session inputs for Session 06 (Google Drive adapter).

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| `tauri-plugin-dialog` version mismatch with other Tauri 2.0-rc plugins | Build failure | Use same `"2.0.0-rc"` version as existing plugins. Check Cargo.lock for compatible resolution. |
| `AppState` compile gap blocks all Rust tests | All tests fail | Fix this first in Phase 1 before any other work. |
| Dynamic import of dialog plugin fails silently in SSR | Browse button appears broken | Only check `isTauri` in `onMount` (client-side only). The text input is always available as fallback. |
| `merge_toml` array replacement semantics | PATCH with sources array might not replace correctly | `merge_toml` replaces non-table values (arrays are replaced wholesale), which is the desired behavior for sources. Verify with a manual test. |
| TOML serialization of `[[content_sources.sources]]` array of tables | Could produce invalid TOML | `toml::to_string_pretty` handles this correctly — it serializes `Vec<ContentSourceEntry>` as TOML array of tables. Already verified by existing `content_sources_config_serde_roundtrip` test. |
| Onboarding step index shift breaks existing validation logic | Users stuck at wrong step | Carefully update all `case` numbers in `canAdvance()` and the step rendering conditionals. |

---

## What Is NOT Changing

- **Config types** (`crates/tuitbot-core/src/config/types.rs`): `ContentSourcesConfig` and `ContentSourceEntry` already exist and are complete.
- **Server settings routes** (`crates/tuitbot-server/src/routes/settings.rs`): Generic PATCH/GET already handles `content_sources` through serde — no endpoint changes needed.
- **Config `mod.rs`**: Already exports `ContentSourcesConfig` and has `#[serde(default)]` on the `content_sources` field.
- **Server `state.rs`**: Already has `watchtower_cancel` and `content_sources` fields.
- **Existing behavior**: All existing settings sections, onboarding steps (0-4), and API endpoints remain unchanged.

---

## Verification Steps

1. **Rust compiles** after Phase 1 (the lib.rs fix is critical).
2. **Config round-trip**: Write a content source via `PATCH /api/settings`, read it back via `GET /api/settings`, verify `content_sources.sources[0].path` matches.
3. **Settings UI**: Load settings page → Sources section visible → enter path → save → reload → path persists.
4. **Tauri Browse**: In Tauri dev mode, click Browse → native folder picker opens → selected path populates the field.
5. **Browser fallback**: In browser (`npm run dev`), Browse button is hidden → manual text input is the only option.
6. **Onboarding**: Step 5 (Sources) appears → can be skipped → if path entered, it's included in the init config payload → config file contains `[[content_sources.sources]]` section.
7. **CI passes**: All four quality gate commands pass cleanly.
