# Session 08 — Deployment Mode Source Capabilities: Implementation Plan

## Context

Sessions 01–07 built the Watchtower ingest pipeline (local FS + Google Drive), Winning DNA retrieval, and the dashboard UX. The current source model assumes every deployment can use every source type — `local_fs` with filesystem path access is presented everywhere, including a future cloud-hosted tier where the server has no access to the user's local machine.

This session introduces a **deployment capability model** that lets the backend tell the frontend which source types are valid in the current deployment context (desktop, self-host, cloud), so the UI never offers impossible options and validation rejects them before they persist.

## Key Design Decisions

### D1: Deployment mode as a typed enum in config, not a runtime flag

The BACKLOG doc describes `--mode self-host` vs `--mode cloud`, but the codebase already uses `OperatingMode` (Autopilot/Composer) in config — a separate concept. We introduce `DeploymentMode` as a new enum:

```rust
#[derive(Debug, Clone, Default, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum DeploymentMode {
    #[default]
    Desktop,
    SelfHost,
    Cloud,
}
```

**Rationale**: The deployment mode is orthogonal to operating mode (autopilot/composer). A cloud user can run in composer mode. A desktop user can run in autopilot mode. They're independent axes.

**Setting the mode**: Via `TUITBOT_DEPLOYMENT_MODE` env var (for Docker/cloud) or the Tauri sidecar (sets it programmatically). Defaults to `Desktop` to preserve existing behavior. The env var pattern follows the existing `TUITBOT_MODE` precedent.

### D2: Capabilities are derived from deployment mode, not configured directly

Rather than letting operators configure individual capabilities, the capability set is a pure function of `DeploymentMode`. This prevents misconfiguration and keeps the model simple:

| Capability | Desktop | SelfHost | Cloud |
|-----------|---------|----------|-------|
| `local_folder` | Yes | Yes | **No** |
| `manual_local_path` | Yes | Yes | **No** |
| `google_drive` | Yes | Yes | Yes |
| `inline_ingest` | Yes | Yes | Yes |
| `file_picker_native` | Yes | No | No |

**Rationale**: Capabilities are deployment-environment facts, not user preferences. A cloud server can't access `~/notes/vault`, period. Deriving from mode prevents invalid states.

### D3: Capability payload exposed via runtime status endpoint

Rather than creating a new endpoint, extend `GET /api/runtime/status` to include a `capabilities` field. The runtime status is already fetched early by the dashboard and is the natural place for environment metadata.

```json
{
  "running": true,
  "task_count": 4,
  "deployment_mode": "desktop",
  "capabilities": {
    "local_folder": true,
    "manual_local_path": true,
    "google_drive": true,
    "inline_ingest": true,
    "file_picker_native": true
  }
}
```

**Rationale**: Avoids a new endpoint. The runtime status route is lightweight, already consumed on app load, and doesn't require auth for read. The capability payload is small and cacheable.

### D4: Validation rejects local_fs sources in cloud mode

The validation path in `config/validation.rs` gains a deployment-mode-aware check: if mode is `Cloud` and any source has `source_type = "local_fs"`, it's an error. The `PATCH /api/settings` flow already runs validation, so this catches attempts to save invalid configs through any path.

### D5: Pre-existing local configs are preserved via migration rules

- **Desktop/SelfHost**: All existing configs remain valid. No migration needed.
- **Cloud**: If a cloud server starts with a config containing `local_fs` sources, the server logs a warning and skips those sources (sets their status to `"disabled_by_mode"` in `source_contexts`). It does NOT delete them from config, allowing easy migration back to self-host.

## Files to Create

### 1. `docs/roadmap/cold-start-watchtower-rag/deployment-capability-matrix.md`
New documentation file defining the three deployment modes and their capability matrices. This is the authoritative reference for which source types are legal where.

### 2. `docs/roadmap/cold-start-watchtower-rag/session-08-handoff.md`
Session handoff document with summary, open items, and next-session inputs.

## Files to Modify

### 3. `crates/tuitbot-core/src/config/types.rs`
- Add `DeploymentMode` enum (Desktop, SelfHost, Cloud) with serde support
- Add `DeploymentCapabilities` struct with boolean fields for each capability
- Add `DeploymentMode::capabilities(&self) -> DeploymentCapabilities` method
- Add `DeploymentMode::allows_source_type(&self, source_type: &str) -> bool` convenience method

### 4. `crates/tuitbot-core/src/config/mod.rs`
- Add `deployment_mode: DeploymentMode` field to `Config` struct (with `#[serde(default)]`)
- Re-export `DeploymentMode` and `DeploymentCapabilities` from the module
- Add `Config::deployment_capabilities(&self) -> DeploymentCapabilities` delegate method

### 5. `crates/tuitbot-core/src/config/env_overrides.rs`
- Add `TUITBOT_DEPLOYMENT_MODE` env var override (desktop/self_host/cloud)

### 6. `crates/tuitbot-core/src/config/validation.rs`
- Add validation: reject `local_fs` sources when `deployment_mode == Cloud`
- Add validation: reject sources with `path` set when `deployment_mode == Cloud`
- New `validate_source_capabilities()` function that checks each source entry against `deployment_mode.capabilities()`

### 7. `crates/tuitbot-core/src/config/tests.rs`
- Test: `DeploymentMode::Desktop` allows `local_fs` and `google_drive`
- Test: `DeploymentMode::SelfHost` allows `local_fs` and `google_drive`
- Test: `DeploymentMode::Cloud` rejects `local_fs`, allows `google_drive`
- Test: `DeploymentMode` serde roundtrip (TOML + JSON)
- Test: `TUITBOT_DEPLOYMENT_MODE` env var override
- Test: validation fails for `local_fs` source in cloud mode
- Test: validation passes for `google_drive` source in cloud mode
- Test: existing configs without `deployment_mode` default to Desktop

### 8. `crates/tuitbot-server/src/routes/runtime.rs`
- Extend `status()` response to include `deployment_mode` and `capabilities` fields
- Import `DeploymentCapabilities` from core config
- Read deployment mode from `AppState` (requires AppState change)

### 9. `crates/tuitbot-server/src/state.rs`
- Add `deployment_mode: DeploymentMode` field to `AppState`
- Import from `tuitbot_core::config::DeploymentMode`

### 10. `crates/tuitbot-server/src/routes/settings.rs`
- In `validate_settings()` and `patch_settings()`: pass deployment mode context to validation
- The `Config::validate()` method already receives `&self` which will include deployment_mode

### 11. `dashboard/src/lib/api.ts`
- Add `DeploymentCapabilities` interface
- Update `RuntimeStatus` response type to include `deployment_mode` and `capabilities`
- Add `api.runtime.status()` method (currently inline; formalize if needed)
- Add capability helper: `hasCapability(caps: DeploymentCapabilities, key: string): boolean`

### 12. `docs/architecture.md`
- Add "Deployment Modes" section documenting the three-mode model
- Update "Content Source Pipeline" section to note capability gating
- Document that `DeploymentMode` is orthogonal to `OperatingMode`

### 13. `docs/configuration.md`
- Add `deployment_mode` to the config sections table
- Document `TUITBOT_DEPLOYMENT_MODE` env var
- Add "Deployment Mode" section explaining the three modes
- Update "Content Sources" section to note per-mode availability

## Order of Operations

### Phase 1: Core types and capabilities (types.rs, mod.rs)
1. Add `DeploymentMode` enum to `config/types.rs`
2. Add `DeploymentCapabilities` struct to `config/types.rs`
3. Implement `DeploymentMode::capabilities()` and `allows_source_type()`
4. Add `deployment_mode` field to `Config` in `config/mod.rs`
5. Re-export new types from `config/mod.rs`

### Phase 2: Env var support (env_overrides.rs)
6. Add `TUITBOT_DEPLOYMENT_MODE` parsing to `apply_env_overrides()`

### Phase 3: Validation (validation.rs)
7. Add `validate_source_capabilities()` to `Config::validate()`
8. Source entries with incompatible types produce `ConfigError::InvalidValue`

### Phase 4: Tests (tests.rs)
9. Add all unit tests for DeploymentMode, capabilities, validation
10. Run `cargo test -p tuitbot-core` to verify

### Phase 5: Server state and routes (state.rs, runtime.rs, settings.rs)
11. Add `deployment_mode` to `AppState`
12. Extend `runtime::status()` to return capabilities
13. Ensure settings validation path includes deployment mode context

### Phase 6: Frontend types (api.ts)
14. Add `DeploymentCapabilities` interface
15. Update runtime status response type

### Phase 7: Documentation
16. Create `deployment-capability-matrix.md`
17. Update `architecture.md`
18. Update `configuration.md`

### Phase 8: CI and handoff
19. Run full CI checklist: `cargo fmt --all && cargo fmt --all --check && RUSTFLAGS="-D warnings" cargo test --workspace && cargo clippy --workspace -- -D warnings`
20. Run `cd dashboard && npm run check`
21. Write `session-08-handoff.md`

## Risks and Mitigations

### R1: Breaking existing Config deserialization
**Risk**: Adding `deployment_mode` to Config breaks existing TOML files that lack it.
**Mitigation**: `#[serde(default)]` on the field defaults to `Desktop`. The `content_sources_optional_in_config` test pattern already validates this. Add a specific test for configs without `deployment_mode`.

### R2: Validation rejecting existing configs on cloud deploy
**Risk**: A user exports their desktop config (with local_fs sources) and deploys to cloud — validation fails on startup, server won't start.
**Mitigation**: The validation change only affects the `validate()` path, not `load()`. The server loads config first, then validates. For cloud mode specifically, log a warning for incompatible sources but don't block startup. Validation errors are returned to the UI via PATCH/POST but don't crash the server. Add a `validate_with_mode()` method that takes deployment mode as context, leaving `validate()` as-is for backward compatibility.

**Updated approach**: Rather than modifying `validate()` (which is called from many places), add a separate `validate_source_deployment_compatibility()` method on Config. The server calls this at startup (warning-only) and the settings routes call it alongside `validate()` (error on save). This separates load-time leniency from save-time strictness.

### R3: DeploymentMode scope creep
**Risk**: Other systems (auth, billing, multi-tenant) might want to key off DeploymentMode, bloating this PR.
**Mitigation**: This session only touches source-related capability gating. The DeploymentMode enum and capability struct are purposely minimal. Future sessions can extend capabilities without changing the core pattern.

### R4: Tauri sidecar needs to set Desktop mode
**Risk**: The Tauri app currently doesn't set deployment mode — it just starts tuitbot-server.
**Mitigation**: Desktop is the default. Tauri doesn't need to change. Only Docker/cloud need explicit `TUITBOT_DEPLOYMENT_MODE=self_host` or `cloud`.

### R5: AppState construction in existing tests
**Risk**: Adding a field to AppState breaks server tests that construct it.
**Mitigation**: `DeploymentMode` implements `Default` (= Desktop). Any test using `..Default::default()` or constructing AppState will need the field, but it defaults safely. Audit all AppState construction sites.

## Verification Steps

1. **Unit tests**: `cargo test -p tuitbot-core -- deployment_mode` — all new tests pass
2. **Full test suite**: `RUSTFLAGS="-D warnings" cargo test --workspace` — no regressions
3. **Clippy**: `cargo clippy --workspace -- -D warnings` — zero warnings
4. **Format**: `cargo fmt --all && cargo fmt --all --check` — clean
5. **Frontend check**: `cd dashboard && npm run check` — zero errors
6. **Manual smoke test**: Start server, hit `GET /api/runtime/status`, verify `deployment_mode` and `capabilities` fields appear
7. **Backward compat**: Parse a config.toml without `deployment_mode` field — should default to Desktop with all local capabilities enabled

## Detailed Implementation Specs

### DeploymentMode enum (types.rs)

```rust
/// Deployment environment controlling which features and source types are available.
///
/// - **Desktop**: Native Tauri app. Full local filesystem access + file picker.
/// - **SelfHost**: Docker/VPS browser UI. Local filesystem access (server-side).
/// - **Cloud**: Managed cloud at app.tuitbot.dev. No local filesystem access.
#[derive(Debug, Clone, Default, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum DeploymentMode {
    #[default]
    Desktop,
    SelfHost,
    Cloud,
}

impl std::fmt::Display for DeploymentMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeploymentMode::Desktop => write!(f, "desktop"),
            DeploymentMode::SelfHost => write!(f, "self_host"),
            DeploymentMode::Cloud => write!(f, "cloud"),
        }
    }
}
```

### DeploymentCapabilities struct (types.rs)

```rust
/// Capabilities available in the current deployment mode.
///
/// The frontend uses this to conditionally render source type options
/// and the backend uses it to validate source configurations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeploymentCapabilities {
    /// Server can read from local filesystem paths.
    pub local_folder: bool,
    /// User can type a local path (browser text input, not native picker).
    pub manual_local_path: bool,
    /// Google Drive remote source is available.
    pub google_drive: bool,
    /// Direct content ingest via POST /api/ingest.
    pub inline_ingest: bool,
    /// Native file picker dialog (Tauri only).
    pub file_picker_native: bool,
}

impl DeploymentMode {
    /// Returns the set of capabilities for this deployment mode.
    pub fn capabilities(&self) -> DeploymentCapabilities {
        match self {
            DeploymentMode::Desktop => DeploymentCapabilities {
                local_folder: true,
                manual_local_path: true,
                google_drive: true,
                inline_ingest: true,
                file_picker_native: true,
            },
            DeploymentMode::SelfHost => DeploymentCapabilities {
                local_folder: true,
                manual_local_path: true,
                google_drive: true,
                inline_ingest: true,
                file_picker_native: false,
            },
            DeploymentMode::Cloud => DeploymentCapabilities {
                local_folder: false,
                manual_local_path: false,
                google_drive: true,
                inline_ingest: true,
                file_picker_native: false,
            },
        }
    }

    /// Returns `true` if the given source type is allowed in this mode.
    pub fn allows_source_type(&self, source_type: &str) -> bool {
        let caps = self.capabilities();
        match source_type {
            "local_fs" => caps.local_folder,
            "google_drive" => caps.google_drive,
            "manual" => caps.inline_ingest,
            _ => false,
        }
    }
}
```

### Config changes (mod.rs)

Add field after `circuit_breaker`:

```rust
/// Deployment mode: desktop (default), self_host, or cloud.
#[serde(default)]
pub deployment_mode: DeploymentMode,
```

### Env override (env_overrides.rs)

```rust
// Deployment mode
if let Ok(val) = env::var("TUITBOT_DEPLOYMENT_MODE") {
    match val.to_lowercase().as_str() {
        "desktop" => self.deployment_mode = DeploymentMode::Desktop,
        "self_host" | "selfhost" | "self-host" => {
            self.deployment_mode = DeploymentMode::SelfHost
        }
        "cloud" => self.deployment_mode = DeploymentMode::Cloud,
        other => {
            return Err(ConfigError::InvalidValue {
                field: "deployment_mode".to_string(),
                message: format!(
                    "invalid deployment mode '{other}', expected 'desktop', 'self_host', or 'cloud'"
                ),
            });
        }
    }
}
```

### Validation (validation.rs)

Add at the end of `validate()`, before the error-return block:

```rust
// Validate content sources against deployment capabilities
for (i, source) in self.content_sources.sources.iter().enumerate() {
    if !self.deployment_mode.allows_source_type(&source.source_type) {
        errors.push(ConfigError::InvalidValue {
            field: format!("content_sources.sources[{}].source_type", i),
            message: format!(
                "source type '{}' is not available in {} deployment mode",
                source.source_type, self.deployment_mode
            ),
        });
    }
}
```

### Runtime status extension (runtime.rs)

```rust
pub async fn status(
    State(state): State<Arc<AppState>>,
    ctx: AccountContext,
) -> Result<Json<Value>, ApiError> {
    let runtimes = state.runtimes.lock().await;
    let runtime = runtimes.get(&ctx.account_id);
    let running = runtime.is_some();
    let task_count = runtime.map_or(0, |r| r.task_count());
    let capabilities = state.deployment_mode.capabilities();

    Ok(Json(json!({
        "running": running,
        "task_count": task_count,
        "deployment_mode": state.deployment_mode,
        "capabilities": capabilities,
    })))
}
```

### Frontend types (api.ts)

```typescript
export interface DeploymentCapabilities {
    local_folder: boolean;
    manual_local_path: boolean;
    google_drive: boolean;
    inline_ingest: boolean;
    file_picker_native: boolean;
}

// Update the runtime.status response type:
export interface RuntimeStatus {
    running: boolean;
    task_count: number;
    deployment_mode: 'desktop' | 'self_host' | 'cloud';
    capabilities: DeploymentCapabilities;
}
```

Update `api.runtime` section (currently uses inline `request<Json<Value>>`):
```typescript
runtime: {
    status: () => request<RuntimeStatus>('/api/runtime/status'),
    start: () => request<{ status: string }>('/api/runtime/start', { method: 'POST' }),
    stop: () => request<{ status: string }>('/api/runtime/stop', { method: 'POST' }),
},
```

Note: The existing api.ts doesn't have a `runtime` namespace. The runtime routes are not currently wrapped in the api object. We need to add them.

### AppState change (state.rs)

Add field:
```rust
/// Deployment mode (desktop, self_host, or cloud).
pub deployment_mode: DeploymentMode,
```

This requires updating the AppState construction site in `main.rs` or wherever the server binary creates it. Need to find that location.

## Open Questions (to resolve during implementation)

1. **AppState construction**: Where exactly is AppState created in the server binary? Need to find and update that call site to pass `config.deployment_mode`.

2. **Watchtower startup guard**: Should the Watchtower loop skip local_fs sources in cloud mode silently, or refuse to start? Recommendation: skip with a log warning, since the config might have been imported from a desktop setup.

3. **Settings PATCH validation**: When a cloud user tries to PATCH settings with a local_fs source, should it be rejected at the API level (400) or just return validation errors? Recommendation: return validation errors via the existing `validate` flow — consistent with how other invalid settings are handled.

## Definition of Done

- [x] `DeploymentMode` enum and `DeploymentCapabilities` struct in core config
- [x] `TUITBOT_DEPLOYMENT_MODE` env var support
- [x] Validation rejects local_fs sources in cloud mode
- [x] Runtime status endpoint returns deployment mode and capabilities
- [x] Frontend types updated for capability-aware rendering
- [x] `deployment-capability-matrix.md` documents the three modes
- [x] `architecture.md` and `configuration.md` updated
- [x] All CI gates pass: fmt, test, clippy, svelte-check
- [x] `session-08-handoff.md` written with next-session inputs
