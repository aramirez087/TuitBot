# Session 06 — Google Drive Source Adapter: Implementation Plan

## Objective

Add Google Drive as a provider-backed content source that feeds the same ingest pipeline and Winning DNA workflow as local folders. Refactor source handling to support a shared ingest queue and unified source-state model across local and remote providers.

---

## Current State (Post-Session 05)

- `ContentSourceEntry` in `config/types.rs` models `source_type` as a string (`"local_fs"` default), with `path: Option<String>` and fields for `watch`, `file_patterns`, `loop_back_enabled`.
- `WatchtowerLoop` in `automation/watchtower/mod.rs` (572 lines) is hardcoded to local filesystem: uses `notify` watcher, reads files via `tokio::fs`, builds source map from entries with `path.is_some()`.
- Storage layer (`storage/watchtower/mod.rs`, 651 lines) has `ensure_local_fs_source()` and `find_source_by_path()` — both specific to `local_fs` type. Source contexts table already stores `source_type` and `config_json` generically.
- Ingest pipeline (`ingest_file()`, `ingest_files()`) takes `base_path: &Path` and `relative_path: &str` — filesystem-specific signatures.
- Server ingest route (`routes/ingest.rs`) looks for the first `local_fs` source to resolve base path.
- Dashboard (`ContentSourcesSection.svelte`, `SourcesStep.svelte`) only handles `sources[0]` of type `local_fs`.
- `AppState` stores `content_sources: ContentSourcesConfig` directly.

**No trait abstraction exists** — the architecture-decisions.md defines a `ContentSource` trait but it was never implemented. Sessions 02-05 built concrete local-fs support.

---

## Key Design Decisions

### D1: No real Google Drive API calls in v1 — stub adapter with defined contract

**Rationale:** The operator rules say "local-first, no external services required to boot." A real Google Drive OAuth flow + API client is a heavy dependency (OAuth token refresh, Google API crate). Instead:

1. Define the `ContentSourceProvider` async trait that both local and remote sources implement.
2. Build a `GoogleDriveProvider` struct that implements the trait but uses `reqwest` for Google Drive REST API v3 (files.list, files.get export).
3. The provider is instantiated only when a `google_drive` source is configured with valid credentials.
4. For tests: build a `MockRemoteProvider` that implements the same trait and validates the provider dispatch and dedup logic.

This keeps the project buildable and testable without Google credentials while establishing the exact contract a real adapter uses.

### D2: Provider trait abstracts content reading, not watching

**Rationale:** Local sources use `notify` for real-time filesystem watching. Remote sources poll on an interval. Rather than forcing both into a unified "watch" abstraction, the trait covers scan + read + write, and `WatchtowerLoop` dispatches differently:

- **Local sources**: `notify` watcher + fallback polling (existing behavior, unchanged)
- **Remote sources**: Polling loop only, using `scan_for_changes()` with `sync_cursor`

The `WatchtowerLoop` orchestrates both, but each provider only needs to implement the stateless read operations.

### D3: Extend `ContentSourceEntry` with optional Google Drive fields

Rather than a discriminated union of separate config structs, keep `ContentSourceEntry` flat with optional fields. This preserves backward compatibility with existing TOML configs and the generic PATCH settings flow:

```rust
pub struct ContentSourceEntry {
    pub source_type: String,           // "local_fs" | "google_drive"
    pub path: Option<String>,          // local_fs: filesystem path
    pub folder_id: Option<String>,     // google_drive: folder ID
    pub service_account_key: Option<String>, // google_drive: service account JSON path
    pub watch: bool,
    pub file_patterns: Vec<String>,
    pub loop_back_enabled: bool,
    pub poll_interval_seconds: Option<u64>, // remote sources: poll interval
}
```

**Why not an enum?** The config is serialized to TOML and patches come as JSON via the settings API. An enum would require serde tagging that complicates the existing generic merge logic in `settings.rs`. Flat optional fields are simpler and match the existing pattern (`LlmConfig.base_url` is optional per-provider).

### D4: Provider ID for remote dedup

Remote files don't have stable filesystem paths. Google Drive files have stable IDs (`fileId`). The `relative_path` field in `content_nodes` will store the provider-specific ID for remote sources (e.g., `gdrive://FILE_ID/filename.md`). Combined with `content_hash`, this gives two levels of dedup:

- **Path dedup**: `(source_id, relative_path)` unique constraint catches re-scanning the same file
- **Content dedup**: `content_hash` comparison skips unchanged content

### D5: Dashboard source-type selector with conditional fields

The settings UI adds a source-type dropdown. When `google_drive` is selected, the path input is replaced with folder ID and service account key path inputs. Watch becomes "Poll for changes" with an interval selector. Loop-back is hidden for Google Drive (not supported in v1).

---

## Files to Create

### 1. `crates/tuitbot-core/src/source/mod.rs` (NEW, ~120 lines)
Provider trait + types.

### 2. `crates/tuitbot-core/src/source/local_fs.rs` (NEW, ~100 lines)
`LocalFsProvider` — wraps existing filesystem logic behind the trait.

### 3. `crates/tuitbot-core/src/source/google_drive.rs` (NEW, ~200 lines)
`GoogleDriveProvider` — polls Google Drive API, fetches `.md`/`.txt` content, records stable file IDs.

### 4. `crates/tuitbot-core/src/source/tests.rs` (NEW, ~250 lines)
Tests for provider dispatch, dedup, trait contract.

### 5. `docs/roadmap/cold-start-watchtower-rag/google-drive-integration.md` (NEW)
Architecture decision record for the Google Drive integration.

### 6. `docs/roadmap/cold-start-watchtower-rag/session-06-handoff.md` (NEW)
Session handoff document.

## Files to Modify

### 7. `crates/tuitbot-core/src/lib.rs`
Add `pub mod source;` module declaration.

### 8. `crates/tuitbot-core/src/config/types.rs` (lines 457-502)
- Add `folder_id`, `service_account_key`, `poll_interval_seconds` optional fields to `ContentSourceEntry`.
- Add default functions for new fields.

### 9. `crates/tuitbot-core/src/automation/watchtower/mod.rs` (572 lines)
- Refactor `WatchtowerLoop::run()` to split source setup into local vs. remote paths.
- Add a `poll_remote_sources()` method that calls `scan_for_changes()` + `read_content()` on remote providers.
- Introduce `ingest_content()` — a provider-agnostic ingest function that takes body text + metadata directly (extracted from `ingest_file()` filesystem-specific reading).
- Keep `ingest_file()` as a convenience wrapper that reads from disk then calls `ingest_content()`.

### 10. `crates/tuitbot-core/src/storage/watchtower/mod.rs` (651 lines)
- Add `ensure_google_drive_source(pool, folder_id, config_json) -> i64` — idempotent registration for GDrive sources.
- Add `find_source_by_folder_id(pool, folder_id) -> Option<SourceContext>` — lookup by folder ID in config_json.

### 11. `crates/tuitbot-core/src/config/tests.rs`
- Add `content_sources_google_drive_roundtrip` — TOML with `source_type = "google_drive"` + folder_id + service_account_key.
- Add `content_sources_mixed_sources_roundtrip` — TOML with one local_fs and one google_drive source.
- Add `content_sources_google_drive_json_patch` — JSON patch from frontend with GDrive fields.

### 12. `crates/tuitbot-core/Cargo.toml`
- No new dependencies needed. `reqwest` (already present), `sha2` (already present), `serde_json` (already present) are sufficient for the Google Drive REST API adapter.

### 13. `crates/tuitbot-server/src/routes/ingest.rs` (167 lines)
- Extend file_hints handling to check for `google_drive` sources alongside `local_fs`.
- For GDrive sources, resolve files through the provider instead of filesystem paths.

### 14. `crates/tuitbot-server/src/routes/settings.rs`
- No changes needed — the generic JSON→TOML merge already handles new optional fields.

### 15. `dashboard/src/lib/api.ts` (lines 406-414)
- Extend the `content_sources.sources` array type with optional `folder_id`, `service_account_key`, `poll_interval_seconds`.

### 16. `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte` (314 lines)
- Add source-type selector (radio buttons or dropdown): Local Folder / Google Drive.
- Conditional rendering: local fields (path + Browse) vs. GDrive fields (folder ID + service account key path).
- Hide loop-back toggle for Google Drive.
- Show poll interval for Google Drive.

### 17. `dashboard/src/routes/onboarding/+page.svelte` (387 lines)
- Extend submit logic to include new fields when source_type is `google_drive`.

### 18. `dashboard/src/lib/components/onboarding/SourcesStep.svelte` (285 lines)
- Add source-type selector.
- Conditional rendering for local vs. GDrive fields.
- Update onboarding store sync to include new fields.

### 19. `dashboard/src/lib/stores/onboarding.ts`
- Add `source_type`, `folder_id`, `service_account_key`, `poll_interval_seconds` fields.

---

## Order of Operations

### Phase 1: Foundation — Provider Trait and Config (Steps 1-4)

**Step 1: Define the `ContentSourceProvider` trait** (`source/mod.rs`)

```rust
#[async_trait]
pub trait ContentSourceProvider: Send + Sync {
    fn source_type(&self) -> &str;

    async fn scan_for_changes(
        &self,
        since: Option<&str>,  // sync_cursor from DB
        patterns: &[String],
    ) -> Result<Vec<SourceFile>, SourceError>;

    async fn read_content(&self, file_id: &str) -> Result<String, SourceError>;
}

pub struct SourceFile {
    pub provider_id: String,    // stable ID (filepath for local, fileId for GDrive)
    pub display_name: String,   // human-readable name
    pub content_hash: String,   // SHA-256
    pub modified_at: String,    // RFC3339
}

#[derive(Debug, thiserror::Error)]
pub enum SourceError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("network error: {0}")]
    Network(String),
    #[error("auth error: {0}")]
    Auth(String),
    #[error("not found: {0}")]
    NotFound(String),
}
```

**Step 2: Implement `LocalFsProvider`** (`source/local_fs.rs`)

Wraps existing directory walking + file reading logic. `scan_for_changes` does what `WatchtowerLoop::walk_directory` does today. `read_content` reads via `tokio::fs::read_to_string`. This is a thin wrapper — the existing code moves behind the trait.

**Step 3: Extend `ContentSourceEntry` config** (`config/types.rs`)

Add optional fields: `folder_id`, `service_account_key`, `poll_interval_seconds`. Add serde defaults.

**Step 4: Add config round-trip tests** (`config/tests.rs`)

Three new tests for google_drive TOML, mixed sources, and JSON patch.

### Phase 2: Google Drive Provider (Steps 5-6)

**Step 5: Implement `GoogleDriveProvider`** (`source/google_drive.rs`)

```rust
pub struct GoogleDriveProvider {
    folder_id: String,
    service_account_key_path: String,
    http_client: reqwest::Client,
}
```

Implementation:
- `scan_for_changes()`: Uses Google Drive API v3 `files.list` with `q` parameter filtering by folder, mimeType (text/markdown, text/plain), and `modifiedTime > cursor`. Returns `SourceFile` with `fileId` as `provider_id`.
- `read_content()`: Uses `files.get?alt=media` to download file content, or `files.export` for Google Docs.
- Auth: Reads service account JSON key, generates JWT, exchanges for access token. Token cached in-memory with expiry.
- No loop-back support (read-only for v1).

**Step 6: Add provider tests** (`source/tests.rs`)

- Mock HTTP responses for list/get using `wiremock`.
- Test: provider returns correct SourceFiles from mocked list response.
- Test: read_content returns body from mocked get response.
- Test: scan_for_changes with cursor filters correctly.
- Test: auth error surfaces as SourceError::Auth.

### Phase 3: Refactor Watchtower for Provider Dispatch (Steps 7-9)

**Step 7: Extract `ingest_content()` from `ingest_file()`** (`automation/watchtower/mod.rs`)

Create a new function that takes raw text content and metadata instead of reading from filesystem:

```rust
pub async fn ingest_content(
    pool: &DbPool,
    source_id: i64,
    provider_id: &str,  // relative_path for local, gdrive://id for remote
    content: &str,
    force: bool,
) -> Result<store::UpsertResult, WatchtowerError> {
    let (fm, body) = parse_front_matter(content);
    let hash = compute_hash(content, force);
    store::upsert_content_node(pool, source_id, provider_id, &hash, fm.title.as_deref(), body, fm.raw_yaml.as_deref(), fm.tags.as_deref()).await?
}
```

Rewrite `ingest_file()` as: read from disk → call `ingest_content()`. This keeps backward compatibility.

**Step 8: Add remote polling to WatchtowerLoop** (`automation/watchtower/mod.rs`)

Add a `poll_remote_sources()` method:

```rust
async fn poll_remote_sources(
    &self,
    remote_sources: &[(i64, Box<dyn ContentSourceProvider>, Vec<String>)],
) {
    for (source_id, provider, patterns) in remote_sources {
        let cursor = store::get_source_context(&self.pool, *source_id).await?.sync_cursor;
        match provider.scan_for_changes(cursor.as_deref(), patterns).await {
            Ok(files) => {
                for file in files {
                    match provider.read_content(&file.provider_id).await {
                        Ok(content) => {
                            ingest_content(&self.pool, *source_id, &file.provider_id, &content, false).await;
                        }
                        Err(e) => tracing::warn!(...)
                    }
                }
                store::update_sync_cursor(&self.pool, *source_id, &chrono::Utc::now().to_rfc3339()).await;
            }
            Err(e) => {
                store::update_source_status(&self.pool, *source_id, "error", Some(&e.to_string())).await;
            }
        }
    }
}
```

The main `run()` method splits sources into local (existing watcher path) and remote (polling path), running them concurrently:

```rust
tokio::select! {
    () = cancel.cancelled() => break,
    _ = local_watcher_events => { ... }
    _ = remote_poll_timer.tick() => {
        self.poll_remote_sources(&remote_sources).await;
    }
}
```

**Step 9: Add storage helpers** (`storage/watchtower/mod.rs`)

- `ensure_google_drive_source(pool, folder_id, config_json) -> i64` — idempotent, similar to `ensure_local_fs_source`.
- `find_source_by_folder_id(pool, folder_id) -> Option<SourceContext>` — queries config_json for folder_id.

### Phase 4: Server Integration (Step 10)

**Step 10: Update ingest route** (`routes/ingest.rs`)

Extend the file_hints logic to also check for `google_drive` sources. For remote sources, file_hints are treated as provider IDs and routed through the provider's `read_content()`. This is a small change — the inline_nodes path is already provider-agnostic.

### Phase 5: Dashboard UI (Steps 11-14)

**Step 11: Extend TypeScript types** (`api.ts`)

Add to the content_sources source type:
```typescript
sources: Array<{
    source_type: string;
    path: string | null;
    folder_id: string | null;        // NEW
    service_account_key: string | null; // NEW
    poll_interval_seconds: number | null; // NEW
    watch: boolean;
    file_patterns: string[];
    loop_back_enabled: boolean;
}>;
```

**Step 12: Update `ContentSourcesSection.svelte`**

- Add a source-type selector at the top: `<select>` with "Local Folder" and "Google Drive" options.
- Conditionally show path/Browse (for local_fs) or folder_id + service_account_key (for google_drive).
- Hide loop-back toggle for google_drive.
- Show poll_interval_seconds input for google_drive (default: 300 = 5 minutes).
- The `updateSource()` function passes all fields through, with unused fields as null.

**Step 13: Update `SourcesStep.svelte`**

- Add source-type selector.
- Conditional fields.
- Sync new fields to onboarding store.

**Step 14: Update onboarding store and submission** (`onboarding.ts`, `+page.svelte`)

- Add new fields to store.
- Extend submit to include google_drive fields when source_type is google_drive.

### Phase 6: Documentation and Handoff (Steps 15-16)

**Step 15: Write `google-drive-integration.md`**

Document the provider trait contract, Google Drive adapter design, auth flow, limitations, and future improvements.

**Step 16: Write `session-06-handoff.md`**

Document what was built, quality gate results, and next session inputs.

---

## Risks and Mitigations

### R1: File size — `watchtower/mod.rs` is at 572 lines

**Risk:** Adding remote polling could push it past the 500-line limit.

**Mitigation:** Extract `ingest_content()` and the remote polling logic into a new `provider_sync.rs` submodule. The main `mod.rs` keeps the WatchtowerLoop orchestrator, imports sync functions from the submodule. This may also warrant moving existing ingest functions.

### R2: Google Drive auth complexity

**Risk:** Service account JWT generation + token exchange is non-trivial and adds real network dependency.

**Mitigation:** Implement auth as a separate module within the provider. For tests, mock at the HTTP level with wiremock. For development, the provider gracefully returns `SourceError::Auth` if credentials are missing or invalid, and the WatchtowerLoop marks the source status as "error" without crashing.

### R3: Breaking existing local-fs behavior

**Risk:** Refactoring `ingest_file()` to go through `ingest_content()` could introduce regressions.

**Mitigation:**
1. `ingest_file()` remains the public API for filesystem paths — it just delegates internally.
2. All existing tests continue to call `ingest_file()` and must pass unchanged.
3. New tests validate `ingest_content()` directly for the remote path.

### R4: Config backward compatibility

**Risk:** Adding new fields to `ContentSourceEntry` could break existing `config.toml` files.

**Mitigation:** All new fields are `Option<T>` with `#[serde(default)]`. Existing configs deserialize without changes. The settings PATCH API already handles null/missing fields via generic merge.

### R5: Dashboard complexity — conditional rendering

**Risk:** `ContentSourcesSection.svelte` at 314 lines could exceed the 400-line Svelte limit.

**Mitigation:** Extract `LocalSourceFields.svelte` and `GoogleDriveFields.svelte` as sibling components. The section component handles the type selector and delegates to the appropriate field component.

### R6: `reqwest` dependency for Google Drive API

**Risk:** `reqwest` is already a dependency but Google Drive API requires specific auth headers and response parsing.

**Mitigation:** No new crate needed. Use `reqwest::Client` directly with manual JWT construction using `sha2` (already present) and `base64` (already present). For the v1 service account flow, we need to sign JWTs — check if the `rsa` or `ring` crate is needed. If so, add as an optional feature to avoid bloating builds without Google Drive.

**Resolution:** Use the `jsonwebtoken` crate (lightweight, well-maintained) for JWT signing. Add as optional dependency gated behind a `google-drive` feature flag. This keeps the default build lean.

---

## Verification Steps

### Unit Tests (cargo test)

1. **Config tests** (`config/tests.rs`):
   - `content_sources_google_drive_roundtrip` — TOML with GDrive fields
   - `content_sources_mixed_sources_roundtrip` — local + GDrive together
   - `content_sources_google_drive_json_patch` — frontend JSON shape

2. **Provider trait tests** (`source/tests.rs`):
   - `local_fs_provider_scan_returns_files` — scan a tempdir
   - `local_fs_provider_read_content` — read markdown file
   - `local_fs_provider_filters_patterns` — only matching patterns
   - `google_drive_provider_scan_mocked` — wiremock GDrive list
   - `google_drive_provider_read_mocked` — wiremock GDrive get
   - `google_drive_provider_auth_error` — invalid credentials

3. **Storage tests** (`storage/watchtower/tests.rs`):
   - `ensure_google_drive_source_creates_once` — idempotent
   - `find_source_by_folder_id_returns_match` — config_json search
   - `different_source_types_coexist` — local + GDrive in same DB

4. **Watchtower ingest tests** (`automation/watchtower/tests.rs`):
   - `ingest_content_direct_body` — bypass filesystem
   - `ingest_content_dedup_by_hash` — skip unchanged
   - `ingest_content_with_provider_id` — gdrive:// path format
   - `ingest_parity_local_vs_remote` — same content through both paths produces identical nodes

### Quality Gates (CI checklist)

```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
cd dashboard && npm run check
```

### Manual Verification

1. Existing local-fs watchtower still works: configure a local source, add a .md file, verify it gets ingested.
2. Config with `google_drive` source type parses and saves correctly via settings API.
3. Dashboard shows source-type selector; switching between local/GDrive shows correct fields.
4. Onboarding with Google Drive source type saves to config correctly.

---

## Dependency Graph

```
Phase 1 (Foundation) ← no dependencies
  Step 1: source/mod.rs (trait)
  Step 2: source/local_fs.rs (local impl)
  Step 3: config/types.rs (new fields)
  Step 4: config/tests.rs

Phase 2 (GDrive Provider) ← depends on Phase 1
  Step 5: source/google_drive.rs
  Step 6: source/tests.rs

Phase 3 (Watchtower Refactor) ← depends on Phase 1, 2
  Step 7: Extract ingest_content() ← depends on Step 1
  Step 8: Remote polling in WatchtowerLoop ← depends on Steps 5, 7
  Step 9: Storage helpers ← independent of Steps 7-8

Phase 4 (Server) ← depends on Phase 3
  Step 10: Update ingest route

Phase 5 (Dashboard) ← depends on Phase 1 (config changes)
  Steps 11-14 can run in parallel with Phases 2-4

Phase 6 (Docs) ← depends on all above
  Steps 15-16
```

**Parallelization opportunity:** Phase 5 (dashboard) only depends on the config type changes (Step 3), not the Rust provider implementation. Steps 11-14 can be done as soon as Step 3 is complete.

---

## Line Budget

| File | Current | Estimated Change | Final |
|------|---------|-----------------|-------|
| `source/mod.rs` | 0 (new) | +120 | 120 |
| `source/local_fs.rs` | 0 (new) | +100 | 100 |
| `source/google_drive.rs` | 0 (new) | +200 | 200 |
| `source/tests.rs` | 0 (new) | +250 | 250 |
| `config/types.rs` | 503 | +20 | ~523 (over limit → may need split) |
| `config/tests.rs` | ~550 | +45 | ~595 (already over; leave as-is, pre-existing) |
| `automation/watchtower/mod.rs` | 572 | -60 (extract) +80 (remote) = +20 | ~590 (over limit → extract to submodule) |
| `storage/watchtower/mod.rs` | 651 | +40 | ~690 (already over; pre-existing) |
| `routes/ingest.rs` | 167 | +20 | ~187 |
| `api.ts` | 1111 | +5 | ~1116 |
| `ContentSourcesSection.svelte` | 314 | +60 (with extraction) | ~374 (or split into sub-components) |
| `SourcesStep.svelte` | 285 | +50 | ~335 |

**Action items for file size:**
- `automation/watchtower/mod.rs`: Extract `ingest_content()` + remote polling into `automation/watchtower/provider_sync.rs` (~120 lines). Main mod drops to ~470.
- `ContentSourcesSection.svelte`: If exceeding 400 lines, extract `GoogleDriveFields.svelte` (~80 lines).

---

## Out of Scope for Session 06

- **Real OAuth browser flow**: Service account key is the auth method. Interactive OAuth for end-user Google accounts is deferred.
- **Google Docs export**: Only `.md` and `.txt` files in Drive. Google Docs conversion is a future enhancement.
- **Loop-back for Google Drive**: Read-only for v1. Writing metadata back to Drive files requires Drive API write scope.
- **Multiple sources in UI**: Still managing `sources[0]`. Multiple sources via config.toml.
- **Retry/backoff for API failures**: Simple error logging + source status update. Exponential backoff is a future improvement.
- **Webhook/push notifications**: Polling only. Drive push notifications require a public callback URL.
