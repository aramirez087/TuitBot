# Session 2 Implementation Plan — Distraction-Free Writer

## Summary

Refactor the 1,273-line ComposeModal and 858-line ThreadComposer into a `composer/` component directory, wire voice context + winning DNA into assist endpoints, and enhance the notes-to-content flow — all while keeping every file under its size limit and preserving backward compatibility.

---

## Current State Assessment

| File | Lines | Status |
|------|-------|--------|
| `ComposeModal.svelte` | 1,273 | 3.2x over 400-line limit |
| `ThreadComposer.svelte` | 858 | 2.1x over 400-line limit |
| `FromNotesPanel.svelte` | 180 | Under limit, needs enhancement |
| `TweetPreview.svelte` | 192 | Under limit, unchanged |
| `MediaSlot.svelte` | 293 | Under limit, unchanged |
| `CommandPalette.svelte` | 342 | Under limit, unchanged |
| `generator.rs` | 814 | Under 500-line limit but close; adding methods needs care |
| `assist.rs` | 277 | Under limit, room for wiring |

### Key Findings from Code Read

1. **ComposeModal.svelte** has 475 lines of `<script>` (state, handlers, effects) and 798 lines of template+CSS. The CSS alone is ~578 lines. The refactor must move both logic and styles into subcomponents.

2. **ThreadComposer.svelte** has 431 lines of `<script>` and 427 lines of template+CSS. The per-card actions markup (duplicate/split/merge/delete) and drag-drop handlers are the best extraction targets.

3. **assist.rs** handlers have access to `state.db` (for `build_draft_context`) and `state.content_generators` (for `ContentGenerator`). The `get_generator()` helper returns `Arc<ContentGenerator>`.

4. **generator.rs** already has the `generate_reply_with_context()` pattern accepting `rag_context: Option<&str>`, but `generate_tweet` and `generate_thread` lack this parameter. Adding `_with_context` variants follows the existing pattern exactly.

5. **`build_draft_context()`** signature: `(pool: &DbPool, topic_keywords: &[String], max_ancestors: u32, half_life_days: f64) -> Result<DraftContext, StorageError>`. Returns `DraftContext { prompt_block: String, ... }`. Gracefully degrades to empty string when no data exists.

6. **api.ts** `assist.improve(draft, context?)` already sends `context` to the server. `assist.tweet(topic)` and `assist.thread(topic)` only take `topic` — voice cue will be prepended to the topic string (no API contract change).

7. **Settings store** at `stores/settings.ts` provides `config` writable with `business.brand_voice`, `business.content_style`, `business.content_pillars`. `loadSettings()` populates it. The VoiceContextPanel can subscribe directly.

8. **Contract tests** (20 tests) only test `/api/content/compose` and `/api/content/drafts` — they do NOT test `/api/assist/*`. Winning DNA wiring in assist handlers cannot break these tests.

---

## Design Decisions

### D1: Component Extraction Strategy — Top-Down Peel

Extract from ComposeModal by "peeling" complete sections outward, not by rewriting from scratch. This preserves all existing behavior and makes each extraction independently testable via `npm run check`.

**Extraction order** (each step produces a working build):
1. ComposerShell (modal chrome: backdrop, header, footer, focus mode CSS)
2. TweetEditor (tweet textarea + char counter + media attachments for tweet mode)
3. VoiceContextPanel (new: voice summary + quick-cue + saved cues)
4. ThreadEditor (rename ThreadComposer, extract ThreadCardActions)
5. Slim ComposeModal to orchestrator

### D2: VoiceContextPanel Reads Settings Store Directly

No new API calls. The panel subscribes to the existing `config` store from `$lib/stores/settings`. On modal open, if `$config` is null, ComposeModal calls `loadSettings()` once. This is the simplest path — the settings store is already a writable Svelte store populated elsewhere.

### D3: Quick-Cue Threading — Prepend to Topic, Pass as Context

- **`api.assist.improve(draft, context)`**: pass the quick cue as the `context` parameter (already supported)
- **`api.assist.tweet(topic)`**: prepend cue to topic string (e.g., `"[Cue: more casual] general"`)
- **`api.assist.thread(topic)`**: same prepend strategy

This avoids any API contract changes. The server-side handler for `/api/assist/improve` already reads `body.context`. For tweet/thread, the cue becomes part of the topic prompt.

### D4: Winning DNA — Server-Side Only, Transparent to Frontend

The assist handlers in `assist.rs` will call `build_draft_context()` and inject the `prompt_block` into LLM calls. The frontend doesn't know about this. Three new `_with_context` methods in `generator.rs` follow the existing `generate_reply_with_context` pattern.

### D5: FromNotesPanel Enhancement — In-Place, No Rename

The implementation plan suggested renaming to `NotesToContentPanel.svelte`. However, the file is only 180 lines and already well-structured. Renaming adds import churn across the codebase for no functional benefit. Instead, enhance `FromNotesPanel.svelte` in-place: add the inline replacement confirmation banner, loading state, and undo capability.

### D6: Saved Cues in localStorage — MRU List

Key: `tuitbot:voice:saved-cues`. Store up to 5 most-recently-used cues as a JSON string array. On cue submission, prepend to array, deduplicate, slice to 5. Managed entirely within VoiceContextPanel — no prop drilling needed.

---

## File Manifest

| Action | File | Target Lines |
|--------|------|-------------|
| Create | `dashboard/src/lib/components/composer/ComposerShell.svelte` | ~280 |
| Create | `dashboard/src/lib/components/composer/TweetEditor.svelte` | ~180 |
| Create | `dashboard/src/lib/components/composer/VoiceContextPanel.svelte` | ~160 |
| Create | `dashboard/src/lib/components/composer/ThreadCardActions.svelte` | ~120 |
| Modify | `dashboard/src/lib/components/ComposeModal.svelte` | ~380 (down from 1,273) |
| Modify | `dashboard/src/lib/components/ThreadComposer.svelte` | ~400 (down from 858) |
| Modify | `dashboard/src/lib/components/FromNotesPanel.svelte` | ~250 (up from 180) |
| Modify | `crates/tuitbot-core/src/content/generator.rs` | ~500 (add 3 methods + tests) |
| Modify | `crates/tuitbot-server/src/routes/assist.rs` | ~320 (wire winning DNA) |
| Modify | `crates/tuitbot-server/tests/compose_contract_tests.rs` | Unchanged (verify passes) |
| Create | `docs/roadmap/typefully-beating-composer/session-02-handoff.md` | N/A |

### Files NOT Changed
- `dashboard/src/lib/api.ts` — No API contract changes needed (D3)
- `dashboard/src/lib/components/TweetPreview.svelte` — Unchanged (Session 03)
- `dashboard/src/lib/components/MediaSlot.svelte` — Unchanged
- `dashboard/src/lib/components/CommandPalette.svelte` — Unchanged
- `dashboard/src/lib/components/TimePicker.svelte` — Unchanged

---

## Detailed Implementation Steps

### Step 1: Create `composer/` Directory

```bash
mkdir -p dashboard/src/lib/components/composer
```

No code changes. Just the directory.

### Step 2: Extract ComposerShell.svelte (~280 lines)

**Source:** ComposeModal.svelte lines 479-693 (template) + 695-1273 (styles)

**What moves into ComposerShell:**
- Backdrop div with `handleBackdropClick`
- Modal container div with all class bindings (`thread-mode`, `focus-mode`)
- Recovery banner
- Modal header (title, date subtitle, focus button, close button)
- Mode tabs (tweet/thread)
- Modal footer (assist btn, notes btn, spacer, cancel, submit)
- Focus mode CSS
- All modal chrome CSS (`.backdrop`, `.modal`, `.recovery-*`, `.modal-header`, `.mode-tabs`, `.modal-footer`, all button styles, responsive overrides)

**Props for ComposerShell:**
```typescript
{
    open: boolean;
    mode: 'tweet' | 'thread';
    focusMode: boolean;
    dateLabel: string;
    canSubmit: boolean;
    submitting: boolean;
    assisting: boolean;
    tweetHasText: boolean;
    showRecovery: boolean;
    showFromNotes: boolean;
    submitError: string | null;
    onclose: () => void;
    ontogglefocus: () => void;
    onmodechange: (mode: 'tweet' | 'thread') => void;
    onsubmit: () => void;
    onaiassist: () => void;
    ontogglefromnotes: () => void;
    onrecover: () => void;
    ondismissrecovery: () => void;
    children: Snippet;  // Svelte 5 slot
}
```

**Uses Svelte 5 `{@render children()}` snippet** for the modal body content. This lets ComposeModal pass the editor area as a child while ComposerShell handles all chrome.

**Verification:** `cd dashboard && npm run check` — should typecheck cleanly.

### Step 3: Extract TweetEditor.svelte (~180 lines)

**Source:** ComposeModal.svelte lines 550-643 (tweet compose template + media attachments)

**What moves into TweetEditor:**
- Tweet textarea with `compose-input` class
- Character counter
- Media attachment grid (thumbnails + remove buttons)
- "Attach media" button section
- Hidden file input
- All tweet-mode CSS (`.tweet-compose`, `.compose-input`, `.char-counter`, `.media-*`, `.attach-*`)
- `handleFileSelect()`, `removeMedia()` functions
- Media state: `attachedMedia`, `uploading`, `fileInput`
- Constants: `ACCEPTED_TYPES`, `MAX_IMAGES`, size limits

**Props for TweetEditor:**
```typescript
{
    text: string;
    onchange: (text: string) => void;
    attachedMedia: AttachedMedia[];
    onmediachange: (media: AttachedMedia[]) => void;
    submiterror: string | null;
    onerror: (msg: string) => void;
}
```

**Exports:** `fileInput` element ref (for command palette "attach media" action)

**Key:** The `AttachedMedia` interface definition moves here (or to a shared types file if needed by multiple components). ComposeModal imports it.

**Verification:** `cd dashboard && npm run check`

### Step 4: Create VoiceContextPanel.svelte (~160 lines)

**Entirely new component.** Placed between mode tabs and editor area in the ComposerShell layout.

**State:**
- `expanded: boolean` — collapsed by default, remembers via localStorage `tuitbot:voice:expanded`
- `quickCue: string` — the current cue text
- `savedCues: string[]` — MRU list from localStorage `tuitbot:voice:saved-cues`
- Subscribes to `config` store from `$lib/stores/settings`

**Template structure:**
```
<div class="voice-context-panel" class:expanded>
  <button class="voice-toggle">  <!-- collapse/expand -->
    Voice context  <ChevronDown />
  </button>
  {#if expanded}
    <div class="voice-summary">
      {#if brandVoice}<span class="voice-chip">{truncatedBrandVoice}</span>{/if}
      {#if contentStyle}<span class="voice-chip">{contentStyle}</span>{/if}
      {#each pillars.slice(0, 3) as pillar}
        <span class="pillar-chip">{pillar}</span>
      {/each}
      {#if !hasVoiceSettings}
        <span class="voice-empty-hint">Set voice in Settings → Content Persona</span>
      {/if}
    </div>
    <div class="quick-cue-row">
      <input class="cue-input" placeholder="Add a tone cue (e.g., 'more casual')" bind:value={quickCue} />
      {#if savedCues.length > 0}
        <div class="saved-cues-dropdown">
          {#each savedCues as cue}
            <button onclick={() => quickCue = cue}>{cue}</button>
          {/each}
        </div>
      {/if}
    </div>
  {/if}
</div>
```

**Props:**
```typescript
{
    cue: string;
    oncuechange: (cue: string) => void;
}
```

**Behavior:**
- On cue input change, calls `oncuechange(cue)` so ComposeModal can thread it into assist calls
- On generation (detected by parent signaling), saves cue to MRU list
- Voice fields displayed read-only from `$config.business` — link to Settings if empty

**Verification:** `cd dashboard && npm run check`

### Step 5: Extract ThreadCardActions.svelte (~120 lines)

**Source:** ThreadComposer.svelte lines 497-534 (per-card action buttons in template)

**What moves into ThreadCardActions:**
- Duplicate button
- Split button
- Merge button (conditional on position)
- Delete button (conditional on count)
- All action button CSS (`.card-actions`, `.action-btn`, `.remove-card-btn`)

**Props:**
```typescript
{
    blockId: string;
    index: number;
    total: number;
    onduplicate: (id: string) => void;
    onsplit: (id: string) => void;
    onmerge: (id: string) => void;
    onremove: (id: string) => void;
}
```

This is a pure presentational component — all logic stays in ThreadComposer.

**Verification:** `cd dashboard && npm run check`

### Step 6: Slim Down ThreadComposer.svelte (~400 lines)

After extracting ThreadCardActions, ThreadComposer drops from 858 lines. The remaining component keeps:
- Block CRUD (add, remove, update text, update media)
- Reorder logic (moveBlock, drag-drop handlers)
- Keyboard shortcuts (handleCardKeydown)
- Split/merge/duplicate functions
- Validation
- Block iteration template

**Extraction math:**
- Original: 858 lines
- ThreadCardActions extraction: ~120 lines of template + ~60 lines of CSS = ~180 lines removed
- Net: ~678 lines — still over 400

**Additional extraction needed:** Move the drag-and-drop handler functions and CSS into the main ThreadComposer but simplify the per-card template. The CSS section is ~297 lines. Key reductions:
- Move touch/mobile CSS for action buttons into ThreadCardActions (~25 lines)
- Move merge-error and validation-summary CSS (~30 lines) to inline styles or a utility class
- The thread card template itself has significant boilerplate per card — consolidate

**Realistic target:** ~400 lines (tight but achievable by aggressively moving styles with their components)

### Step 7: Rebuild ComposeModal.svelte as Orchestrator (~380 lines)

After steps 2-6, ComposeModal becomes a thin orchestrator:

**Keeps:**
- All state declarations (mode, tweetText, threadBlocks, etc.)
- Auto-save logic (effects + functions)
- handleSubmit() building ComposeRequest
- handleInlineAssist() dispatching to tweet/thread
- handleGenerateFromNotes() dispatching to API
- handleAiAssist() dispatching to API
- Keyboard handler (handleKeydown) dispatching to sub-components
- handlePaletteAction routing

**Delegates:**
- Modal chrome → ComposerShell
- Tweet editor UI → TweetEditor
- Thread editor UI → ThreadComposer (slimmed)
- Voice context → VoiceContextPanel
- Notes panel → FromNotesPanel (enhanced)
- Command palette → CommandPalette (unchanged)
- Time picker → TimePicker (unchanged)

**Template structure (simplified):**
```svelte
<svelte:window onkeydown={handleKeydown} />

{#if open}
  <ComposerShell {open} {mode} {focusMode} ...handlers>
    <VoiceContextPanel cue={voiceCue} oncuechange={(c) => voiceCue = c} />

    {#if mode === 'tweet'}
      <TweetEditor text={tweetText} onchange={(t) => tweetText = t} ... />
    {:else}
      <div class="thread-layout">
        <ThreadComposer bind:this={threadComposerRef} ... />
        <div class="thread-preview-pane">
          <!-- preview stays here for now — Session 03 extracts PreviewRail -->
          {#each sortedPreviewBlocks as block, i}
            <TweetPreview ... />
          {/each}
        </div>
      </div>
    {/if}

    {#if showFromNotes}
      <FromNotesPanel ... />
    {/if}

    <div class="schedule-section">
      <TimePicker ... />
    </div>

    {#if submitError}<div class="error-msg">{submitError}</div>{/if}
  </ComposerShell>

  {#if paletteOpen}
    <CommandPalette ... />
  {/if}
{/if}
```

**CSS remaining in ComposeModal:** Only the thread-layout grid and schedule-section styles — everything else moved to subcomponents.

**Line count math:**
- Script: ~200 lines (state + handlers + effects — media handlers moved to TweetEditor)
- Template: ~80 lines
- CSS: ~100 lines (thread-layout + schedule + error + a few remaining responsive rules)
- Total: ~380 lines

**Verification:** `cd dashboard && npm run check && npm run build`

### Step 8: Enhance FromNotesPanel.svelte (~250 lines)

**Changes to existing file:**

1. **Replace `confirm()` with inline banner.** Add state `showReplaceBanner: boolean`. When user clicks Generate and content exists, show a banner:
   ```
   <div class="replace-banner">
     This will replace your current content.
     <button onclick={doGenerate}>Replace</button>
     <button onclick={() => showReplaceBanner = false}>Cancel</button>
   </div>
   ```
   The `ongenerate` callback is called only after explicit confirmation.

2. **Add loading skeleton.** When `generating` is true, show a shimmer animation over the textarea:
   ```css
   .notes-loading {
     background: linear-gradient(90deg, var(--color-base) 25%, var(--color-surface-hover) 50%, var(--color-base) 75%);
     background-size: 200% 100%;
     animation: shimmer 1.5s infinite;
   }
   ```

3. **Add undo.** New prop: `previousContent: string | null` from ComposeModal. After generation completes, ComposeModal snapshots content before replacement and passes it as `previousContent`. FromNotesPanel shows an "Undo" button for 10 seconds that calls `onundo()`. ComposeModal restores the snapshot.

**New props:**
```typescript
{
    mode: 'tweet' | 'thread';
    hasExistingContent: boolean;       // NEW: whether editor already has content
    ongenerate: (text: string) => Promise<void>;
    onclose: () => void;
    onundo?: () => void;               // NEW: restore pre-generation content
    showUndo?: boolean;                 // NEW: whether undo button is visible
}
```

**Verification:** `cd dashboard && npm run check`

### Step 9: Wire Voice Cue into Assist Calls (ComposeModal)

In the orchestrator ComposeModal, add state:
```typescript
let voiceCue = $state('');
```

Modify assist call sites:

1. **`handleInlineAssist()`** — tweet mode:
   ```typescript
   const result = await api.assist.improve(selectedText, voiceCue || undefined);
   ```

2. **`handleAiAssist()`** — tweet mode improve:
   ```typescript
   const result = await api.assist.improve(tweetText, voiceCue || undefined);
   ```

3. **`handleAiAssist()`** — tweet mode generate:
   ```typescript
   const topicWithCue = voiceCue ? `[Tone: ${voiceCue}] general` : 'general';
   const result = await api.assist.tweet(topicWithCue);
   ```

4. **`handleAiAssist()`** — thread mode:
   ```typescript
   const topicWithCue = voiceCue ? `[Tone: ${voiceCue}] general` : 'general';
   const result = await api.assist.thread(topicWithCue);
   ```

5. **`handleGenerateFromNotes()`** — thread mode:
   ```typescript
   const topicWithCue = voiceCue ? `[Tone: ${voiceCue}] ${notesInput}` : notesInput;
   const result = await api.assist.thread(topicWithCue);
   ```

6. **Save cue to MRU on successful generation** — signal VoiceContextPanel to persist.

### Step 10: Add `generate_tweet_with_context()` to generator.rs

**Pattern:** Mirror `generate_reply_with_context()` (lines 77-93).

```rust
/// Generate a tweet with optional RAG context injected into the prompt.
pub async fn generate_tweet_with_context(
    &self,
    topic: &str,
    format: Option<TweetFormat>,
    rag_context: Option<&str>,
) -> Result<GenerationOutput, LlmError> {
    // Same as generate_tweet_with_format but inserts rag_context
    // between persona_section and Rules section in system prompt
}
```

Implementation: Copy `generate_tweet_with_format` body, add `rag_section` construction (lines 139-142 pattern), insert it before the `Rules:` section in the system prompt format string.

**Also add `generate_thread_with_context()`:**
```rust
/// Generate a thread with optional RAG context.
pub async fn generate_thread_with_context(
    &self,
    topic: &str,
    structure: Option<ThreadStructure>,
    rag_context: Option<&str>,
) -> Result<ThreadGenerationOutput, LlmError> {
    // Same as generate_thread_with_structure but inserts rag_context
}
```

**File size concern:** generator.rs is currently 814 lines (with tests). Adding two methods (~60 lines each) pushes it near the limit. However, the methods are nearly identical to existing ones with one added parameter. If the file exceeds 500 lines of non-test code, extract the `parse_thread()` function and tests into a submodule.

**Mitigation:** Count only non-test lines. Currently: ~542 non-test lines. Adding ~120 lines → ~662. This exceeds 500.

**Resolution:** Refactor generator.rs into a module directory:
```
content/generator/
  mod.rs        — ContentGenerator struct + public API methods (~400 lines)
  parser.rs     — parse_thread() function (~60 lines)
  tests.rs      — all tests (~270 lines)
```

Actually, let me recount. The file is 814 lines total. Tests are lines 544-814 = 270 lines. Non-test code is 543 lines, already over 500. Adding 2 methods would bring it to ~600+ non-test lines.

**Better approach:** Instead of adding separate `_with_context` methods, add an optional `rag_context` parameter to the existing internal generation flow, similar to how `generate_reply_inner` works. Create private `generate_tweet_inner` and `generate_thread_inner` methods that both the public `_with_format`/`_with_structure` methods and the new `_with_context` methods delegate to. This avoids code duplication and keeps the file manageable.

**Even better approach:** The file already exceeds 500 non-test lines. The session should convert it to a module directory first (as CLAUDE.md prescribes), THEN add the context methods:

1. `crates/tuitbot-core/src/content/generator/mod.rs` — ContentGenerator struct + all public methods
2. `crates/tuitbot-core/src/content/generator/parser.rs` — `parse_thread()` function
3. `crates/tuitbot-core/src/content/generator/tests.rs` — all `#[cfg(test)]` tests

This brings `mod.rs` under 500 lines even with the new methods.

### Step 11: Wire Winning DNA into assist.rs Handlers

**Changes to `assist_tweet()`:**
```rust
pub async fn assist_tweet(...) -> Result<...> {
    let gen = get_generator(&state, &ctx.account_id).await?;

    // Build winning DNA context (graceful degradation)
    let topic_keywords: Vec<String> = body.topic
        .split_whitespace()
        .map(|s| s.to_lowercase())
        .collect();
    let draft_ctx = tuitbot_core::context::winning_dna::build_draft_context(
        &state.db, &topic_keywords, 5, 14.0
    ).await.unwrap_or_default();

    let rag = if draft_ctx.prompt_block.is_empty() {
        None
    } else {
        Some(draft_ctx.prompt_block.as_str())
    };

    let output = gen
        .generate_tweet_with_context(&body.topic, None, rag)
        .await
        .map_err(|e| ApiError::Internal(e.to_string()))?;

    Ok(Json(AssistTweetResponse { content: output.text, topic: body.topic }))
}
```

**Same pattern for `assist_thread()` and `assist_improve()`.**

**Import needed:** `use tuitbot_core::context::winning_dna;`

**Error handling:** `build_draft_context` returns `Result<DraftContext, StorageError>`. Use `.unwrap_or_default()` so the assist call never fails due to winning DNA retrieval errors. Add `impl Default for DraftContext` if not already present (check — if `DraftContext` doesn't impl Default, use `.unwrap_or_else(|_| DraftContext { prompt_block: String::new(), ... })` pattern).

**Verification:**
```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

### Step 12: Verify Contract Tests Pass

Run:
```bash
RUSTFLAGS="-D warnings" cargo test --workspace
```

The 20 compose contract tests in `compose_contract_tests.rs` test `/api/content/compose` and `/api/content/drafts`. They do NOT test `/api/assist/*`. The only risk is if the `use tuitbot_core::context::winning_dna;` import or AppState changes cause compilation errors in the test harness. Since we're only adding methods to existing structs and adding imports to `assist.rs`, the test file should compile and pass unchanged.

### Step 13: Update docs/composer-mode.md

Add a "Voice Context" section documenting:
- VoiceContextPanel behavior
- Quick-cue input
- Saved cues (localStorage)
- How voice context flows into assist requests

Update the "Keyboard Shortcuts" table if any new shortcuts are added (none planned).

### Step 14: Write Session 02 Handoff

Create `docs/roadmap/typefully-beating-composer/session-02-handoff.md` documenting:
- What changed (files created/modified, line counts)
- Decisions made and rationale
- Open questions for Session 03
- Files Session 03 must read

---

## Risks and Mitigations

### R1: ComposeModal Refactor Breaks Existing Behavior
**Risk:** High — 1,273 lines of interconnected state and handlers.
**Mitigation:** Extract one component at a time. Run `npm run check` after each extraction. Verify autosave, recovery, keyboard shortcuts, command palette, and focus mode still work at each step. Never have two broken components at once.

### R2: generator.rs Exceeds 500 Lines
**Risk:** High — already at 543 non-test lines.
**Mitigation:** Convert to module directory (mod.rs + parser.rs + tests.rs) BEFORE adding new methods. This is prescribed by CLAUDE.md for files exceeding the limit.

### R3: Winning DNA Query Slows Assist Endpoints
**Risk:** Low — `build_draft_context` is a SQLite query on indexed columns. Typical latency < 5ms.
**Mitigation:** Use `.unwrap_or_default()` so failures don't block the assist response. Log warnings on errors for debugging.

### R4: VoiceContextPanel Doesn't Have Settings Data
**Risk:** Medium — the settings store is populated by the Settings page visit.
**Mitigation:** On modal open, check if `$config` is null and call `loadSettings()` as a fallback. This is a single GET request that returns quickly.

### R5: ThreadComposer Still Exceeds 400 Lines After ThreadCardActions Extraction
**Risk:** Medium — removing ~180 lines from 858 gives ~678.
**Mitigation:** Additional CSS extraction strategy: move per-card template into a `ThreadCard` inline component using Svelte 5 snippets, or aggressively consolidate duplicate CSS. If 400 is unachievable without breaking the component's cohesion, document the deviation and target ~420 lines with a justification in the handoff.

### R6: DraftContext Doesn't Implement Default
**Risk:** Low — need to verify.
**Mitigation:** If `Default` isn't derived, use `unwrap_or_else` with an explicit fallback constructor instead of `unwrap_or_default`.

---

## Exact Order of Operations

1. **Read anchor files** — already done in planning
2. **`mkdir -p dashboard/src/lib/components/composer`**
3. **Create ComposerShell.svelte** — extract modal chrome from ComposeModal
4. **Run `npm run check`** — verify TypeScript/Svelte compilation
5. **Create TweetEditor.svelte** — extract tweet textarea + media from ComposeModal
6. **Run `npm run check`**
7. **Create VoiceContextPanel.svelte** — new voice context bar
8. **Run `npm run check`**
9. **Create ThreadCardActions.svelte** — extract from ThreadComposer
10. **Slim ThreadComposer.svelte** — remove extracted code, import ThreadCardActions
11. **Run `npm run check`**
12. **Rebuild ComposeModal.svelte** — replace inline markup with subcomponent imports
13. **Run `npm run check && npm run build`** — full frontend verification
14. **Enhance FromNotesPanel.svelte** — inline confirmation, loading, undo
15. **Run `npm run check`**
16. **Wire voice cue into ComposeModal assist calls** — modify handler functions
17. **Run `npm run check`**
18. **Convert generator.rs to module directory** — mod.rs + parser.rs + tests.rs
19. **Run `cargo fmt --all && cargo test -p tuitbot-core`** — verify refactor preserves behavior
20. **Add `generate_tweet_with_context` and `generate_thread_with_context`** to generator mod.rs
21. **Add unit tests** for new context methods using MockProvider
22. **Run `cargo fmt --all && cargo test -p tuitbot-core`**
23. **Wire winning DNA into assist.rs** — modify assist_tweet, assist_thread, assist_improve
24. **Run full Rust CI:**
    ```bash
    cargo fmt --all && cargo fmt --all --check
    RUSTFLAGS="-D warnings" cargo test --workspace
    cargo clippy --workspace -- -D warnings
    ```
25. **Verify all 20 contract tests pass**
26. **Update docs/composer-mode.md** — add voice context section
27. **Run `cd dashboard && npm run check && npm run build`** — final frontend gate
28. **Write session-02-handoff.md**

---

## Verification Steps

### Frontend Quality Gate
```bash
cd dashboard && npm run check    # svelte-check TypeScript verification
cd dashboard && npm run build    # production build (catches runtime issues)
```

### Rust Quality Gate
```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

### Contract Test Verification
```bash
cargo test -p tuitbot-server -- compose_contract
```
All 20 tests must pass without modification.

### Manual Checklist (after all code changes)
- [ ] Modal opens/closes cleanly
- [ ] Focus mode enters/exits (Cmd+Shift+F)
- [ ] Tweet mode: type, char counter, submit
- [ ] Thread mode: add/remove/reorder/split/merge cards
- [ ] Command palette (Cmd+K) all actions work
- [ ] AI Improve (Cmd+J) works in both modes
- [ ] From Notes generates tweet and thread
- [ ] From Notes shows inline confirmation (not `confirm()` dialog)
- [ ] VoiceContextPanel shows voice settings
- [ ] Quick cue input modifies assist requests
- [ ] Autosave and recovery work
- [ ] Scheduling works
- [ ] Escape cascade: notes panel → focus mode → close modal

---

## Fallback Scope Cuts (Priority Order)

If time runs short, cut in this order:

1. **Cut first:** Saved cues localStorage persistence (keep ephemeral cue input, drop MRU dropdown)
2. **Cut second:** FromNotesPanel undo feature (keep inline confirmation banner, drop snapshot/undo)
3. **Cut third:** generator.rs module directory refactor (add `_with_context` methods inline, accept temporary file size violation, document in handoff)
4. **Cut fourth:** ThreadComposer under-400 strict compliance (accept ~420 lines with justification)

**Minimum viable session:** Refactored components + voice context bar (read-only summary + ephemeral cue) + winning DNA wiring + improved notes confirmation. All files under limits or with documented justification.
