# Session 1 Plan: Factory Reset Danger Zone -- Audit & Contract

## Mission

Audit the current onboarding, auth, storage, and settings flows.
Lock the exact factory-reset contract before any code changes.

**Deliverables (documentation-only):**
1. `docs/roadmap/factory-reset-danger-zone/charter.md`
2. `docs/roadmap/factory-reset-danger-zone/session-01-handoff.md`

---

## Current State Summary (from audit)

### Auth & Onboarding Flow

**Bearer auth (Tauri/desktop):**
- `+layout.svelte` tries `invoke("get_api_token")` from Tauri, falls back to `__DEV_API_TOKEN__`.
- If token found, sets bearer mode. Checks `GET /api/settings/status` -> if not configured, redirects to `/onboarding`.
- Bearer token lives at `{data_dir}/api_token` (generated by `auth::token::ensure_api_token()`).

**Cookie auth (web/LAN):**
- If no bearer token, checks `GET /api/settings/status` first:
  - Not configured -> redirect to `/onboarding` (with `?claimed=1` if passphrase_hash exists).
  - Configured -> checks existing session via `GET /api/auth/status`.
  - Has session -> connect WebSocket, redirect away from `/login`.
  - No session -> redirect to `/login`.
- Login: `POST /api/auth/login` with passphrase -> creates session row in `sessions` table, sets `tuitbot_session` cookie.
- Logout: `POST /api/auth/logout` -> deletes session row, sets `Max-Age=0` cookie.
- CSRF: Mutating requests require `X-CSRF-Token` header matching session's CSRF token.

**Auth-exempt routes:**
- `/api/health`, `/api/settings/status`, `/api/settings/init`, `/api/ws`, `/api/auth/login`, `/api/auth/status`.

**Onboarding flow:**
- Multi-step wizard: Welcome -> X API -> Business -> LLM -> Language -> Sources -> Validate -> Review -> [Secure/Claim].
- On submit, calls `POST /api/settings/init` with config JSON + optional `claim` object.
- `init_settings()`: Creates `config.toml`, optionally creates `passphrase_hash` and session.
- After success, redirects to `/content?compose=true`.

### Storage Layer

**Database (SQLite, WAL mode, pool of 4):**
- Path: `~/.tuitbot/tuitbot.db` (configurable via `storage.db_path`).
- 27 tables total (see full list below).
- Schema managed by embedded SQLx migrations.

**All database tables:**
1. `accounts` -- account registry
2. `account_roles` -- role-based access
3. `sessions` -- web/LAN auth sessions
4. `discovered_tweets` -- tweets from discovery
5. `replies_sent` -- sent replies
6. `original_tweets` -- original tweets
7. `threads` -- thread groups
8. `thread_tweets` -- individual tweets in threads
9. `target_accounts` -- monitored target accounts
10. `target_tweets` -- tweets from targets
11. `approval_queue` -- human review queue
12. `approval_edit_history` -- edit audit trail
13. `scheduled_content` -- composed content with scheduling
14. `follower_snapshots` -- daily follower counts
15. `reply_performance` -- reply engagement metrics
16. `tweet_performance` -- tweet engagement metrics
17. `content_scores` -- topic/format averages
18. `rate_limits` -- rate limit counters
19. `action_log` -- append-only audit trail
20. `cursors` -- loop state (since_id)
21. `author_interactions` -- per-author daily counts
22. `media_uploads` -- media upload tracking
23. `llm_usage` -- LLM API usage/cost
24. `x_api_usage` -- X API call tracking
25. `mcp_telemetry` -- MCP tool telemetry
26. `mutation_audit` -- mutation idempotency
27. `source_contexts` -- content source configs
28. `content_nodes` -- ingested content chunks
29. `draft_seeds` -- pre-computed draft ideas

**File artifacts in `data_dir` (`~/.tuitbot/`):**
- `config.toml` -- user configuration (TOML)
- `passphrase_hash` -- bcrypt hash of web login passphrase (0600)
- `api_token` -- bearer token for Tauri/API auth (0600)
- `media/` -- uploaded media files (`{uuid}.{ext}`)
- `tuitbot.db` + `-wal` + `-shm` -- SQLite database files
- `backups/` -- pre-migration database backups

**In-memory state (AppState):**
- `passphrase_hash: RwLock<Option<String>>` -- cached bcrypt hash
- `runtimes: Mutex<HashMap<String, Runtime>>` -- per-account automation runtimes
- `content_generators: Mutex<HashMap<String, Arc<ContentGenerator>>>` -- per-account LLM generators
- `login_attempts: Mutex<HashMap<IpAddr, (u32, Instant)>>` -- rate limiting
- `watchtower_cancel: Option<CancellationToken>` -- filesystem watcher cancel token

### Settings Page

Settings page (`+page.svelte`) displays sections: Business, Persona, Scoring, Limits, Schedule, LLM, X API, Storage, Sources, LAN.
The LAN section (`LanAccessSection.svelte`) is the natural neighbor for a "Danger Zone" section.

---

## Design Decisions

### 1. Reset Scope -- What Gets Cleared

**CLEARED (Tuitbot-managed data):**

| Category | What | How |
|----------|------|-----|
| Config file | `config.toml` | `fs::remove_file()` |
| Passphrase | `passphrase_hash` | `fs::remove_file()` + clear `AppState.passphrase_hash` |
| All sessions | `sessions` table rows | `DELETE FROM sessions` |
| All DB table contents | All 27 user tables | `DELETE FROM <table>` for each (not DROP) |
| Media files | `media/` directory | `fs::remove_dir_all(data_dir.join("media"))` |
| In-memory runtimes | All automation loops | `Runtime::shutdown()` for each |
| In-memory generators | Content generators cache | `content_generators.lock().clear()` |
| In-memory login state | Rate limit tracking | `login_attempts.lock().clear()` |
| Watchtower | File watcher | Cancel via `watchtower_cancel` token |

**PRESERVED (infrastructure):**

| What | Why |
|------|-----|
| SQLite schema (tables, indexes) | Schema is managed by migrations; re-running migrations on empty tables is the designed init path |
| `api_token` file | Bearer auth must survive so Tauri can still reach the server |
| `AppState.api_token` in memory | Same bearer token remains valid |
| `_sqlx_migrations` table | Tracks which migrations have run; must not be cleared |
| Database files (`tuitbot.db`, `-wal`, `-shm`) | Pool stays open; only contents cleared |
| Server process | The whole point of "live reset" |
| `backups/` directory | Pre-migration backups are safety artifacts |

**EXPLICITLY EXCLUDED:**

| What | Why |
|------|-----|
| User content source folders (local_fs paths in `content_sources`) | These are user-authored files outside the app data directory. Must never be touched. |
| Any files outside `data_dir` | Reset scope is strictly `~/.tuitbot/` minus `api_token` and `backups/` |

### 2. Endpoint Contract

```
POST /api/settings/factory-reset
```

**Authentication:** Required (bearer token OR session cookie + CSRF). NOT auth-exempt -- this is a destructive action that must be authenticated.

**Request body:**
```json
{
  "confirmation": "RESET TUITBOT"
}
```

The typed confirmation phrase is `RESET TUITBOT` (uppercase, ASCII, no special characters). The server validates this string exactly. This prevents accidental invocation and meets the "explicit typed phrase" requirement.

**Response (200 OK):**
```json
{
  "status": "reset_complete",
  "cleared": {
    "tables": 27,
    "config_deleted": true,
    "passphrase_deleted": true,
    "media_deleted": true,
    "runtimes_stopped": 1
  }
}
```

**Response headers (cookie-auth only):**
```
Set-Cookie: tuitbot_session=; HttpOnly; SameSite=Strict; Path=/; Max-Age=0
```

Clears the session cookie since all sessions are deleted from the DB.

**Error responses:**
- `400 Bad Request` -- confirmation phrase missing or incorrect
- `401 Unauthorized` -- not authenticated
- `403 Forbidden` -- missing CSRF token (cookie auth)
- `500 Internal Server Error` -- partial failure during reset

**Redirect target (frontend):** After successful reset, frontend redirects to `/onboarding`. The `+layout.svelte` boot logic already handles this: if `configured=false` from `/api/settings/status`, it redirects to onboarding.

### 3. Reset Execution Order

The order matters to avoid partial states:

1. **Stop all runtimes** -- `Runtime::shutdown()` for every entry in `runtimes` map. Also cancel watchtower.
2. **Clear all DB table contents** -- Single transaction with `DELETE FROM <table>` for each table (except `_sqlx_migrations`). Order respects FK constraints (children before parents).
3. **Delete config.toml** -- `fs::remove_file(config_path)`.
4. **Delete passphrase_hash** -- `fs::remove_file(data_dir.join("passphrase_hash"))`.
5. **Delete media directory** -- `fs::remove_dir_all(data_dir.join("media"))`.
6. **Clear in-memory state** -- `passphrase_hash` RwLock -> `None`, clear `content_generators`, clear `login_attempts`.
7. **VACUUM** -- Reclaim disk space from deleted rows.
8. **Return response** -- Include cleared stats, set cookie-clearing header.

Steps 2-5 should be wrapped in a fallible sequence that logs partial failures but continues. The response should indicate if any step failed.

### 4. Architecture Placement

Per the three-layer model and the constraint to keep HTTP handlers thin:

**Core function** (`tuitbot-core`):
- New module or function in `core/storage/` (e.g., `core/storage/reset.rs`).
- `pub async fn factory_reset(pool: &DbPool) -> Result<ResetStats, StorageError>` -- handles all DB table clearing in a transaction.
- This is a storage-layer concern, not a workflow or autopilot concern.

**Server handler** (`tuitbot-server`):
- New route handler in `routes/settings.rs` (it already owns settings endpoints).
- Handler validates confirmation phrase, stops runtimes, calls core `factory_reset()`, deletes files, clears in-memory state, returns response.
- Thin adapter pattern: validation + delegation + response envelope.

**Frontend** (`dashboard`):
- New `DangerZoneSection.svelte` component in settings sections.
- Added to settings page after `LanAccessSection`.
- Added to nav with a section id `danger` and appropriate icon.
- New `api.settings.factoryReset()` method in `api.ts`.

---

## Implementation Plan (Files & Order)

### Session 2: Backend (Core + Server)

**Files to create:**
1. `crates/tuitbot-core/src/storage/reset.rs` -- Core reset logic
   - `pub struct ResetStats { tables_cleared: u32, rows_deleted: u64 }`
   - `pub async fn factory_reset(pool: &DbPool) -> Result<ResetStats, StorageError>`
   - Deletes all rows from all user tables in FK-safe order within a transaction.
   - Unit tests with `init_test_db()`.

**Files to modify:**
2. `crates/tuitbot-core/src/storage/mod.rs` -- Add `pub mod reset;`
3. `crates/tuitbot-server/src/routes/settings.rs` -- Add `factory_reset` handler
   - Validates confirmation phrase.
   - Stops runtimes (locks `state.runtimes`, calls `shutdown()`, clears map).
   - Cancels watchtower.
   - Calls `core::storage::reset::factory_reset(&state.db)`.
   - Deletes `config_path`, `passphrase_hash`, `media/` directory.
   - Clears in-memory `passphrase_hash`, `content_generators`, `login_attempts`.
   - Runs VACUUM.
   - Returns `ResetStats` with cookie-clearing header.
4. `crates/tuitbot-server/src/lib.rs` -- Add route: `.route("/settings/factory-reset", post(routes::settings::factory_reset))`

**Tests to create:**
5. `crates/tuitbot-core/src/storage/reset.rs` (inline `#[cfg(test)]` module)
   - `factory_reset_clears_all_tables` -- Insert sample data, reset, verify all tables empty.
   - `factory_reset_preserves_migrations` -- Verify `_sqlx_migrations` untouched.
   - `factory_reset_returns_stats` -- Check row counts.

6. `crates/tuitbot-server/tests/factory_reset.rs` -- Integration tests
   - `factory_reset_requires_auth` -- 401 without token.
   - `factory_reset_requires_confirmation` -- 400 with wrong phrase.
   - `factory_reset_clears_data` -- Full reset flow, verify config deleted, tables empty, status returns unconfigured.
   - `factory_reset_clears_session_cookie` -- Check Set-Cookie header.
   - `factory_reset_idempotent` -- Reset on already-reset instance succeeds.

### Session 3: Frontend (Dashboard)

**Files to create:**
7. `dashboard/src/routes/(app)/settings/DangerZoneSection.svelte`
   - Red-bordered section with "Factory Reset" heading.
   - Warning text explaining what will be deleted.
   - Text input requiring user to type "RESET TUITBOT".
   - Submit button disabled until phrase matches.
   - Loading state during API call.
   - On success: redirect to `/onboarding`.
   - On error: display error message.

**Files to modify:**
8. `dashboard/src/lib/api.ts` -- Add `api.settings.factoryReset(confirmation: string)` method.
9. `dashboard/src/routes/(app)/settings/+page.svelte`
   - Import `DangerZoneSection`.
   - Add to `sections` array with id `danger`, label `Danger`, icon `AlertTriangle` (from lucide-svelte).
   - Render `<DangerZoneSection />` after `<LanAccessSection />`.

---

## Risks & Mitigations

| Risk | Mitigation |
|------|-----------|
| Partial reset (crash mid-way) | DB changes in single transaction; file deletions after DB success; log partial failures; response includes stats showing what was/wasn't cleared |
| User accidentally resets | Explicit typed phrase "RESET TUITBOT"; red danger styling; warning text |
| FK constraint violations during DELETE | Delete in child-first order: `thread_tweets` before `threads`, `approval_edit_history` before `approval_queue`, etc. |
| Pool open while deleting table contents | We DELETE rows, never DROP tables or delete the DB file. Pool and schema survive. |
| Watchtower file watcher still running after reset | Cancel watchtower token before clearing DB (watchtower writes to `content_nodes`/`source_contexts`) |
| Content source user folders deleted | Explicitly do NOT touch any paths referenced in `content_sources` config. Only delete `{data_dir}/media/`. |
| `api_token` accidentally deleted | api_token is NOT in the deletion list. Explicitly preserved. |
| Race condition: requests during reset | The reset handler holds the runtimes lock during shutdown; DB transaction ensures atomicity for table clears |

## Verification Steps

1. **CI checklist (backend):**
   ```bash
   cargo fmt --all && cargo fmt --all --check
   RUSTFLAGS="-D warnings" cargo test --workspace
   cargo clippy --workspace -- -D warnings
   ```

2. **Frontend checks:**
   ```bash
   cd dashboard && npm run check
   cd dashboard && npm run build
   ```

3. **Manual verification:**
   - Start fresh instance -> onboard -> reset -> verify redirect to onboarding.
   - After reset: verify `config.toml` deleted, `passphrase_hash` deleted, `media/` deleted, `api_token` preserved.
   - After reset: verify `GET /api/settings/status` returns `configured: false, claimed: false`.
   - After reset: re-onboard successfully (init + claim works again).

## Table Deletion Order (FK-safe)

Must delete children before parents:

```
1.  thread_tweets           (FK -> threads)
2.  approval_edit_history   (FK -> approval_queue)
3.  target_tweets           (FK -> target_accounts -- if FK exists)
4.  reply_performance       (FK -> replies_sent)
5.  tweet_performance       (FK -> original_tweets)
6.  content_nodes           (FK -> source_contexts)
7.  draft_seeds             (FK -> content_nodes)
8.  account_roles           (FK -> accounts)
9.  replies_sent
10. discovered_tweets
11. original_tweets
12. threads
13. approval_queue
14. scheduled_content
15. target_accounts
16. follower_snapshots
17. content_scores
18. rate_limits
19. action_log
20. cursors
21. author_interactions
22. media_uploads
23. llm_usage
24. x_api_usage
25. mcp_telemetry
26. mutation_audit
27. source_contexts
28. sessions
29. accounts
```

Note: Draft seeds depend on content_nodes which depend on source_contexts. So: `draft_seeds` -> `content_nodes` -> `source_contexts`. Need to verify exact FK definitions from migrations.

Alternative: Use `PRAGMA foreign_keys = OFF` temporarily, delete all tables in any order, then re-enable. Simpler but less safe. Decision: prefer explicit ordering.

## Exact Inputs for Session 2

- Confirmation phrase: `"RESET TUITBOT"` (exact string, case-sensitive)
- Endpoint: `POST /api/settings/factory-reset`
- Core function: `tuitbot_core::storage::reset::factory_reset(pool) -> Result<ResetStats, StorageError>`
- File plan: `reset.rs` in core, handler in `routes/settings.rs`, route in `lib.rs`, tests in both crates
- FK order: As listed above (verify from migrations)
- In-memory state to clear: `passphrase_hash`, `runtimes`, `content_generators`, `login_attempts`, `watchtower_cancel`
- Files to delete: `config.toml`, `passphrase_hash`, `media/` directory
- Files to preserve: `api_token`, `backups/`, `tuitbot.db` (schema only)
