# Session 3 Implementation Plan -- Dashboard Danger Zone

## Objective

Add a "Danger Zone" section to the Settings page with typed confirmation UX,
wire up the API client method, handle post-reset cleanup of local state, and
redirect to `/onboarding`.

---

## Files to Create

| # | File | Purpose |
|---|------|---------|
| 1 | `dashboard/src/routes/(app)/settings/DangerZoneSection.svelte` | Self-contained danger zone component |
| 2 | `docs/roadmap/factory-reset-danger-zone/frontend-flow.md` | UX flow documentation |
| 3 | `docs/roadmap/factory-reset-danger-zone/session-03-handoff.md` | Handoff for Session 4 |

## Files to Modify

| # | File | Change |
|---|------|--------|
| 4 | `dashboard/src/lib/api.ts` | Add `factoryReset` method to `api.settings` |
| 5 | `dashboard/src/routes/(app)/settings/+page.svelte` | Import DangerZoneSection, add nav entry, render after LAN |
| 6 | `dashboard/src/lib/stores/auth.ts` | Add `clearSession()` export for post-reset cleanup |
| 7 | `dashboard/src/lib/stores/settings.ts` | Add `resetStores()` export to clear all writable stores |

---

## Order of Operations

### Step 1: Add `factoryReset` to API client (`api.ts`)

**What:** Add a single method to the `api.settings` object.

**Exact change:** After the existing `testLlm` method (around line 915),
add:

```typescript
factoryReset: (confirmation: string) =>
    request<{ status: string; cleared: Record<string, unknown> }>(
        '/api/settings/factory-reset',
        {
            method: 'POST',
            body: JSON.stringify({ confirmation })
        }
    )
```

**Rationale:** The `request<T>()` helper already handles auth headers
(bearer OR cookie + CSRF), Content-Type, and error throwing. No special
handling needed -- the server always returns `Set-Cookie` clearing header
on success, which the browser processes automatically for cookie mode.

**Risk:** None. Additive change, no existing signatures modified.

### Step 2: Add `clearSession()` to auth store (`auth.ts`)

**What:** Export a new function that clears local web-session state without
making an API call (unlike `logout()` which calls `api.auth.logout()`).
After reset, the server has already deleted all sessions -- calling logout
would fail with 401.

**Exact change:** Add after the existing `logout` function:

```typescript
/** Clear local session state without an API call (used after factory reset). */
export function clearSession(): void {
    setCsrfToken('');
    authMode.set('none');
    isAuthenticated.set(false);
}
```

**Key decision: Do NOT call `setAuthMode('bearer')` here.**

In Tauri/bearer mode, the auth store's `authMode` is `'tauri'` (set in
`+layout.svelte`), and the api module's `authMode` is `'bearer'` -- both
were set during boot and should remain unchanged. The bearer token and
api_token file survive the reset, so bearer auth continues working.

In web/cookie mode, we clear the CSRF token and set authMode to `'none'`.
The `+layout.svelte` boot logic will re-detect the auth state on the next
page load (which happens when we redirect to `/onboarding`).

**Risk:** If we accidentally call `setAuthMode('bearer')` in web mode, CSRF
headers stop being sent. Mitigated by only clearing session-specific state.

### Step 3: Add `resetStores()` to settings store (`settings.ts`)

**What:** Export a function that nulls out the settings-related writable
stores so stale data doesn't flash when the user returns to settings after
re-onboarding.

**Exact change:** Add at the end of the actions section:

```typescript
/** Clear all settings stores (used after factory reset). */
export function resetStores(): void {
    config.set(null);
    defaults.set(null);
    draft.set(null);
    loading.set(true);
    error.set(null);
    saveError.set(null);
    validationErrors.set([]);
    lastSaved.set(null);
}
```

**Rationale:** After reset, the server has no config. If the user somehow
navigates back to `/settings` before re-onboarding, the stores should be in
their initial state. The `loading.set(true)` matches the initial store value
so the skeleton UI shows instead of stale data.

**Risk:** None. Additive. Only called in the reset success path.

### Step 4: Create `DangerZoneSection.svelte`

**What:** The main deliverable. A self-contained Svelte 5 component.

**Design decisions:**

1. **Uses `SettingsSection` wrapper** -- Same as all other settings sections
   for consistent layout, but with danger-themed icon color override via
   CSS custom property or a scoped style on the section-icon.

2. **Visual separation** -- The section card uses a red-tinted border
   (`color-mix(in srgb, var(--color-danger) 40%, var(--color-border-subtle))`)
   to make it visually distinct from the normal sections. The section icon
   background uses danger color instead of accent.

3. **Warning text** -- Concise paragraph explaining what factory reset does.

4. **Deleted vs Preserved lists** -- Two compact lists using existing
   `field-hint` styling:
   - Deleted: all table data, config, passphrase, sessions, media files,
     running automations.
   - Preserved: database schema, API token (Tauri), backup files.

5. **Typed confirmation input** -- `<input>` with placeholder
   "Type RESET TUITBOT to confirm". Bound to a `$state` variable.
   The button is disabled until `confirmationText === 'RESET TUITBOT'`
   (exact match, no trimming -- the server is case-sensitive).

6. **Red "Factory Reset" button** -- Uses `var(--color-danger)` background.
   Disabled when: (a) confirmation doesn't match, or (b) request in flight.

7. **Loading state** -- Button text changes to "Resetting..." with a spinner
   icon (use `Loader2` from lucide-svelte, same as onboarding). Input
   disabled during request.

8. **Error state** -- If the API call fails, show error text below the
   button in `var(--color-danger)`. Reset is idempotent, so retrying is safe.

9. **Success path** -- On 200 response:
   a. Call `clearSession()` from auth store (clears CSRF, sets authMode
      to 'none' for web mode; no-op effect for bearer mode since bearer
      auth survives).
   b. Call `resetStores()` from settings store (nulls out cached config).
   c. Call `disconnectWs()` from websocket store (stops reconnect loop --
      important because after reset, the WS auth will fail and trigger
      infinite reconnect attempts).
   d. Redirect to `/onboarding` using `goto('/onboarding')` from SvelteKit.
      Using `goto()` instead of `window.location.href` because:
      - In bearer/Tauri mode, `+layout.svelte` doesn't need to re-detect
        the token -- the `setToken()` call from boot still holds.
      - The layout's `onMount` already ran during initial boot. A `goto()`
        triggers SvelteKit's client-side navigation which renders the
        onboarding page immediately.
      - If the session cookie was cleared by the server's `Set-Cookie`
        header, the layout boot logic on full page reload would detect
        `configured=false` and redirect to `/onboarding` anyway -- but
        using `goto()` avoids the full page reload latency.

   **Alternative considered:** `window.location.href = '/onboarding'` for a
   hard reload. This ensures absolutely clean state but adds latency. The
   `goto()` + explicit store cleanup approach is faster and equally correct
   because we manually clear all relevant stores. If any edge case arises
   (e.g., some other store caches stale data), the user can refresh. We
   prefer `goto()` for UX speed.

   **Fallback:** If `goto()` throws for any reason, fall back to
   `window.location.href = '/onboarding'`.

10. **Does NOT use the existing timer-only double-click pattern** from
    LanAccessSection's `initiateReset()`. The charter explicitly requires
    typed confirmation, not timer-based double click.

**Component structure:**

```
<script lang="ts">
  imports: AlertTriangle, Loader2 from lucide-svelte
  imports: SettingsSection from '$lib/components/settings/SettingsSection.svelte'
  imports: api from '$lib/api'
  imports: clearSession from '$lib/stores/auth'
  imports: resetStores from '$lib/stores/settings'
  imports: disconnectWs from '$lib/stores/websocket'
  imports: goto from '$app/navigation'

  state: confirmationText = $state('')
  state: resetting = $state(false)
  state: errorMsg = $state('')

  derived: canReset = $derived(confirmationText === 'RESET TUITBOT' && !resetting)

  CONFIRMATION_PHRASE constant = 'RESET TUITBOT'

  async function handleReset() {
    resetting = true
    errorMsg = ''
    try {
      await api.settings.factoryReset(confirmationText)
      // Success -- clean up and redirect
      clearSession()
      resetStores()
      disconnectWs()
      try { goto('/onboarding') } catch { window.location.href = '/onboarding' }
    } catch (e) {
      errorMsg = e instanceof Error ? e.message : 'Factory reset failed'
      resetting = false
    }
  }
</script>
```

**Styling approach:** Scoped `<style>` block. Override the SettingsSection's
icon color by targeting `.danger-zone :global(.section-icon)` with
`background: color-mix(in srgb, var(--color-danger) 12%, transparent)` and
`color: var(--color-danger)`. The section wrapper gets a
`.danger-zone` class via a wrapping `<div>`.

The border override on `.settings-section` is done via
`.danger-zone :global(.settings-section)` with
`border-color: color-mix(in srgb, var(--color-danger) 40%, var(--color-border-subtle))`.

**Estimated lines:** ~180 (well under the 400-line limit for Svelte files).

### Step 5: Integrate into `+page.svelte`

**What:** Three small changes to the settings page:

1. **Import:** Add `import DangerZoneSection from './DangerZoneSection.svelte';`
   after the existing `LanAccessSection` import (line 36). Also add
   `AlertTriangle` to the lucide-svelte import.

2. **Nav entry:** Add to the `sections` array after the `lan` entry:
   ```typescript
   { id: 'danger', label: 'Danger', icon: AlertTriangle }
   ```
   This adds "Danger" with the warning triangle icon to the sticky sidebar.

3. **Render:** Add `<DangerZoneSection />` after `<LanAccessSection />`
   inside the `.sections` div (line 188).

**IntersectionObserver:** The existing `setupObservers()` loop iterates
over `sections` and creates observers for each `id`. Since we added
`{ id: 'danger' }` to the array, the observer will automatically pick up
the new section and highlight the nav item when scrolled into view. No
additional observer code needed.

**Risk:** The danger zone nav item must be visually distinct. The `active`
class uses `var(--color-accent)` (blue) by default. Consider adding a
conditional class for the danger nav item to use `var(--color-danger)` when
active. However, this adds complexity for marginal UX benefit -- the red
AlertTriangle icon already signals danger. Decision: keep default active
styling for nav consistency; the section content itself has enough danger
theming.

### Step 6: Write `frontend-flow.md` documentation

**What:** Document the UX flow for the danger zone feature.

**Contents:**
- User journey: navigate to Settings > scroll to Danger Zone > type phrase
  > click reset > redirect to onboarding.
- Auth mode handling: bearer vs cookie differences.
- State cleanup sequence.
- Known limitations:
  - WebSocket reconnect: we call `disconnectWs()` but if the user had
    multiple tabs open, other tabs will keep trying to reconnect.
  - Server subsystem hot-restart: the server doesn't hot-restart runtimes
    or watchtower after reset. The user must re-configure and manually start
    the runtime after re-onboarding.
  - Multi-tab: other open tabs will see stale data until they refresh. The
    layout boot check on next navigation will redirect them to onboarding.

### Step 7: Write `session-03-handoff.md`

**What:** Standard handoff document listing completed work, key decisions,
CI results, open issues, and inputs for Session 4.

---

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| `goto()` not `window.location.href` | Faster client-side nav; explicit store cleanup makes it equivalent to a hard reload. Fallback to hard redirect if goto fails. |
| `clearSession()` not `logout()` | Server already deleted all sessions; calling `api.auth.logout()` would fail with 401. Only clear local state. |
| Do not call `setAuthMode('bearer')` in clearSession | In web mode, the next boot in `+layout.svelte` will re-detect auth state. In Tauri mode, bearer auth is already set and survives reset. Forcing bearer in web mode would break CSRF on retry. |
| `disconnectWs()` on success | Prevents infinite reconnect loop. After reset, WS auth fails (sessions cleared). Without disconnect, the exponential backoff reconnect would run indefinitely until page reload. |
| No nav item color override | The red AlertTriangle icon already signals danger. Adding conditional active-state color for one nav item adds complexity without proportional UX benefit. The section content carries the danger theme. |
| Wrap SettingsSection in `.danger-zone` div | Clean way to override the component's scoped styles (icon color, border) without modifying the shared SettingsSection component. |
| Input not trimmed before comparison | The server does exact match on `"RESET TUITBOT"`. Trimming could mask accidental whitespace. The placeholder text shows the exact phrase to type. |
| No `onDestroy` cleanup needed | The component only has reactive state; no timers, observers, or subscriptions to clean up. If the reset redirects away, the component is unmounted naturally. |
| Separate `clearSession` and `resetStores` | Keeps auth and settings concerns separated in their respective store modules. The DangerZoneSection orchestrates both. |

---

## Risks and Mitigations

| Risk | Severity | Mitigation |
|------|----------|------------|
| Stale data in other stores (websocket events, onboarding) | Low | `disconnectWs()` clears the WS connection. Onboarding store has no stale data (it's empty by default). Other stores (analytics, approval, etc.) will fail gracefully on next API call since config is gone. |
| Race condition: user clicks reset twice | Low | Button disabled while `resetting = true`. Even if bypassed, server handles idempotent reset (returns 0 rows deleted). |
| `goto('/onboarding')` fails in edge case | Low | Fallback to `window.location.href = '/onboarding'` in catch block. |
| Other tabs left in stale state | Medium | Known limitation. Documented in frontend-flow.md. The `+layout.svelte` boot logic redirects to onboarding on next navigation. No cross-tab broadcast implemented (would require BroadcastChannel API -- out of scope). |
| Bearer mode: clearSession sets authMode to 'none' | Low | In Tauri mode, `authMode` store is 'tauri' set during boot. `clearSession()` sets it to 'none', but the api module's internal `authMode` remains 'bearer' (we don't call `setAuthMode()`). The bearer token in the api module survives. On redirect to `/onboarding`, the layout boot re-detects Tauri and sets everything back. |

Wait -- this is actually a concern. Let me trace the Tauri flow:

1. Boot: `setToken(token)`, `setAuthMode('bearer')`, `authModeStore.set('tauri')`.
2. User clicks reset: `clearSession()` sets `authModeStore` to 'none' and
   clears CSRF. Does NOT touch the api module's internal `authMode` or `token`.
3. `goto('/onboarding')` renders the onboarding page. The layout's `onMount`
   already ran (SvelteKit doesn't re-run layout onMount for client navigation).
4. The api module still has `authMode = 'bearer'` and `token = <valid>`.
5. Onboarding calls `api.settings.init()` which uses a direct `fetch()` call
   (not the `request()` helper) with `credentials: 'include'`. In bearer
   mode, this works fine since `init` is auth-exempt.

Actually, `api.settings.init()` is a custom function that does NOT use the
`request()` helper -- it does raw `fetch()` without bearer headers. This is
correct because `/api/settings/init` is in `AUTH_EXEMPT_PATHS`. So the
bearer token presence/absence doesn't matter for init.

After re-onboarding and submitting, the user is redirected to
`/content?compose=true`. If they navigate to settings, `loadSettings()`
calls `api.settings.get()` which uses `request()` with bearer auth -- this
works because the api module's token is still set.

**Conclusion:** The Tauri flow is safe. The `authModeStore` being 'none'
temporarily doesn't matter because it's only used for UI decisions, not for
API calls. The api module's internal state (`token`, `authMode`) drives
actual auth behavior.

For extra safety, we can skip `clearSession()` in Tauri mode and only call
it in web mode. But since `clearSession()` only touches the Svelte store
(not the api module internals), and the layout boot in Tauri mode doesn't
re-run on `goto()`, this is safe as-is. Keep it simple.

---

## Verification Steps

### Automated

```bash
# Frontend type-check and build
cd dashboard && npm run check
cd dashboard && npm run build

# Backend (should be unaffected but run for full CI gate)
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

### Manual Testing Scenarios

1. **Happy path (bearer mode):**
   - Start Tauri dev: `cd dashboard && npm run tauri dev`
   - Navigate to Settings > scroll to Danger Zone
   - Type "RESET TUITBOT" in input > button enables
   - Click "Factory Reset" > spinner shows
   - Redirects to `/onboarding`
   - Complete onboarding > app works normally

2. **Happy path (web/cookie mode):**
   - Start server: `cargo run -p tuitbot-server -- --host 0.0.0.0`
   - Open browser, login with passphrase
   - Navigate to Settings > Danger Zone
   - Type "RESET TUITBOT" > click reset
   - Session cookie cleared, redirects to `/onboarding`
   - Onboarding shows claim step (since passphrase was deleted)

3. **Wrong confirmation:**
   - Type "reset tuitbot" (lowercase) > button stays disabled
   - Type "RESET TUITBOT " (trailing space) > button stays disabled
   - Type partial phrase > button stays disabled

4. **Error handling:**
   - Disconnect server > attempt reset > error message shown
   - Error clears when user retries

5. **Idempotent:**
   - Reset on already-reset instance > succeeds (server returns 0 rows)

6. **Multi-tab (web mode):**
   - Open two tabs at settings
   - Reset from tab 1 > tab 1 redirects to onboarding
   - Tab 2: next navigation triggers layout boot > detects unconfigured >
     redirects to onboarding

---

## Implementation Sequence (Exact Order)

1. `dashboard/src/lib/api.ts` -- add `factoryReset` method (1 minute)
2. `dashboard/src/lib/stores/auth.ts` -- add `clearSession` export (1 minute)
3. `dashboard/src/lib/stores/settings.ts` -- add `resetStores` export (1 minute)
4. `dashboard/src/routes/(app)/settings/DangerZoneSection.svelte` -- create component (main work)
5. `dashboard/src/routes/(app)/settings/+page.svelte` -- integrate section + nav entry
6. Run `cd dashboard && npm run check && npm run build` -- fix any type errors
7. Run full CI checklist -- verify no regressions
8. `docs/roadmap/factory-reset-danger-zone/frontend-flow.md` -- document UX flow
9. `docs/roadmap/factory-reset-danger-zone/session-03-handoff.md` -- write handoff

Steps 1-3 are independent and can be done in any order. Step 4 depends on
1-3 (imports from those modules). Step 5 depends on 4. Step 6 validates
4-5. Steps 8-9 are documentation, done last.
