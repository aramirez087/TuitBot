# Session 1 Implementation Plan — First-Run Charter

## Problem Statement

Tuitbot has an **auth-before-onboarding inversion**: on a fresh install, the web/LAN frontend demands a passphrase (login screen) before the user can reach the onboarding wizard, but the passphrase was only shown once in the server terminal output. If the user missed it, they're locked out with no self-service recovery path from the browser.

### Current Flow (Web/LAN — broken for fresh installs)

```
Server starts → passphrase printed to terminal (once) → passphrase_hash written to disk
User opens browser → +layout.svelte runs →
  1. No bearer token (not Tauri)
  2. checkAuth() → no session cookie
  3. Redirect to /login
  4. User must enter passphrase from terminal
  5. Only AFTER login → check if configured → redirect to /onboarding
```

**The problem:** Step 4 is a dead end for users who didn't see the terminal output (e.g., running as a systemd service, Docker container, or Tauri sidecar on first launch). The login page says "Enter the passphrase shown in your server terminal" but provides no alternative path.

### Current Flow (Tauri — works fine)

```
Tauri reads api_token file → Bearer mode → all requests authenticated
+layout.svelte Step 3 → not configured → redirect to /onboarding
```

Tauri bypasses the passphrase entirely via bearer token. This flow is correct and must remain unchanged.

---

## Audit Summary of Anchor Files

### `+layout.svelte` (frontend gate)
- **Lines 18–46:** Auth check runs first. If no bearer token and no session cookie, redirects to `/login` regardless of whether config exists.
- **Lines 49–57:** Config check runs second. If not configured, redirects to `/onboarding`.
- **Order is wrong for web users:** login gate fires before onboarding check. A fresh install with no passphrase is a dead end.

### `login/+page.svelte` (login UI)
- Accepts a 4-word passphrase, calls `login()` store function.
- No "first-time setup" alternative. No passphrase reset mechanism from the browser.
- Subtitle hardcodes: "Enter the passphrase shown in your server terminal."

### `main.rs` (server startup)
- **Lines 78–94:** `ensure_passphrase(db_dir)` runs at startup. If no hash file exists, generates a new passphrase, prints it to stdout, and writes the hash.
- Passphrase is generated before the server even knows whether a config exists.
- The plaintext is shown once and never stored.

### `settings.rs` (config init endpoint)
- **`GET /api/settings/status`** — auth-exempt. Returns `{ configured, deployment_mode, capabilities }`.
- **`POST /api/settings/init`** — auth-exempt. Creates initial config.toml. Returns 409 if already configured.
- Neither endpoint interacts with the passphrase system.

### `lan.rs` (LAN passphrase management)
- **`POST /api/settings/lan/reset-passphrase`** — requires auth (not exempt). Returns the new plaintext passphrase in the response body.
- Cannot be used by unauthenticated users to bootstrap.

### `middleware.rs` (auth middleware)
- Exempt paths: `/health`, `/settings/status`, `/settings/init`, `/ws`, `/auth/login`, `/auth/status`.
- `/settings/init` is exempt — this is the key: the onboarding wizard can POST config without auth.
- But there's no way to establish a session without already having the passphrase.

### `docs/lan-mode.md`
- Documents the passphrase-on-first-start behavior.
- Recommends `--reset-passphrase` CLI flag for recovery.
- No mention of a browser-based first-run claim flow.

---

## Target UX (What We Want)

### Fresh Install — Web/LAN User
```
Server starts → no passphrase_hash exists yet → server prints nothing about passphrase
User opens browser → +layout.svelte runs →
  1. No bearer token (not Tauri)
  2. GET /api/settings/status → { configured: false, claimed: false }
  3. Redirect to /onboarding (skip login entirely)
  4. User completes onboarding wizard
  5. Final submit: POST /api/settings/init with { ..., claim: { passphrase: "user-chosen-or-generated" } }
  6. Server creates config, creates passphrase_hash, creates session, returns session cookie + CSRF
  7. User is now authenticated and configured → redirect to dashboard
```

### Returning User — Web/LAN (configured, has session)
```
User opens browser → +layout.svelte →
  1. No bearer token
  2. checkAuth() → session cookie valid
  3. Config check → configured
  4. Render dashboard
```

### Returning User — Web/LAN (configured, no session)
```
User opens browser → +layout.svelte →
  1. No bearer token
  2. checkAuth() → no valid session
  3. Config check → configured
  4. Redirect to /login
  5. Enter passphrase → authenticated → dashboard
```

### Tauri User (unchanged)
```
Bearer token from api_token file → always authenticated
Config check → configured or not → onboarding or dashboard
```

---

## Key Design Decisions

### 1. Instance Claiming via `POST /api/settings/init`

**Decision:** Extend `POST /api/settings/init` to optionally accept a `claim` object containing the passphrase. If the instance is unclaimed (no `passphrase_hash` file), the endpoint creates both the config and the passphrase hash atomically.

**Rationale:**
- `/settings/init` is already auth-exempt — no new unauthenticated surface area.
- Atomic operation prevents partial states (config exists but no passphrase, or vice versa).
- The endpoint already returns 409 if config exists, so claiming is inherently one-shot.

**Security consideration:** The passphrase must be provided by the user/frontend — never generated server-side and returned in the response. The plaintext never touches disk or logs. Only the bcrypt hash is stored.

### 2. Frontend Gate Reordering

**Decision:** In `+layout.svelte`, check config status *before* checking auth for web users. If unconfigured AND unclaimed, redirect to onboarding. If configured but unauthenticated, redirect to login.

**Rationale:**
- Fixes the auth-before-onboarding inversion.
- Tauri bearer-token path is unaffected (bearer always authenticated first).
- No security weakening: unconfigured instances have no sensitive data to protect.

### 3. Session Bootstrap at Claim Time

**Decision:** When `/api/settings/init` processes a claim, it also creates a session and returns `Set-Cookie` + CSRF token in the response, identical to the login endpoint's response shape.

**Rationale:**
- User doesn't need to re-enter the passphrase they just set.
- Smooth UX: onboarding → dashboard without an intermediate login screen.
- The session is created server-side with the same security properties as a regular login session.

### 4. Passphrase Generation UX

**Decision:** The frontend generates a suggested 4-word passphrase using the same EFF wordlist (bundled as a static asset), with a "regenerate" button. Users can also type their own. The passphrase is shown clearly with a "copy" button and a warning to save it.

**Rationale:**
- Client-side generation means the plaintext never traverses the network except in the claim POST.
- Using the same EFF wordlist maintains consistency.
- User agency: they can choose their own passphrase if preferred.

**Alternative considered:** Server generates passphrase and returns it. Rejected because it means the plaintext crosses the wire in the response, and we'd need to trust the server not to log it.

### 5. Deferred Passphrase for Tauri

**Decision:** In Tauri/bearer mode, skip the passphrase claim step during onboarding entirely. The passphrase is only needed for web/LAN access. Users can set one later from the LAN settings page.

**Rationale:**
- Tauri users authenticate via bearer token and never need a passphrase.
- Forcing them to create one adds friction with no benefit.
- The existing server-side `ensure_passphrase()` at startup can be made conditional (only generate if `--host 0.0.0.0` is set, or defer entirely).

---

## Implementation Sessions

### Session 02: Backend Claim Bootstrap

**Goal:** Implement the backend contract so `POST /api/settings/init` can accept an optional claim with passphrase, create the hash, and return a session cookie.

**Files to create/modify:**

| File | Action | Description |
|------|--------|-------------|
| `crates/tuitbot-server/src/routes/settings.rs` | Modify | Extend `init_settings` to accept optional `claim` object, create passphrase hash, create session, return `Set-Cookie` + CSRF |
| `crates/tuitbot-core/src/auth/passphrase.rs` | Modify | Add `create_passphrase_hash(data_dir, plaintext)` function that writes hash if file doesn't exist, returns error if already claimed |
| `crates/tuitbot-server/src/auth/middleware.rs` | Modify | Possibly add `/settings/defaults` to exempt list if needed for onboarding |
| `crates/tuitbot-server/src/routes/lan.rs` | Modify | Add `claimed` field to `GET /api/settings/lan` response |
| `crates/tuitbot-server/src/main.rs` | Modify | Make startup passphrase generation conditional — skip if no `--host 0.0.0.0` (or defer to claim flow) |
| `crates/tuitbot-server/src/state.rs` | No change | `passphrase_hash` is already `RwLock<Option<String>>` — supports runtime updates |
| `docs/roadmap/fresh-install-auth-ux/backend-contract.md` | Create | Document the new API contract |
| `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md` | Create | Session handoff |

**Acceptance criteria:**
1. `POST /api/settings/init` with `claim.passphrase` creates config + passphrase_hash atomically.
2. Response includes `Set-Cookie: tuitbot_session=...` and `csrf_token` field.
3. If passphrase_hash already exists, `claim` is rejected (409 or ignored).
4. Existing callers without `claim` field still work identically (backward compatible).
5. `GET /api/settings/status` returns `claimed: bool` field.
6. All CI checks pass.

**Risks:**
| Risk | Mitigation |
|------|------------|
| Race condition: two browsers claim simultaneously | `create_passphrase_hash` uses atomic file creation (O_EXCL) or checks existence before writing. The first writer wins. |
| Passphrase plaintext leaks in logs | Never log the plaintext. Use `tracing::info!("instance claimed")` without the passphrase value. |
| Breaking existing `init_settings` callers | `claim` field is optional (`Option<ClaimRequest>`). Omitting it preserves current behavior. |
| Server startup still generates passphrase | Make `ensure_passphrase` a no-op or skip when server expects claim flow. Needs careful handling for CLI-only users who want the terminal-printed passphrase. |

### Session 03: Frontend First-Run UX

**Goal:** Implement the frontend routing changes so fresh installs reach onboarding before login, and the onboarding wizard handles instance claiming.

**Files to create/modify:**

| File | Action | Description |
|------|--------|-------------|
| `dashboard/src/routes/+layout.svelte` | Modify | Reorder gate: check config status before auth for non-bearer users. Route unconfigured+unclaimed to `/onboarding`. |
| `dashboard/src/routes/onboarding/+page.svelte` | Modify | Add passphrase claim step (before or after Review step). Show generated passphrase, allow custom, copy button, save warning. Send `claim` in `init` payload. Handle session cookie from response. |
| `dashboard/src/routes/login/+page.svelte` | Modify | Update copy for returning users. Add "forgot passphrase?" hint pointing to CLI reset command. |
| `dashboard/src/lib/api.ts` | Modify | Update `settings.init()` to handle `Set-Cookie` response (ensure `credentials: 'include'`). Store CSRF token from claim response. |
| `dashboard/src/lib/stores/auth.ts` | Modify | Add `claimAndLogin(csrfToken)` function or extend `login` to handle claim-time session bootstrap. |
| `dashboard/src/lib/components/onboarding/ClaimStep.svelte` | Create | New onboarding step for passphrase creation. EFF wordlist, regenerate button, copy button, warning text. |
| `dashboard/src/lib/stores/onboarding.ts` | Modify | Add `passphrase` field to onboarding data (never persisted to localStorage). |
| `dashboard/src/routes/(app)/settings/LanAccessSection.svelte` | Modify | Improve UX: clearer passphrase reset confirmation, actionable copy. |
| `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md` | Create | Session handoff |

**Acceptance criteria:**
1. Fresh install in web mode: browser → onboarding wizard → claim passphrase → dashboard (no login screen).
2. Fresh install in Tauri mode: same as today (bearer → onboarding → dashboard, no passphrase step).
3. Returning web user with expired session: → login screen → passphrase → dashboard.
4. Configured web user with valid session: → dashboard directly.
5. Passphrase is shown clearly during claim with copy-to-clipboard and save warning.
6. Login page has actionable "forgot passphrase?" guidance.
7. All CI checks pass.

**Risks:**
| Risk | Mitigation |
|------|------------|
| User navigates away during claim without saving passphrase | Show a `beforeunload` warning. Make the passphrase visible and copyable. Consider a "I've saved this" checkbox before proceeding. |
| EFF wordlist bundle size | ~13KB gzipped — acceptable for onboarding page. Can lazy-load. |
| CSRF token not stored after claim | Ensure `settings.init()` response handler stores CSRF token in the same way `login()` does. |
| Race between layout gate and onboarding submit | Use a local `claiming` state to prevent double navigation. |

### Session 04: Validation and Release Readiness

**Goal:** End-to-end validation of all flows, close small gaps, publish go/no-go report.

**Files to create/modify:**

| File | Action | Description |
|------|--------|-------------|
| `docs/roadmap/fresh-install-auth-ux/release-readiness.md` | Create | Go/no-go report |
| `docs/roadmap/fresh-install-auth-ux/session-04-handoff.md` | Create | Final handoff |
| `docs/lan-mode.md` | Modify | Update documentation to reflect new claim flow |
| Various | Fix | Small validation findings |

---

## Exact Order of Operations for Session 02 (Next Session)

1. **Read** `docs/roadmap/fresh-install-auth-ux/charter.md` and `session-01-handoff.md` (will be created in this session).
2. **Read** `crates/tuitbot-core/src/auth/passphrase.rs` — understand `ensure_passphrase`, `hash_passphrase`, file I/O.
3. **Add** `create_passphrase_hash(data_dir, plaintext) -> Result<()>` to `passphrase.rs`:
   - Check if `passphrase_hash` file exists → error if yes (already claimed).
   - Hash plaintext with bcrypt.
   - Write hash to file with 0600 permissions.
   - Never log the plaintext.
4. **Add** `claimed` field to `GET /api/settings/status` response in `settings.rs`:
   - Check if `passphrase_hash` file exists in `data_dir`.
5. **Extend** `init_settings` in `settings.rs`:
   - Add `#[serde(default)] claim: Option<ClaimRequest>` to the request body.
   - If `claim` is present and instance is unclaimed:
     - Call `create_passphrase_hash(data_dir, claim.passphrase)`.
     - Update `state.passphrase_hash` RwLock with new hash.
     - Create session via `session::create_session(db, ...)`.
     - Add `Set-Cookie` header and `csrf_token` to response.
   - If `claim` is present but instance is already claimed: return 409.
   - If `claim` is absent: preserve current behavior exactly.
6. **Update** `main.rs` startup:
   - Consider making `ensure_passphrase` conditional: only auto-generate if `--host 0.0.0.0` (LAN mode). Otherwise, defer to claim flow.
   - **Careful:** This changes behavior for CLI-only users. May need a `--generate-passphrase` flag or keep current behavior as fallback.
7. **Write tests** in `crates/tuitbot-server/tests/fresh_install_auth.rs` or add to existing test files:
   - Test: init with claim on unclaimed instance → 200 + cookie + hash file created.
   - Test: init with claim on already-claimed instance → 409.
   - Test: init without claim → current behavior (200, no cookie).
   - Test: GET /settings/status returns `claimed: false` before claim, `claimed: true` after.
8. **Run CI checklist:**
   ```bash
   cargo fmt --all && cargo fmt --all --check
   RUSTFLAGS="-D warnings" cargo test --workspace
   cargo clippy --workspace -- -D warnings
   ```
9. **Write** `docs/roadmap/fresh-install-auth-ux/backend-contract.md`.
10. **Write** `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md`.

---

## Verification Steps

After each session, the following must pass:

```bash
# Rust CI
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings

# Frontend (Session 03 only)
cd dashboard && npm run check
cd dashboard && npm run build
```

Manual verification (Session 04):
1. Delete `~/.tuitbot/` directory.
2. Start server with `--host 0.0.0.0`.
3. Open browser to LAN IP → should reach onboarding, not login.
4. Complete onboarding with passphrase claim → should land on dashboard.
5. Open incognito window → should reach login page.
6. Enter passphrase → should reach dashboard.
7. Start Tauri app → should work as before (bearer token, no passphrase needed).

---

## Files to Create in This Session (Session 01)

| File | Description |
|------|-------------|
| `docs/roadmap/fresh-install-auth-ux/charter.md` | Full charter document covering target UX, design decisions, security model, session breakdown |
| `docs/roadmap/fresh-install-auth-ux/session-01-handoff.md` | Handoff documenting what was done, open issues, and inputs for Session 02 |

**No source code modifications.** This session is documentation-only.
