# Session 03 Implementation Plan ‚Äî Frontend First-Run UX

**Date:** 2026-02-28
**Branch:** `feat/init_improvements`
**Objective:** Implement the frontend claim, onboarding, login, and LAN UX so fresh installs avoid the passphrase dead end while returning users keep secure access.

---

## Pre-Implementation Reading (completed during planning)

- `docs/roadmap/fresh-install-auth-ux/charter.md` ‚Äî full charter
- `docs/roadmap/fresh-install-auth-ux/backend-contract.md` ‚Äî API contract
- `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md` ‚Äî handoff
- All frontend files listed in the session instructions

---

## Design Decisions

### D1: EFF wordlist delivery ‚Äî inline TypeScript array

**Decision:** Ship the 1,296-word EFF short wordlist as a TypeScript `string[]` constant in a dedicated module `dashboard/src/lib/wordlist.ts`.

**Rationale:**
- The raw file is 10,778 bytes (~5KB gzipped). As an inline TS array, this becomes ~11KB raw / ~4KB gzipped after tree-shaking.
- No async fetch required ‚Äî instant generation on page load.
- The wordlist is only imported in the ClaimStep component, so it's tree-shaken from other routes.
- Consistent with the backend's `include_str!()` approach ‚Äî same source of truth.

**Rejected:** Static JSON file fetched at runtime ‚Äî adds latency, requires error handling for network failures during onboarding.
**Rejected:** Lazy-loaded module ‚Äî unnecessary complexity; the file is small enough to be part of the onboarding chunk.

### D2: Claim step position ‚Äî new step 8, after Review (step 7)

**Decision:** Add the claim step as step 8 ("Secure"), after "Review" (step 7). The final "Start Tuitbot" button moves from Review to the new Claim step. STEPS array becomes 9 items: `['Welcome', 'X API', 'Business', 'LLM', 'Language', 'Sources', 'Validate', 'Review', 'Secure']`.

**Rationale:**
- The user has seen everything about their config before being asked to create a passphrase.
- The claim step clearly separates "review your choices" from "secure your instance."
- In Tauri/bearer mode, step 8 is simply skipped ‚Äî the submit button remains on Review.

**Rejected:** Integrating into the Review step ‚Äî makes the Review step too complex and conflates configuration review with security setup.

### D3: Conditional claim step based on auth mode

**Decision:** The `ClaimStep` (step 8) is only shown when `authMode` is NOT `tauri`. In bearer mode, the "Start Tuitbot" button stays on step 7 (Review) and `submit()` is called without a `claim` payload ‚Äî preserving existing Tauri behavior exactly.

**Rationale:**
- Tauri users never need a passphrase. Adding a passphrase step would be confusing.
- The layout gate already sets `authModeStore` to `'tauri'` before redirecting to onboarding.
- Step count adjusts dynamically: 8 steps in bearer mode, 9 in web mode.

### D4: CSRF token storage after claim mirrors login exactly

**Decision:** After a successful `POST /api/settings/init` with `claim`, the response handler calls `setCsrfToken()`, `setAuthMode('cookie')`, `authModeStore.set('web')`, `isAuthenticated.set(true)`, and `connectWs()` ‚Äî the same sequence used in `login()` in `auth.ts`.

**Rationale:** Identical session state ensures authenticated requests work immediately after claim, with no special-casing in `api.ts` or middleware.

### D5: `beforeunload` guard scoped to ClaimStep only

**Decision:** A `beforeunload` listener is attached when the passphrase is generated and removed after successful submit. The guard fires only if the user hasn't yet completed submission.

**Rationale:** Prevents accidental navigation away without saving the passphrase. The handler is removed on successful submit so it doesn't fire during the `goto('/content?compose=true')` navigation.

### D6: `ConfigStatus` type updated to include `claimed`

**Decision:** Add `claimed: boolean` to the `ConfigStatus` interface in `api.ts`. This is an additive, backward-compatible change.

### D7: Layout gate reordering ‚Äî config/claimed check before auth for web users

**Decision:** Restructure `+layout.svelte` so that for non-bearer users:
1. First, call `GET /api/settings/status` to get `configured` and `claimed`.
2. If `!configured && !claimed` ‚Üí redirect to `/onboarding` (fresh install, skip login entirely).
3. If `configured` ‚Üí attempt `checkAuth()`. If no session ‚Üí redirect to `/login`.
4. If `!configured && claimed` ‚Üí edge case (config deleted but passphrase exists). Still redirect to `/onboarding` ‚Äî the claim step will be skipped since `claimed` is true.

**Rationale:** This eliminates the auth-before-onboarding inversion. The status endpoint is already auth-exempt and fast (filesystem checks only).

---

## Files to Modify

### 1. `dashboard/src/lib/api.ts`

**Changes:**
- Update `ConfigStatus` interface to add `claimed: boolean` field (line ~448).
- Update `api.settings.init()` signature to accept a broader type that can include the `claim` object, and return `csrf_token` in the response type.
- The `init()` method must use `credentials: 'include'` when a claim is present so the browser stores the `Set-Cookie` header. Currently it uses the `request()` helper which only sets `credentials: 'include'` when `authMode === 'cookie'`. At init time, authMode is still `'bearer'` (default). **Solution:** Make `init()` a custom fetch call (like `auth.login`) instead of using the generic `request()` helper, so it always includes credentials.

**Specific edits:**

a) `ConfigStatus` interface (line 447-451):
```typescript
export interface ConfigStatus {
	configured: boolean;
	claimed: boolean;       // ‚Üê add
	deployment_mode: DeploymentModeValue;
	capabilities: DeploymentCapabilities;
}
```

b) `api.settings.init()` (lines 875-882): Change from `request()` to a custom fetch that always includes `credentials: 'include'`:
```typescript
init: async (data: Record<string, unknown>): Promise<{
	status: string;
	config?: TuitbotConfig;
	csrf_token?: string;
	errors?: Array<{ field: string; message: string }>;
}> => {
	const res = await fetch(`${BASE_URL}/api/settings/init`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(data),
		credentials: 'include'
	});
	if (!res.ok) {
		const body = await res.json().catch(() => ({ error: res.statusText }));
		throw new Error(body.error || res.statusText);
	}
	return res.json();
},
```

### 2. `dashboard/src/lib/stores/auth.ts`

**Changes:**
- Add a `claimSession()` function that establishes a session from the init response's `csrf_token`. This mirrors `login()` but takes a `csrf_token` string directly instead of calling the login API.

**New function:**
```typescript
/** Establish session after claim (init with passphrase). */
export function claimSession(csrfToken: string): void {
	setCsrfToken(csrfToken);
	setAuthMode('cookie');
	authMode.set('web');
	isAuthenticated.set(true);
}
```

### 3. `dashboard/src/routes/+layout.svelte`

**Changes:** Restructure the `onMount` logic to check config/claimed status BEFORE checking auth for non-bearer users.

**New flow:**
```
onMount:
  1. initTheme()
  2. Try Tauri token (bearer mode)
  3. If bearer ‚Üí set bearer mode, connectWs, then check config ‚Üí onboarding or app
  4. If NOT bearer (web/LAN):
     a. GET /api/settings/status ‚Üí { configured, claimed }
     b. If !configured ‚Üí goto('/onboarding'), done
     c. If configured ‚Üí checkAuth()
        - If session valid ‚Üí connectWs, check if on login ‚Üí goto('/')
        - If no session ‚Üí goto('/login') unless already there
  5. ready = true
```

**Key detail:** The current code checks auth first, then config. The new code checks config first for web users. The bearer path remains unchanged ‚Äî it always authenticates first, then checks config.

**Specific implementation:**
```svelte
<script lang="ts">
	import "../app.css";
	import { setToken, setAuthMode, setCsrfToken } from "$lib/api";
	import { connectWs } from "$lib/stores/websocket";
	import { initTheme } from "$lib/stores/theme";
	import { checkAuth, authMode as authModeStore } from "$lib/stores/auth";
	import { onMount } from "svelte";
	import { goto } from "$app/navigation";
	import { page } from "$app/stores";
	import { api } from "$lib/api";

	let { children } = $props();
	let ready = $state(false);

	onMount(async () => {
		initTheme();

		// Step 1: Try Tauri token or dev fallback (bearer mode).
		let token = "";
		try {
			const { invoke } = await import("@tauri-apps/api/core");
			token = await invoke("get_api_token");
		} catch {
			token = __DEV_API_TOKEN__;
		}

		if (token) {
			// Bearer mode: Tauri desktop or dev mode ‚Äî unchanged.
			setToken(token);
			setAuthMode("bearer");
			authModeStore.set("tauri");
			connectWs(token);

			// Check config for onboarding redirect.
			try {
				const status = await api.settings.configStatus();
				if (!status.configured && !$page.url.pathname.startsWith("/onboarding")) {
					goto("/onboarding");
				}
			} catch {
				// Server not ready ‚Äî allow through.
			}
		} else {
			// Web/LAN mode: check config status FIRST, then auth.
			const path = $page.url.pathname;

			try {
				const status = await api.settings.configStatus();

				if (!status.configured) {
					// Fresh or unconfigured instance ‚Üí onboarding (skip login).
					if (!path.startsWith("/onboarding")) {
						goto("/onboarding");
					}
					ready = true;
					return;
				}

				// Configured instance ‚Üí check for existing session.
				const hasSession = await checkAuth();
				if (hasSession) {
					connectWs();
					// If user landed on login but has valid session, go to app.
					if (path.startsWith("/login")) {
						goto("/");
					}
				} else {
					// No session ‚Üí login page (unless already there or on onboarding).
					if (!path.startsWith("/login") && !path.startsWith("/onboarding")) {
						goto("/login");
						ready = true;
						return;
					}
				}
			} catch {
				// Server not reachable ‚Äî allow through (loading state will show).
			}
		}

		ready = true;
	});
</script>
```

### 4. `dashboard/src/lib/wordlist.ts` (NEW FILE)

**Purpose:** Export the EFF short wordlist as a TypeScript array and a `generatePassphrase()` function.

**Implementation:**
```typescript
/** EFF short wordlist (1,296 words) ‚Äî same list used by the backend. */
const WORDLIST: string[] = [
  'aardvark', 'abandoned', 'abbreviate', /* ... all 1,296 words ... */
];

/** Generate a random 4-word passphrase from the EFF short wordlist. */
export function generatePassphrase(): string {
  const words: string[] = [];
  const arr = new Uint32Array(4);
  crypto.getRandomValues(arr);
  for (let i = 0; i < 4; i++) {
    words.push(WORDLIST[arr[i] % WORDLIST.length]);
  }
  return words.join(' ');
}
```

**Note:** Uses `crypto.getRandomValues()` for cryptographic randomness, not `Math.random()`.

### 5. `dashboard/src/lib/components/onboarding/ClaimStep.svelte` (NEW FILE)

**Purpose:** Passphrase creation UI for the onboarding wizard.

**Props:** None (reads from global state).

**Features:**
- Generates a 4-word passphrase on mount using `generatePassphrase()`.
- "Regenerate" button to generate a new passphrase.
- "Copy to clipboard" button with visual feedback (checkmark for 2 seconds).
- "I've saved my passphrase" checkbox ‚Äî required before the parent's submit button is enabled.
- Clear copy explaining what the passphrase is for: "This passphrase protects your Tuitbot dashboard when accessing it from a browser. You'll need it to log in again if your session expires."
- Warning text: "Save this passphrase now ‚Äî it cannot be recovered later."
- Input field allowing the user to type a custom passphrase instead.
- Minimum 8 character validation shown inline.

**State management:**
- The passphrase value is stored in a local `$state` variable ‚Äî NOT in the onboarding store and NOT in localStorage. This ensures the plaintext is never persisted.
- An `onboardingData.updateField('passphrase_saved', true/false)` flag controls whether the parent's submit button is enabled.

**Actually ‚Äî correction:** We should NOT store the passphrase in the onboarding store (it gets reset on submit). Instead, the passphrase needs to be available in the `submit()` function of `+page.svelte`. We'll use a module-level exported reactive state or a small dedicated store that's never persisted.

**Revised approach:** Add a module-level export from ClaimStep that provides the current passphrase value. The parent page imports it. Alternatively, use Svelte 5's `$bindable` pattern to let the parent own the state. Given the parent already owns `submit()`, the simplest approach is:
- Parent (`+page.svelte`) owns `claimPassphrase` state.
- Parent passes it as a `$bindable` prop to ClaimStep.
- ClaimStep generates the passphrase and binds it back.
- Parent includes it in the init payload.

**Layout:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Secure Your Instance                        ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  This passphrase protects your dashboard    ‚îÇ
‚îÇ  when accessing from a browser.             ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê [üîÑ] [üìã] ‚îÇ
‚îÇ  ‚îÇ alpine cobra morning puzzle ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  Or type your own (minimum 8 characters):   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ                                         ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚ö† Save this passphrase ‚Äî it cannot be     ‚îÇ
‚îÇ    recovered later. You can reset it from   ‚îÇ
‚îÇ    Settings ‚Üí LAN Access or via the CLI.    ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚òê I've saved my passphrase                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6. `dashboard/src/routes/onboarding/+page.svelte`

**Changes:**

a) Import `ClaimStep` and `authMode` store:
```typescript
import ClaimStep from '$lib/components/onboarding/ClaimStep.svelte';
import { authMode as authModeStore, claimSession } from '$lib/stores/auth';
import { connectWs } from '$lib/stores/websocket';
```

b) Add state for claim:
```typescript
let claimPassphrase = $state('');
let passphraseSaved = $state(false);
```

c) Compute whether claim step is needed:
```typescript
// Tauri/bearer mode skips the claim step.
let isTauri = $derived($authModeStore === 'tauri');
let steps = $derived(isTauri
    ? ['Welcome', 'X API', 'Business', 'LLM', 'Language', 'Sources', 'Validate', 'Review']
    : ['Welcome', 'X API', 'Business', 'LLM', 'Language', 'Sources', 'Validate', 'Review', 'Secure']
);
let isLastStep = $derived(currentStep === steps.length - 1);
let isClaimStep = $derived(!isTauri && currentStep === steps.length - 1);
```

d) Replace the static `STEPS` constant with the reactive `steps`.

e) Update `canAdvance()` for the claim step:
```typescript
case 8: // Secure (claim) ‚Äî only when not Tauri
    return claimPassphrase.trim().length >= 8 && passphraseSaved;
```

f) Update `submit()` to include `claim` when in web mode:
```typescript
async function submit() {
    submitting = true;
    errorMsg = '';
    try {
        const data = $onboardingData;
        const config: Record<string, unknown> = { /* ...existing config building... */ };

        // Include claim for web mode.
        if (!isTauri && claimPassphrase.trim()) {
            config.claim = { passphrase: claimPassphrase.trim() };
        }

        const result = await api.settings.init(config);

        if (result.status === 'validation_failed' && result.errors) {
            errorMsg = result.errors.map((e) => `${e.field}: ${e.message}`).join('; ');
            return;
        }

        // If claim was included, establish session from response.
        if (result.csrf_token) {
            claimSession(result.csrf_token);
            connectWs();
        }

        onboardingData.reset();
        goto('/content?compose=true');
    } catch (e) {
        errorMsg = e instanceof Error ? e.message : 'Failed to create configuration';
    } finally {
        submitting = false;
    }
}
```

g) Add ClaimStep rendering in the template:
```svelte
{:else if currentStep === 8 && !isTauri}
    <ClaimStep bind:passphrase={claimPassphrase} bind:saved={passphraseSaved} />
```

h) Update the last-step button to show on `isLastStep` instead of hardcoded step 7.

i) Add `beforeunload` guard for the claim step:
```typescript
$effect(() => {
    if (isClaimStep && claimPassphrase && !submitting) {
        const handler = (e: BeforeUnloadEvent) => { e.preventDefault(); };
        window.addEventListener('beforeunload', handler);
        return () => window.removeEventListener('beforeunload', handler);
    }
});
```

### 7. `dashboard/src/routes/login/+page.svelte`

**Changes:**

a) Update subtitle copy from "Enter the passphrase shown in your server terminal" to more actionable copy:
```
"Enter your passphrase to access the dashboard."
```

b) Add a "forgot passphrase?" section below the form:
```svelte
<div class="help-section">
    <p class="help-title">Forgot your passphrase?</p>
    <p class="help-text">
        Reset it from the terminal:
    </p>
    <code class="help-code">tuitbot-server --reset-passphrase</code>
    <p class="help-text">
        Or if using cargo:
    </p>
    <code class="help-code">cargo run -p tuitbot-server -- --reset-passphrase</code>
</div>
```

c) Improve error messaging ‚Äî make error more specific:
- On 401/incorrect passphrase: "Incorrect passphrase. Check your spelling and try again."
- On network error: "Cannot reach the server. Is it running?"

d) Add visible focus states to the input and button (currently the input has `border-color` change on focus, but the button has no focus style). Add:
```css
.login-btn:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

.input-group input:focus-visible {
    border-color: var(--color-accent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-accent) 20%, transparent);
}
```

e) Add `aria-label` to the submit button and `aria-live="polite"` to the error region for screen reader accessibility.

f) Update the hint at the bottom to be contextually aware:
```
Start the server with --host 0.0.0.0 to access from other devices on your network.
```
This stays the same ‚Äî it's already clear.

### 8. `dashboard/src/routes/(app)/settings/LanAccessSection.svelte`

**Changes:**

a) Add `aria-label` attributes to icon-only buttons (Copy, Reset). The copy button (line 165) has a `title` but no `aria-label`. The reset button (line 178) has neither for the icon.

```svelte
<!-- Copy button -->
<button class="copy-btn" onclick={copyPassphrase} aria-label="Copy passphrase to clipboard">
```

b) Add visible focus states to the toggle, copy button, and reset button:
```css
.toggle:focus-visible .toggle-track {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

.copy-btn:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}

.reset-btn:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
}
```

c) Add confirmation before reset ‚Äî currently clicking "Reset Passphrase" immediately resets without warning. Add a two-click confirmation:
```typescript
let confirmingReset = $state(false);
let confirmTimeout: ReturnType<typeof setTimeout> | null = null;

function initiateReset() {
    if (confirmingReset) {
        handleResetPassphrase();
        confirmingReset = false;
        if (confirmTimeout) clearTimeout(confirmTimeout);
    } else {
        confirmingReset = true;
        confirmTimeout = setTimeout(() => { confirmingReset = false; }, 3000);
    }
}
```

The button text changes from "Reset Passphrase" to "Confirm Reset" (with a warning color) on first click, then actually resets on second click. Reverts after 3 seconds if not confirmed.

d) Update copy for the passphrase section to match the new first-run flow context:
```svelte
<span class="field-hint">
    Generate a new passphrase for browser login. All existing sessions will continue working.
</span>
```

e) Add error display for failed reset operations (currently only `console.error`):
```typescript
let resetError = $state('');

// In handleResetPassphrase catch block:
resetError = 'Failed to reset passphrase. Please try again.';
```

### 9. `docs/lan-mode.md`

**Changes:**

a) Update the "When you open the dashboard in a browser..." paragraph (line 50) to describe the new flow:
```
When you open the dashboard in a browser without a bearer token on a fresh install, you're
directed to the onboarding wizard. At the end of setup, you'll create a passphrase that
protects future browser sessions. A session cookie is set automatically, so you're logged
in immediately after onboarding. On subsequent visits, if your session has expired, you'll
see a login screen where you enter the same passphrase.
```

b) The "First-Time Setup (Browser)" section (lines 23-39) is already correct from Session 02. No changes needed.

c) Update the troubleshooting section's "Invalid passphrase" item to mention the new reset guidance:
```
**"Invalid passphrase"**
- Passphrase is case-sensitive and space-separated (4 words if auto-generated)
- You can reset it from the terminal: `tuitbot-server --reset-passphrase`
- Or from Settings ‚Üí LAN Access ‚Üí Reset Passphrase (requires an active session)
```

### 10. `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md` (NEW FILE)

Created at the end of the session with:
- What changed (all files modified/created)
- Design decisions made
- CI results
- Open issues / deferred to session 04
- Exact inputs for session 04

---

## Files to Create

| File | Purpose | Approx Lines |
|------|---------|-------------|
| `dashboard/src/lib/wordlist.ts` | EFF wordlist + `generatePassphrase()` | ~1,310 |
| `dashboard/src/lib/components/onboarding/ClaimStep.svelte` | Passphrase creation UI | ~250 |
| `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md` | Session handoff | ~100 |

---

## Order of Operations

### Phase 1: Foundation (no UI impact)

1. **Create `dashboard/src/lib/wordlist.ts`**
   - Copy the 1,296 words from `crates/tuitbot-core/assets/eff_short_wordlist.txt` into a TS array.
   - Implement `generatePassphrase()` using `crypto.getRandomValues()`.
   - This file has zero dependencies and can be created first.

2. **Update `dashboard/src/lib/api.ts`**
   - Add `claimed: boolean` to `ConfigStatus` interface.
   - Rewrite `api.settings.init()` to use custom fetch with `credentials: 'include'`.
   - Update the return type to include `csrf_token?: string`.

3. **Update `dashboard/src/lib/stores/auth.ts`**
   - Add `claimSession(csrfToken: string)` function.

### Phase 2: Layout Gate

4. **Update `dashboard/src/routes/+layout.svelte`**
   - Restructure `onMount` to check config/claimed before auth for web users.
   - Bearer path remains identical but pulls config check into the bearer block too for cleanliness.
   - Test: mentally trace all four scenarios (fresh web, returning web, expired web, Tauri).

### Phase 3: Onboarding Claim Step

5. **Create `dashboard/src/lib/components/onboarding/ClaimStep.svelte`**
   - Passphrase generation UI with copy, regenerate, custom input, save confirmation.
   - Uses `$bindable` props for `passphrase` and `saved`.
   - Includes `beforeunload` guard logic.

6. **Update `dashboard/src/routes/onboarding/+page.svelte`**
   - Import ClaimStep and auth stores.
   - Make STEPS dynamic based on auth mode.
   - Add claim passphrase state.
   - Update `submit()` to include claim and establish session.
   - Update template to render ClaimStep on the final step for web mode.

### Phase 4: Login & Settings Polish

7. **Update `dashboard/src/routes/login/+page.svelte`**
   - Update subtitle copy.
   - Add forgot passphrase section.
   - Improve error messages.
   - Add focus-visible styles and ARIA attributes.

8. **Update `dashboard/src/routes/(app)/settings/LanAccessSection.svelte`**
   - Add ARIA labels to buttons.
   - Add focus-visible styles.
   - Add reset confirmation.
   - Update helper copy.
   - Add error display.

### Phase 5: Documentation & Handoff

9. **Update `docs/lan-mode.md`**
   - Update flow description.
   - Update troubleshooting guidance.

10. **Run CI checks**
    ```bash
    cargo fmt --all && cargo fmt --all --check
    RUSTFLAGS="-D warnings" cargo test --workspace
    cargo clippy --workspace -- -D warnings
    cd dashboard && npm run check
    cd dashboard && npm run build
    ```

11. **Create `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md`**
    - Document everything.

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `api.settings.init()` doesn't receive the `Set-Cookie` because `credentials: 'include'` is missing | High if not addressed | Session not established after claim | Custom fetch call with `credentials: 'include'` (explicitly planned above) |
| CSRF token not stored after claim, causing 403 on first authenticated request | Medium | First POST fails | `claimSession()` sets the token in the same code path as the init response handler |
| Tauri bearer mode accidentally shows claim step | Low | Confusing UX | `isTauri` derived from `authModeStore` which is set before onboarding redirect |
| `beforeunload` prevents navigation after successful submit | Medium | User stuck | Remove listener before `goto()` by checking `submitting` flag |
| EFF wordlist in TS doesn't match backend wordlist | Low | Different passphrase suggestions | Copy directly from `crates/tuitbot-core/assets/eff_short_wordlist.txt` during implementation |
| Layout gate race condition: config status returns before page store is ready | Low | Wrong redirect | `$page.url.pathname` is available synchronously in `onMount` |
| User types a custom passphrase < 8 chars and clicks submit | Low | 400 from backend | Frontend validates minimum 8 chars; submit button disabled until valid |
| `npm run build` fails due to TypeScript type mismatch on `init()` | Medium | Build gate fails | Test build after api.ts changes, before building the full claim flow |

---

## Verification Steps

### Automated
1. `cargo fmt --all && cargo fmt --all --check` ‚Äî Rust formatting (no Rust changes expected, but verify nothing regressed)
2. `RUSTFLAGS="-D warnings" cargo test --workspace` ‚Äî Rust tests (no Rust changes expected)
3. `cargo clippy --workspace -- -D warnings` ‚Äî Rust lint (no Rust changes expected)
4. `cd dashboard && npm run check` ‚Äî Svelte/TypeScript type checking
5. `cd dashboard && npm run build` ‚Äî Production build succeeds

### Manual Trace (mental verification)

**Scenario 1: Fresh install, web mode**
- Server starts on localhost (no passphrase_hash, no config.toml)
- Browser opens ‚Üí `+layout.svelte` ‚Üí no token ‚Üí web path
- `configStatus()` returns `{ configured: false, claimed: false }`
- Redirect to `/onboarding`
- User completes steps 1-8 (including Secure step)
- `submit()` sends `POST /api/settings/init` with `claim: { passphrase: "..." }`
- Response: `{ status: "created", config: {...}, csrf_token: "..." }` + Set-Cookie
- `claimSession(csrf_token)` ‚Üí auth mode = web, CSRF stored
- `connectWs()` ‚Üí WebSocket connected
- `goto('/content?compose=true')` ‚Üí dashboard

**Scenario 2: Fresh install, Tauri mode**
- Tauri sidecar starts server ‚Üí no passphrase_hash, no config.toml
- Bearer token available ‚Üí bearer path
- `configStatus()` returns `{ configured: false }`
- Redirect to `/onboarding`
- Steps array has 8 items (no Secure step)
- `submit()` sends `POST /api/settings/init` WITHOUT claim
- Response: `{ status: "created", config: {...} }` ‚Äî no cookie, no CSRF
- `goto('/content?compose=true')` ‚Üí dashboard (bearer auth continues)

**Scenario 3: Returning web user, session expired**
- Server running with existing config.toml and passphrase_hash
- Browser opens ‚Üí no token ‚Üí web path
- `configStatus()` returns `{ configured: true, claimed: true }`
- `checkAuth()` ‚Üí no valid session ‚Üí returns false
- Redirect to `/login`
- User enters passphrase ‚Üí `login()` ‚Üí session established
- `goto('/')` ‚Üí dashboard

**Scenario 4: Returning web user, valid session**
- Server running with existing config.toml and passphrase_hash
- Browser opens ‚Üí no token ‚Üí web path
- `configStatus()` returns `{ configured: true, claimed: true }`
- `checkAuth()` ‚Üí valid session ‚Üí returns true, CSRF restored
- `connectWs()` ‚Üí WebSocket connected
- Dashboard renders directly

---

## Estimate of File Changes

| File | Lines Changed (approx) | Type |
|------|----------------------|------|
| `dashboard/src/lib/wordlist.ts` | ~1,310 new | Create |
| `dashboard/src/lib/components/onboarding/ClaimStep.svelte` | ~250 new | Create |
| `dashboard/src/lib/api.ts` | ~20 modified | Edit |
| `dashboard/src/lib/stores/auth.ts` | ~10 added | Edit |
| `dashboard/src/routes/+layout.svelte` | ~40 rewritten | Edit |
| `dashboard/src/routes/onboarding/+page.svelte` | ~60 modified | Edit |
| `dashboard/src/routes/login/+page.svelte` | ~60 modified | Edit |
| `dashboard/src/routes/(app)/settings/LanAccessSection.svelte` | ~50 modified | Edit |
| `docs/lan-mode.md` | ~15 modified | Edit |
| `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md` | ~100 new | Create |
