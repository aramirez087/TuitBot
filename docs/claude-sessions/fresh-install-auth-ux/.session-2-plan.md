# Session 2 Implementation Plan — Backend Claim Bootstrap

**Date:** 2026-02-28
**Branch:** `feat/init_improvements`
**Goal:** Implement the backend claim bootstrap flow so a fresh install can establish its passphrase and receive a valid web session during initial setup.

---

## Summary of Current State

- **Session 01** produced documentation only (charter + handoff). No source code was modified.
- `POST /api/settings/init` currently accepts a raw `serde_json::Value`, converts it to TOML, validates via `Config`, and writes `config.toml`. Returns 409 if config already exists.
- `GET /api/settings/status` returns `{ configured, deployment_mode, capabilities }`. No `claimed` field.
- `passphrase.rs` has `ensure_passphrase()` (check-then-generate), `hash_passphrase()`, `verify_passphrase()`, `load_passphrase_hash()`, `reset_passphrase()`. No `create_passphrase_hash()`.
- `main.rs:84` calls `ensure_passphrase()` unconditionally at startup.
- `AppState.passphrase_hash` is `RwLock<Option<String>>` — supports runtime updates.
- Auth middleware exempts `/settings/init` and `/settings/status` — no new unauthenticated surface area needed.
- The login route (`auth/routes.rs:97-175`) shows the exact pattern for creating sessions and setting cookies.

---

## Files to Modify/Create

| # | File | Action | Purpose |
|---|------|--------|---------|
| 1 | `crates/tuitbot-core/src/auth/error.rs` | Modify | Add `AlreadyClaimed` variant |
| 2 | `crates/tuitbot-core/src/auth/passphrase.rs` | Modify | Add `create_passphrase_hash()` function |
| 3 | `crates/tuitbot-server/src/routes/settings.rs` | Modify | Extend `init_settings` with claim handling; extend `config_status` with `claimed` field |
| 4 | `crates/tuitbot-server/src/main.rs` | Modify | Make `ensure_passphrase` conditional on bind host |
| 5 | `crates/tuitbot-server/tests/fresh_install_auth.rs` | Create | Integration tests for claim bootstrap |
| 6 | `docs/roadmap/fresh-install-auth-ux/backend-contract.md` | Create | Document the backend API contract |
| 7 | `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md` | Create | Session handoff for Session 03 |
| 8 | `docs/lan-mode.md` | Modify | Update to reflect claim flow and conditional passphrase generation |

---

## Exact Order of Operations

### Step 1: Add `AlreadyClaimed` error variant

**File:** `crates/tuitbot-core/src/auth/error.rs`

Add a new variant to `AuthError`:

```rust
/// Attempted to claim an instance that already has a passphrase.
#[error("instance already claimed")]
AlreadyClaimed,
```

**Rationale:** The claim flow needs a distinct error when the passphrase_hash file already exists. This maps to HTTP 409 at the server layer. Keeping it in the core error enum follows the existing pattern (e.g., `InvalidPassphrase`, `RateLimited`).

### Step 2: Add `create_passphrase_hash()` to core

**File:** `crates/tuitbot-core/src/auth/passphrase.rs`

Add a new public function:

```rust
/// Create a passphrase hash from a user-provided plaintext.
///
/// This is the "claim" operation for first-time web setup. It:
/// - Validates the passphrase (minimum 8 characters)
/// - Checks that no hash file exists (returns AlreadyClaimed if it does)
/// - Hashes with bcrypt (cost 12)
/// - Writes the hash to `data_dir/passphrase_hash` with 0600 permissions
///
/// The plaintext is never logged or persisted.
pub fn create_passphrase_hash(data_dir: &Path, plaintext: &str) -> Result<(), AuthError>
```

**Design decisions:**

1. **Validation rule: minimum 8 characters.** This covers both multi-word passphrases ("word word" = 9 chars) and short custom passwords. No maximum length. The frontend will suggest 4-word EFF phrases (~20+ chars), but we don't mandate the format. This is the simplest useful validation.

2. **Atomicity: check-then-write (NOT `O_EXCL`).** The existing `ensure_passphrase` uses check-then-write. The race window is negligible because: (a) `init_settings` already returns 409 if config exists, so the second concurrent request fails at the config level before reaching the claim; (b) claim is a one-shot human operation, not a high-concurrency path. Using the same pattern as `ensure_passphrase` keeps the code consistent and avoids platform-specific `O_EXCL` handling.

3. **No logging of plaintext.** The function only logs at the tracing level that a claim occurred, never the passphrase itself.

**Implementation outline:**

```rust
pub fn create_passphrase_hash(data_dir: &Path, plaintext: &str) -> Result<(), AuthError> {
    // Validate minimum length
    if plaintext.len() < 8 {
        return Err(AuthError::Storage {
            message: "passphrase must be at least 8 characters".to_string(),
        });
    }

    let hash_path = data_dir.join("passphrase_hash");

    // Reject if already claimed
    if hash_path.exists() {
        let existing = std::fs::read_to_string(&hash_path).map_err(|e| AuthError::Storage {
            message: format!("failed to read passphrase hash: {e}"),
        })?;
        if !existing.trim().is_empty() {
            return Err(AuthError::AlreadyClaimed);
        }
    }

    let hash = hash_passphrase(plaintext)?;

    std::fs::create_dir_all(data_dir).map_err(|e| AuthError::Storage {
        message: format!("failed to create data directory: {e}"),
    })?;
    std::fs::write(&hash_path, &hash).map_err(|e| AuthError::Storage {
        message: format!("failed to write passphrase hash: {e}"),
    })?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let _ = std::fs::set_permissions(&hash_path, std::fs::Permissions::from_mode(0o600));
    }

    Ok(())
}
```

**Also add a helper** for checking if claimed:

```rust
/// Check if a passphrase hash file exists (i.e., the instance has been claimed).
pub fn is_claimed(data_dir: &Path) -> bool {
    let hash_path = data_dir.join("passphrase_hash");
    if !hash_path.exists() {
        return false;
    }
    std::fs::read_to_string(&hash_path)
        .map(|s| !s.trim().is_empty())
        .unwrap_or(false)
}
```

**Tests to add** (in the existing `mod tests` block):

- `create_passphrase_hash_creates_file` — creates hash file, can verify with `verify_passphrase`
- `create_passphrase_hash_rejects_short_passphrase` — returns error for < 8 chars
- `create_passphrase_hash_rejects_already_claimed` — returns `AlreadyClaimed` when hash file exists
- `is_claimed_returns_false_on_empty_dir` / `is_claimed_returns_true_after_create`

### Step 3: Extend `init_settings` with claim handling

**File:** `crates/tuitbot-server/src/routes/settings.rs`

This is the most complex change. The current handler accepts `Json<Value>` and passes the entire body to `json_to_toml`. We need to:

1. Extract the optional `claim` field before TOML conversion
2. Process the claim after config creation succeeds
3. Create a session and return Set-Cookie if claim was processed

**New types:**

```rust
#[derive(Deserialize)]
struct ClaimRequest {
    passphrase: String,
}
```

**Modified `init_settings` flow:**

```rust
pub async fn init_settings(
    State(state): State<Arc<AppState>>,
    Json(mut body): Json<Value>,
) -> Result<impl IntoResponse, ApiError> {
    // 1. Check config doesn't already exist (unchanged)
    if state.config_path.exists() {
        return Err(ApiError::Conflict("configuration already exists...".into()));
    }

    // 2. Extract and remove `claim` before TOML conversion
    let claim: Option<ClaimRequest> = body
        .as_object_mut()
        .and_then(|obj| obj.remove("claim"))
        .map(|v| serde_json::from_value(v))
        .transpose()
        .map_err(|e| ApiError::BadRequest(format!("invalid claim object: {e}")))?;

    // 3. Validate claim.passphrase before doing any file I/O
    if let Some(ref claim) = claim {
        if claim.passphrase.len() < 8 {
            return Err(ApiError::BadRequest(
                "passphrase must be at least 8 characters".into(),
            ));
        }
        // Pre-check: if already claimed, reject early with 409
        if passphrase::is_claimed(&state.data_dir) {
            return Err(ApiError::Conflict("instance already claimed".into()));
        }
    }

    // 4. Convert remaining body to TOML, validate, write config (unchanged logic)
    // ... existing json_to_toml, Config parse, validate, write ...

    // 5. If claim present, create passphrase hash + session
    if let Some(claim) = claim {
        // Create passphrase hash (will fail with AlreadyClaimed on race)
        passphrase::create_passphrase_hash(&state.data_dir, &claim.passphrase)
            .map_err(|e| match e {
                AuthError::AlreadyClaimed => ApiError::Conflict("instance already claimed".into()),
                other => ApiError::Internal(format!("failed to create passphrase: {other}")),
            })?;

        // Update in-memory hash
        let new_hash = passphrase::load_passphrase_hash(&state.data_dir)
            .map_err(|e| ApiError::Internal(format!("failed to load hash: {e}")))?;
        {
            let mut hash = state.passphrase_hash.write().await;
            *hash = new_hash;
        }

        // Create session (same pattern as login route)
        let new_session = session::create_session(&state.db).await
            .map_err(|e| ApiError::Internal(format!("failed to create session: {e}")))?;

        let cookie = format!(
            "tuitbot_session={}; HttpOnly; SameSite=Strict; Path=/; Max-Age=604800",
            new_session.raw_token,
        );

        tracing::info!("instance claimed via /settings/init");

        return Ok((
            StatusCode::OK,
            [(axum::http::header::SET_COOKIE, cookie)],
            Json(serde_json::json!({
                "status": "created",
                "config": json,
                "csrf_token": new_session.csrf_token,
            })),
        ).into_response());
    }

    // 6. No claim — return existing response shape (backward compatible)
    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "status": "created",
            "config": json
        })),
    ).into_response())
}
```

**Key design decisions:**

1. **`claim` extracted from body via `obj.remove("claim")`** before `json_to_toml()`. This prevents TOML serialization errors from the non-config `claim` field and avoids needing a typed request struct that wraps the entire config (which would break compatibility).

2. **Return type changes to `impl IntoResponse`** because the claim path needs to set a `Set-Cookie` header while the non-claim path doesn't. Using Axum's `.into_response()` pattern handles both cases.

3. **Passphrase validation happens before config file I/O.** If the passphrase is too short or the instance is already claimed, we reject before writing any config. This prevents partial states.

4. **Session creation uses the exact same cookie format as the login route** (`auth/routes.rs:149-152`). This ensures the frontend handles it identically.

5. **The `csrf_token` is added to the JSON response body** (same pattern as login's `LoginResponse`). The frontend will need to store this for subsequent mutating requests.

**New imports needed:**

```rust
use axum::http::StatusCode;
use axum::response::IntoResponse;
use tuitbot_core::auth::{passphrase, session};
use tuitbot_core::auth::error::AuthError;
```

### Step 4: Extend `config_status` with `claimed` field

**File:** `crates/tuitbot-server/src/routes/settings.rs`

Modify the existing `config_status` handler:

```rust
pub async fn config_status(State(state): State<Arc<AppState>>) -> Json<Value> {
    let configured = state.config_path.exists();
    let claimed = passphrase::is_claimed(&state.data_dir);
    let capabilities = state.deployment_mode.capabilities();
    Json(serde_json::json!({
        "configured": configured,
        "claimed": claimed,
        "deployment_mode": state.deployment_mode,
        "capabilities": capabilities,
    }))
}
```

**Rationale:** Uses the new `is_claimed()` helper. Checks the file system every time (no caching) — this is an infrequent call on a local file, so no performance concern. The `claimed` field is additive, so existing callers that don't read it are unaffected.

### Step 5: Make startup passphrase generation conditional

**File:** `crates/tuitbot-server/src/main.rs`

Replace lines 78-94 (the passphrase handling block):

```rust
// Handle passphrase for web/LAN auth.
let passphrase_hash = if cli.reset_passphrase {
    // --reset-passphrase: always reset, regardless of host
    let new_passphrase = passphrase::reset_passphrase(db_dir)?;
    println!("\n  Web login passphrase (reset): {new_passphrase}\n");
    tracing::info!("Passphrase has been reset");
    passphrase::load_passphrase_hash(db_dir)?
} else if bind_host == "0.0.0.0" {
    // LAN mode: auto-generate passphrase if none exists (backward compatible)
    match passphrase::ensure_passphrase(db_dir)? {
        Some(new_passphrase) => {
            println!("\n  Web login passphrase: {new_passphrase}");
            println!("  (save this — it won't be shown again)\n");
        }
        None => {
            tracing::info!("Passphrase already configured");
        }
    }
    passphrase::load_passphrase_hash(db_dir)?
} else {
    // Localhost mode: load existing hash if present, skip generation
    // The browser claim flow will handle passphrase creation
    match passphrase::load_passphrase_hash(db_dir)? {
        Some(hash) => {
            tracing::info!("Passphrase loaded from disk");
            Some(hash)
        }
        None => {
            tracing::info!("No passphrase configured — awaiting browser claim");
            None
        }
    }
};
```

**Important:** The `bind_host` variable is computed further down in the current code (lines 105-112). The passphrase block (lines 78-94) runs before `bind_host` is known. We need to either:

- **Option A:** Move the passphrase block after `bind_host` computation. This requires careful reordering — `bind_host` depends on `loaded_config` which depends on `Config::load`. But `passphrase_hash` initialization doesn't depend on `bind_host`. We can compute `bind_host` earlier.
- **Option B:** Use `cli.host` directly instead of `bind_host`. The distinction matters: `bind_host` can be overridden by the config file. But for the purpose of "did the user explicitly request LAN mode", `cli.host` is the right signal — if the CLI flag says `0.0.0.0`, auto-generate; otherwise defer to the claim flow.

**Decision: Use `cli.host` directly.** This is simpler and more correct. If a user has `host = "0.0.0.0"` in their config but didn't pass `--host 0.0.0.0`, they're a returning user (config already exists, passphrase already exists). The conditional generation only matters for first starts.

Actually, re-reading the code more carefully: `cli.host` defaults to `"127.0.0.1"`, and `bind_host` can be overridden from config. For first-time installs, there's no config file, so `bind_host == cli.host`. For returning users, the passphrase already exists, so `ensure_passphrase` would return `None` anyway. **Using `cli.host` is correct and safe.**

### Step 6: Create integration tests

**File:** `crates/tuitbot-server/tests/fresh_install_auth.rs`

Following the pattern from `api_tests.rs`:

```rust
//! Integration tests for the fresh-install claim bootstrap flow.

// Test helpers: test_router_with_dir(tempdir) that sets data_dir and config_path
// to a tempdir so we can test fresh-install scenarios with isolated state.

// Tests:

// 1. claim_creates_passphrase_and_session
//    POST /api/settings/init with valid config + claim.passphrase
//    → 200, response has "status": "created", "csrf_token" present
//    → Set-Cookie header present with "tuitbot_session="
//    → passphrase_hash file exists in data_dir
//    → passphrase verifies against the stored hash

// 2. claim_rejects_already_claimed
//    Pre-create a passphrase_hash file in data_dir
//    POST /api/settings/init with config + claim.passphrase
//    → 409

// 3. claim_rejects_short_passphrase
//    POST /api/settings/init with claim.passphrase = "short"
//    → 400

// 4. init_without_claim_works_as_before
//    POST /api/settings/init with valid config, no claim field
//    → 200, response has "status": "created"
//    → No Set-Cookie header
//    → No csrf_token in response
//    → No passphrase_hash file created

// 5. config_status_includes_claimed_false
//    GET /api/settings/status on fresh instance
//    → 200, "claimed": false

// 6. config_status_includes_claimed_true
//    Pre-create passphrase_hash file
//    GET /api/settings/status
//    → 200, "claimed": true

// 7. init_with_claim_then_login_works
//    POST /api/settings/init with claim → get csrf_token
//    Extract session cookie from response
//    Use cookie + csrf_token to make an authenticated POST request
//    → Should succeed (proves the session is valid)

// 8. double_init_returns_409
//    POST /api/settings/init twice (even without claim)
//    Second call → 409 (existing behavior, regression test)
```

**Test helper:**

```rust
async fn test_router_with_dir(dir: &std::path::Path) -> axum::Router {
    let pool = storage::init_test_db().await.expect("init test db");
    let (event_tx, _) = tokio::sync::broadcast::channel::<WsEvent>(256);

    let state = Arc::new(AppState {
        db: pool,
        config_path: dir.join("config.toml"),
        data_dir: dir.to_path_buf(),
        event_tx,
        api_token: TEST_TOKEN.to_string(),
        passphrase_hash: tokio::sync::RwLock::new(None),
        bind_host: "127.0.0.1".to_string(),
        bind_port: 3001,
        login_attempts: Mutex::new(std::collections::HashMap::new()),
        content_generators: Mutex::new(std::collections::HashMap::new()),
        runtimes: Mutex::new(std::collections::HashMap::new()),
        circuit_breaker: None,
        watchtower_cancel: None,
        content_sources: Default::default(),
        deployment_mode: Default::default(),
    });

    tuitbot_server::build_router(state)
}
```

**Note on test config body:** We need a valid Config JSON body for init. Based on reading `Config::default()` and the existing test patterns, a minimal valid body is:

```json
{
  "x_api": {
    "consumer_key": "test",
    "consumer_secret": "test"
  },
  "business": {
    "product_name": "TestBot"
  }
}
```

We should verify this parses correctly during implementation. If `Config` requires more fields, we'll need to match its minimum validation requirements.

**Helper for extracting Set-Cookie from response:**

```rust
fn extract_set_cookie(response: &axum::http::Response<Body>) -> Option<String> {
    response
        .headers()
        .get("set-cookie")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string())
}
```

### Step 7: Update LAN mode documentation

**File:** `docs/lan-mode.md`

Add a new section "## First-Time Setup (Browser)" before "## How It Works":

```markdown
## First-Time Setup (Browser)

When the server starts on `127.0.0.1` (the default) without an existing passphrase,
it **does not** generate one automatically. Instead, the browser-based onboarding
wizard handles passphrase creation:

1. Start the server: `cargo run -p tuitbot-server`
2. Open `http://localhost:3001` in your browser
3. Complete the onboarding wizard
4. On the final step, set your passphrase (a 4-word phrase is suggested)
5. Save the passphrase — you'll need it to log in again after your session expires

The passphrase is created during `POST /api/settings/init` and a session cookie
is set automatically, so you're logged in immediately after onboarding.

**LAN mode (`--host 0.0.0.0`)** still generates a passphrase at startup and
prints it to the terminal, preserving backward compatibility for CLI users.
```

Also update the "## Quick Start" section to mention that the passphrase can also be set via the browser.

### Step 8: Create backend contract document

**File:** `docs/roadmap/fresh-install-auth-ux/backend-contract.md`

Document the modified API contract including:
- `GET /api/settings/status` response shape (with `claimed` field)
- `POST /api/settings/init` request shape (with optional `claim`)
- All response variants (200 with claim, 200 without claim, 400, 409)
- Cookie format and CSRF token delivery
- Passphrase validation rules

### Step 9: Create session handoff

**File:** `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md`

---

## Key Design Decisions

### D1: `claim` field extracted via `obj.remove()` — not a typed wrapper struct

The current `init_settings` accepts `Json<Value>`. We could switch to a typed struct wrapping the full config plus `Option<ClaimRequest>`, but that would break if the Config struct changes and would couple the server tightly to the core's Config layout. Instead, we extract `claim` from the raw Value before TOML conversion.

**Tradeoff:** Slightly less type-safe at the boundary, but maintains backward compatibility and keeps the code minimal.

### D2: Passphrase validation: minimum 8 characters, no format requirement

We don't require a specific format (e.g., "must be 4 words"). The frontend will suggest strong passphrases, but we allow custom ones. 8 chars is a pragmatic floor that catches empty/trivial inputs.

### D3: `is_claimed()` checks the filesystem, not in-memory state

We could check `state.passphrase_hash.read().await.is_some()` for the `claimed` field. But the filesystem is the source of truth — if the server started before a passphrase existed but one was created later (via the claim flow), the in-memory state might not be updated yet in all code paths. The filesystem check is always correct.

**Counter-argument:** After a successful claim, we do update the in-memory hash. So `state.passphrase_hash` would be in sync. However, for `config_status` (a GET endpoint), the filesystem check is simpler and avoids making the handler async for the RwLock.

**Decision:** Use `is_claimed()` (filesystem). It's O(1) on local SSD and always correct.

### D4: Conditional passphrase generation uses `cli.host`, not `bind_host`

`cli.host` reflects explicit user intent ("I started with `--host 0.0.0.0`"). `bind_host` can be overridden by config. For first-time installs (no config), they're identical. For returning users, the passphrase already exists. Using `cli.host` is simpler and more predictable.

### D5: Return type of `init_settings` changes to `impl IntoResponse`

The claim path needs to set a `Set-Cookie` header. The current return type `Result<Json<Value>, ApiError>` can't include headers. Changing to `Result<impl IntoResponse, ApiError>` (or `Result<Response, ApiError>`) handles both paths.

**Compatibility:** The JSON body shape is backward-compatible. The `csrf_token` field is additive (only present with claim). The `Set-Cookie` header is additive (browsers store it automatically, non-browser clients ignore it).

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `init_settings` return type change breaks compilation | High | Low | Use `into_response()` pattern from existing login handler; Axum supports this natively |
| Claim + config write is not truly atomic | Medium | Low | Config write happens before claim. If claim fails, config exists but no passphrase — user can re-claim or reset. If config fails, claim never runs. Acceptable for one-shot operation. |
| Existing tests fail due to changed `config_status` response | Medium | Low | Existing test `config_status_includes_capabilities` doesn't check for absence of `claimed` — it only asserts `configured`, `deployment_mode`, `capabilities` exist. Adding `claimed` is purely additive. |
| bcrypt hashing blocks the async runtime | Low | Medium | bcrypt at cost 12 takes ~250ms. The login handler already does this without `spawn_blocking`. We'll follow the same pattern for consistency. If it becomes an issue, both can be wrapped in `spawn_blocking` later. |
| Test config body doesn't pass validation | Medium | Low | Will need to verify the minimum valid Config JSON during implementation. May need to add more fields. |
| Import conflicts in `settings.rs` | Low | Low | The file currently imports from `tuitbot_core::config`. Adding `tuitbot_core::auth` imports is straightforward. |

---

## Verification Steps

### During Implementation

After each file is modified, run:

```bash
cargo check --workspace  # Quick compilation check
```

### After All Changes

Run the full CI checklist:

```bash
# Format
cargo fmt --all && cargo fmt --all --check

# Tests (warnings are errors)
RUSTFLAGS="-D warnings" cargo test --workspace

# Lint
cargo clippy --workspace -- -D warnings
```

### Specific Test Verification

```bash
# Run only the new test file
cargo test -p tuitbot-server --test fresh_install_auth

# Run core passphrase tests (includes new tests)
cargo test -p tuitbot-core passphrase

# Run existing settings tests (regression check)
cargo test -p tuitbot-server settings
```

### Manual Smoke Test (optional but recommended)

```bash
# Start server on fresh data dir
rm -rf /tmp/tuitbot-test && mkdir /tmp/tuitbot-test
cargo run -p tuitbot-server -- --config /tmp/tuitbot-test/config.toml

# Verify no passphrase is printed (localhost mode)
# Check /api/settings/status returns claimed: false
curl http://localhost:3001/api/settings/status | jq .
```

---

## Dependency Graph

```
Step 1 (AuthError variant)
    └─► Step 2 (create_passphrase_hash + is_claimed)
            └─► Step 3 (init_settings + config_status changes)
                    └─► Step 6 (integration tests)
Step 5 (conditional startup) — independent, can be done in parallel with Step 3
Step 4 (config_status) — part of Step 3
Step 7 (docs/lan-mode.md) — independent
Step 8 (backend-contract.md) — after Step 3
Step 9 (session-02-handoff.md) — last
```

**Optimal execution order:** 1 → 2 → 3+4 → 5 → 6 → 7 → 8 → 9

---

## Exit Criteria Checklist

- [ ] `create_passphrase_hash()` exists in core and never persists plaintext
- [ ] `is_claimed()` helper exists in core
- [ ] `POST /api/settings/init` with `claim.passphrase` creates hash + session cookie
- [ ] `POST /api/settings/init` with `claim` on already-claimed instance returns 409
- [ ] `POST /api/settings/init` without `claim` works identically to before
- [ ] `GET /api/settings/status` includes `claimed: bool`
- [ ] Startup passphrase generation is conditional on `--host 0.0.0.0`
- [ ] All new behavior has integration tests
- [ ] `cargo fmt --all --check` passes
- [ ] `RUSTFLAGS="-D warnings" cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] `docs/lan-mode.md` updated
- [ ] `docs/roadmap/fresh-install-auth-ux/backend-contract.md` created
- [ ] `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md` created
