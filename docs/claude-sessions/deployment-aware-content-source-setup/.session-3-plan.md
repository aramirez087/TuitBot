# Session 3 Implementation Plan -- Drive Connection Backend

## Objective

Implement the authenticated backend flow for linking, inspecting, refreshing,
and disconnecting a user-owned Google Drive connection. All secret material
(refresh tokens, connector key) must be encrypted at rest and never exposed in
API responses.

## Prerequisites Confirmed

From Session 02:
- `connections` table exists (`migrations/20260228000020_connections.sql`).
- `Connection` struct + CRUD in `storage::watchtower::connections` (no credentials).
- `ConnectorConfig` / `GoogleDriveConnectorConfig` in `config/types.rs` with
  `client_id`, `client_secret`, `redirect_uri`.
- `ContentSourceEntry.connection_id: Option<i64>` wired.
- `preferred_source_default` in `DeploymentCapabilities`.
- `oauth2` crate v4 already in `tuitbot-core/Cargo.toml` (used by `x_api/auth.rs`).
- No `aes-gcm` crate yet -- must add.
- No `connector/` directory exists under `source/`.

---

## Key Design Decisions

### KD1: AES-256-GCM for credential encryption

The charter (D5) prescribes AES-256-GCM with a per-instance random key at
`~/.tuitbot/connector_key` (0600 permissions). Add the `aes-gcm` crate to
`tuitbot-core`. The key is 32 bytes, generated once via `rand::thread_rng()`.
Each encryption produces a random 12-byte nonce prepended to the ciphertext, so
the stored BLOB is `nonce(12) || ciphertext(N) || tag(16)`.

**Rationale:** AES-256-GCM is the industry standard for authenticated
encryption. The nonce-prepend convention is simple and self-describing.
`aes-gcm` is from RustCrypto, well-audited, and has no C dependencies.

### KD2: In-memory PKCE state store

The OAuth PKCE flow requires bridging `POST /link` (generates state +
code_verifier) with `GET /callback` (receives state + code from Google). Store
pending PKCE challenges in a `Mutex<HashMap<String, PendingOAuth>>` on
`AppState`. Entries expire after 10 minutes. The HashMap is keyed by the `state`
parameter (a random CSRF token).

**Rationale:** Simpler than database storage for short-lived PKCE state. The
HashMap is process-local -- acceptable because the callback always hits the same
server instance. The 10-minute TTL prevents stale entries from accumulating.

### KD3: Callback is auth-exempt but state-validated

The `GET /api/connectors/google-drive/callback` endpoint must be accessible
without Bearer/session auth because the browser navigates to it after the Google
consent screen. Security is provided by the `state` parameter (unpredictable
random token that must match a pending link request). This mirrors how
`x_api/auth.rs` handles PKCE callbacks.

Add the callback path to `AUTH_EXEMPT_PATHS` in `middleware.rs`.

### KD4: Google Drive OAuth uses reqwest directly, not the oauth2 crate

The `oauth2` crate v4 is already in the workspace but Google Drive OAuth has
specific requirements (sending `client_secret` as form body, not Basic auth;
Google-specific token endpoint quirks). Using `reqwest` directly (as the
existing `x_api/auth.rs::TokenManager::do_refresh` does) gives full control
and avoids fighting the `oauth2` crate's BasicClient assumptions.

**Authorization URL:** Built manually with proper PKCE parameters (S256 method).
**Token exchange:** `POST https://oauth2.googleapis.com/token` with form body.
**Refresh:** Same endpoint with `grant_type=refresh_token`.
**Revocation:** `POST https://oauth2.googleapis.com/revoke` with `token` param.

### KD5: Connector trait is minimal for Session 3

Define a `RemoteConnector` trait with just enough surface for the link/callback/
status/disconnect flow. Session 04 will extend it with `get_access_token()` for
Watchtower consumption. This avoids over-engineering the trait before we know
the exact Watchtower integration needs.

### KD6: Deduplication -- one active connection per connector_type

When linking, if an active connection of the same `connector_type` already
exists, the link flow disconnects (revokes + deletes) the old one first. This
prevents orphaned connections. The API returns 409 Conflict if the caller
explicitly tries to create a duplicate without disconnecting.

---

## Files to Create

### 1. `crates/tuitbot-core/src/source/connector/mod.rs` (new, ~80 lines)

Module orchestrator. Defines:

```rust
pub mod crypto;
pub mod google_drive;
#[cfg(test)]
mod tests;

/// Error type for connector operations.
#[derive(Debug, thiserror::Error)]
pub enum ConnectorError {
    #[error("connector not configured: {0}")]
    NotConfigured(String),
    #[error("invalid OAuth state")]
    InvalidState,
    #[error("token exchange failed: {0}")]
    TokenExchange(String),
    #[error("token refresh failed: {0}")]
    TokenRefresh(String),
    #[error("revocation failed: {0}")]
    Revocation(String),
    #[error("encryption error: {0}")]
    Encryption(String),
    #[error("storage error: {source}")]
    Storage { #[from] source: crate::error::StorageError },
    #[error("network error: {0}")]
    Network(String),
}
```

And a minimal trait:

```rust
#[async_trait]
pub trait RemoteConnector: Send + Sync {
    fn connector_type(&self) -> &str;
    fn authorization_url(&self, state: &str, code_challenge: &str) -> Result<String, ConnectorError>;
    async fn exchange_code(&self, code: &str, code_verifier: &str) -> Result<TokenSet, ConnectorError>;
    async fn refresh_access_token(&self, encrypted_refresh: &[u8], key: &[u8]) -> Result<RefreshedToken, ConnectorError>;
    async fn revoke(&self, encrypted_refresh: &[u8], key: &[u8]) -> Result<(), ConnectorError>;
    async fn user_info(&self, access_token: &str) -> Result<UserInfo, ConnectorError>;
}

pub struct TokenSet {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_in_secs: i64,
    pub scope: String,
}

pub struct RefreshedToken {
    pub access_token: String,
    pub expires_in_secs: i64,
}

pub struct UserInfo {
    pub email: String,
    pub display_name: Option<String>,
}
```

### 2. `crates/tuitbot-core/src/source/connector/crypto.rs` (new, ~120 lines)

AES-256-GCM encryption/decryption:

- `ensure_connector_key(data_dir: &Path) -> Result<Vec<u8>, ConnectorError>`
  - Reads `data_dir/connector_key` if it exists.
  - Otherwise, generates 32 random bytes, writes with 0600 perms (reuse
    `x_api/auth.rs::save_tokens` pattern for safe file creation), returns.
- `encrypt_credentials(plaintext: &[u8], key: &[u8]) -> Result<Vec<u8>, ConnectorError>`
  - Generates 12-byte random nonce.
  - Encrypts with AES-256-GCM.
  - Returns `nonce || ciphertext_with_tag`.
- `decrypt_credentials(blob: &[u8], key: &[u8]) -> Result<Vec<u8>, ConnectorError>`
  - Splits blob at byte 12 (nonce | rest).
  - Decrypts and returns plaintext.

Tests:
- Round-trip encrypt/decrypt.
- Decrypt with wrong key fails.
- Corrupt ciphertext fails.
- `ensure_connector_key` creates file with 0600 perms.
- `ensure_connector_key` is idempotent.

### 3. `crates/tuitbot-core/src/source/connector/google_drive.rs` (new, ~200 lines)

Google Drive OAuth implementation:

```rust
pub struct GoogleDriveConnector {
    client_id: String,
    client_secret: String,
    redirect_uri: String,
    http_client: reqwest::Client,
}
```

Constants:
```rust
const GOOGLE_AUTH_URL: &str = "https://accounts.google.com/o/oauth2/v2/auth";
const GOOGLE_TOKEN_URL: &str = "https://oauth2.googleapis.com/token";
const GOOGLE_REVOKE_URL: &str = "https://oauth2.googleapis.com/revoke";
const GOOGLE_USERINFO_URL: &str = "https://www.googleapis.com/oauth2/v2/userinfo";
const DRIVE_SCOPE: &str = "https://www.googleapis.com/auth/drive.readonly openid email profile";
```

Methods (implement `RemoteConnector` trait):

- `authorization_url()`: Build URL with `response_type=code`, `client_id`,
  `redirect_uri`, `scope`, `state`, `code_challenge`, `code_challenge_method=S256`,
  `access_type=offline`, `prompt=consent` (forces refresh token issuance).
- `exchange_code()`: POST to token endpoint with form body
  (`grant_type=authorization_code`, `code`, `redirect_uri`, `client_id`,
  `client_secret`, `code_verifier`). Parse response into `TokenSet`.
- `refresh_access_token()`: Decrypt refresh token from blob, POST with
  `grant_type=refresh_token`. Parse into `RefreshedToken`. Do NOT log the token.
- `revoke()`: Decrypt refresh token, POST to revoke endpoint. Best-effort --
  swallow 400 (already revoked).
- `user_info()`: GET userinfo endpoint with Bearer token, extract email + name.

Constructor:
```rust
pub fn new(config: &GoogleDriveConnectorConfig) -> Result<Self, ConnectorError>
```
Returns `ConnectorError::NotConfigured` if `client_id` or `client_secret` is None.

Tests (unit, with wiremock for HTTP endpoints):
- `authorization_url` produces valid URL with all required params.
- `exchange_code` happy path (mock 200 with token response).
- `exchange_code` error (mock 400 -- invalid grant).
- `refresh_access_token` happy path.
- `refresh_access_token` with expired/revoked token (mock 401).
- `revoke` happy path.
- `revoke` already-revoked (mock 400 -- still succeeds).
- `user_info` parses email and display name.

### 4. `crates/tuitbot-core/src/source/connector/tests.rs` (new, ~60 lines)

Integration tests for crypto + connector:
- Full encrypt -> store -> retrieve -> decrypt -> refresh round trip (with mocked HTTP).

### 5. `crates/tuitbot-server/src/routes/connectors.rs` (new, ~280 lines)

Four endpoint handlers:

#### `POST /api/connectors/google-drive/link` (authenticated)

1. Read `ConnectorConfig` from disk (via `state.config_path`).
2. Construct `GoogleDriveConnector` from config. Return 400 if not configured.
3. Check for existing active `google_drive` connection. Return 409 if found
   (client must disconnect first, or pass `?force=true` to auto-disconnect).
4. Generate PKCE: `code_verifier` (43-128 chars, random), `code_challenge`
   (SHA-256 of verifier, base64url).
5. Generate `state` (32 random bytes, hex-encoded).
6. Store `PendingOAuth { code_verifier, created_at }` in `state.pending_oauth`
   keyed by `state`.
7. Build `authorization_url` via connector.
8. Return `200 { authorization_url, state }`.

#### `GET /api/connectors/google-drive/callback` (auth-exempt)

1. Extract `code` and `state` from query params. Return 400 if missing.
2. Look up and remove `PendingOAuth` from `state.pending_oauth` by `state` key.
   Return 400 ("invalid or expired state") if not found or expired (>10 min).
3. Read connector config, build `GoogleDriveConnector`.
4. Exchange code for tokens via connector.
5. Fetch user info (email, display name) using the access token.
6. Load connector key via `ensure_connector_key(&state.data_dir)`.
7. Encrypt refresh token.
8. Insert connection row (`insert_connection`).
9. Write encrypted credentials (`store_encrypted_credentials`).
10. Update `metadata_json` with `{ "scope": "...", "linked_at": "..." }`.
11. Respond with HTML success page (user can close the tab).
    Include a script that posts a message to `window.opener` if available
    (for the dashboard to detect completion).

#### `GET /api/connectors/google-drive/status` (authenticated)

1. Call `get_connections(pool)` filtered by `connector_type = "google_drive"`.
2. Return `200 { connections: [...] }` with `Connection` structs (no secrets).

#### `DELETE /api/connectors/google-drive/{id}` (authenticated)

1. Load connection by ID. Return 404 if not found.
2. Verify `connector_type == "google_drive"`. Return 400 if mismatch.
3. Load connector key. Read encrypted credentials.
4. Best-effort revoke via connector (log warning on failure, don't block).
5. Delete the connection row.
6. Return `200 { disconnected: true, id }`.

### 6. `crates/tuitbot-server/src/routes/mod.rs` (modify)

Add `pub mod connectors;` to the module list.

### 7. `crates/tuitbot-server/src/lib.rs` (modify)

Add four routes in the `build_router` function, after the Settings block:

```rust
// Connectors
.route("/connectors/google-drive/link", post(routes::connectors::link_google_drive))
.route("/connectors/google-drive/callback", get(routes::connectors::callback_google_drive))
.route("/connectors/google-drive/status", get(routes::connectors::status_google_drive))
.route("/connectors/google-drive/{id}", delete(routes::connectors::disconnect_google_drive))
```

### 8. `crates/tuitbot-server/src/auth/middleware.rs` (modify)

Add two entries to `AUTH_EXEMPT_PATHS`:
```rust
"/connectors/google-drive/callback",
"/api/connectors/google-drive/callback",
```

### 9. `crates/tuitbot-server/src/state.rs` (modify)

Add to `AppState`:
```rust
pub pending_oauth: Mutex<HashMap<String, PendingOAuth>>,
```

And define:
```rust
pub struct PendingOAuth {
    pub code_verifier: String,
    pub created_at: std::time::Instant,
}
```

### 10. `crates/tuitbot-core/src/storage/watchtower/connections.rs` (modify)

Add two credential-specific functions:

```rust
/// Store encrypted credentials for a connection (explicit opt-in).
pub async fn store_encrypted_credentials(
    pool: &DbPool,
    id: i64,
    ciphertext: &[u8],
) -> Result<(), StorageError>

/// Read encrypted credentials for a connection (explicit opt-in).
/// Returns None if the connection doesn't exist or has no credentials.
pub async fn read_encrypted_credentials(
    pool: &DbPool,
    id: i64,
) -> Result<Option<Vec<u8>>, StorageError>
```

Also add a filtered getter:

```rust
/// Get active connections filtered by connector_type.
pub async fn get_connections_by_type(
    pool: &DbPool,
    connector_type: &str,
) -> Result<Vec<Connection>, StorageError>
```

And a metadata updater:

```rust
/// Update the metadata_json of a connection.
pub async fn update_connection_metadata(
    pool: &DbPool,
    id: i64,
    metadata_json: &str,
) -> Result<(), StorageError>
```

### 11. `crates/tuitbot-core/src/source/mod.rs` (modify)

Add `pub mod connector;` to the module list.

### 12. `crates/tuitbot-core/Cargo.toml` (modify)

Add dependency:
```toml
aes-gcm = "0.10"
```

---

## Files to Create (Documentation)

### 13. `docs/roadmap/deployment-aware-content-source-setup/drive-connection-flow.md`

Document the complete OAuth flow, including:
- Sequence diagram (ASCII) of link -> consent -> callback -> store.
- Security model (PKCE, state validation, credential encryption).
- Error states and recovery (expired state, revoked token, duplicate connection).
- Endpoint reference table.

### 14. `docs/roadmap/deployment-aware-content-source-setup/session-03-handoff.md`

Standard handoff: completed work, open issues, inputs for Session 04.

---

## Files to Modify (Tests)

### 15. `crates/tuitbot-server/tests/api_tests.rs` (modify)

Add new test section for connector endpoints. Tests use the existing `test_router()`
pattern. No wiremock needed at the server test level because the connector module
is not instantiated -- the route handlers check for `ConnectorConfig` and return
400 if not configured (which is the case in tests).

Tests to add:

| Test | Description | Expected |
|------|-------------|----------|
| `connector_link_not_configured` | POST /link with no connector config | 400 + "not configured" |
| `connector_link_requires_auth` | POST /link without Bearer token | 401 |
| `connector_callback_missing_params` | GET /callback without code/state | 400 |
| `connector_callback_invalid_state` | GET /callback with unknown state | 400 + "invalid or expired" |
| `connector_status_empty` | GET /status with no connections | 200 + empty array |
| `connector_status_with_connection` | Seed a connection row, GET /status | 200 + one connection, no secrets |
| `connector_status_requires_auth` | GET /status without Bearer | 401 |
| `connector_disconnect_not_found` | DELETE /{id} with non-existent ID | 404 |
| `connector_disconnect_requires_auth` | DELETE without Bearer | 401 |
| `connector_callback_is_auth_exempt` | GET /callback returns 400 (not 401) without auth | 400 (validates params, not auth) |

Additionally, add focused unit tests in the core crate:

- `source/connector/crypto.rs` -- 5 tests (see section 2 above).
- `source/connector/google_drive.rs` -- 8 tests (see section 3 above).
- `source/connector/tests.rs` -- 1-2 integration tests.
- `storage/watchtower/connections.rs` -- 4 new tests for the new functions.

### 16. Update `AppState` construction in test helper

The `test_router()` function and all inline `AppState` constructions in
`api_tests.rs` must include the new `pending_oauth` field:
```rust
pending_oauth: Mutex::new(HashMap::new()),
```

---

## Order of Operations

### Phase 1: Core Crate (tuitbot-core)

1. **Add `aes-gcm` dependency** to `crates/tuitbot-core/Cargo.toml`.

2. **Create `source/connector/` module directory** with:
   - `mod.rs` -- ConnectorError, RemoteConnector trait, TokenSet, RefreshedToken, UserInfo.
   - `crypto.rs` -- AES-256-GCM encrypt/decrypt, connector key management.
   - `google_drive.rs` -- GoogleDriveConnector implementing RemoteConnector.
   - `tests.rs` -- integration tests.

3. **Wire module** -- add `pub mod connector;` to `source/mod.rs`.

4. **Extend `connections.rs`** -- add `store_encrypted_credentials`,
   `read_encrypted_credentials`, `get_connections_by_type`,
   `update_connection_metadata`.

5. **Run core tests** -- `cargo test -p tuitbot-core`.

### Phase 2: Server Crate (tuitbot-server)

6. **Extend `state.rs`** -- add `PendingOAuth` struct and `pending_oauth` field
   to `AppState`.

7. **Add callback to auth exemptions** -- modify `middleware.rs` AUTH_EXEMPT_PATHS.

8. **Create `routes/connectors.rs`** -- four handler functions.

9. **Wire routes** -- add `pub mod connectors;` to `routes/mod.rs`, register
   routes in `lib.rs`.

10. **Update test helpers** -- add `pending_oauth` to all `AppState` constructions
    in `api_tests.rs`.

11. **Add connector API tests** to `api_tests.rs`.

12. **Run server tests** -- `cargo test -p tuitbot-server`.

### Phase 3: Full Workspace Validation

13. `cargo fmt --all && cargo fmt --all --check`
14. `RUSTFLAGS="-D warnings" cargo test --workspace`
15. `cargo clippy --workspace -- -D warnings`

### Phase 4: Documentation

16. Write `drive-connection-flow.md`.
17. Write `session-03-handoff.md`.

---

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| `aes-gcm` crate adds compile time | It's a pure-Rust crate with minimal deps; acceptable trade-off for correct encryption |
| oauth2 crate v4 API changes | Not using oauth2 crate for Google flow -- using raw reqwest (KD4), so no version risk |
| PKCE state lost on server restart | Acceptable -- user retries the link flow. State lives 10 min max. Document this. |
| Google Drive connector tests need network | All HTTP calls in tests use wiremock (localhost mock server) |
| Callback endpoint open to abuse | Rate-limited by state validation (must match a pending link). Invalid states rejected immediately. State consumed on use (one-shot). 10-min expiry cleans up abandoned flows. |
| File size limits | `connectors.rs` route file may approach 280 lines. Monitor; if it exceeds 300, split link/callback into a submodule. `google_drive.rs` connector at ~200 lines is within limits. |
| `AppState` field addition breaks all test constructors | Accept the churn -- it's a one-field addition. Grep for `AppState {` in tests and update all. |

---

## Dependency Graph

```
aes-gcm (new)
    |
    v
crypto.rs  <--  google_drive.rs (connector)
                      |
                      v
              connections.rs (CRUD extensions)
                      |
                      v
              connectors.rs (routes)  <--  state.rs (PendingOAuth)
                      |                        |
                      v                        v
                  lib.rs (route wiring)   middleware.rs (auth exempt)
                      |
                      v
                 api_tests.rs
```

---

## Verification Checklist

- [ ] `cargo fmt --all && cargo fmt --all --check` passes
- [ ] `RUSTFLAGS="-D warnings" cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] No secrets in API responses (Connection struct omits encrypted_credentials)
- [ ] No secrets in log output (tracing calls redact tokens)
- [ ] Connector key file has 0600 permissions on Unix
- [ ] Callback endpoint is auth-exempt but state-validated
- [ ] Link endpoint requires authentication
- [ ] Status endpoint requires authentication
- [ ] Disconnect endpoint requires authentication
- [ ] Crypto round-trip tests pass
- [ ] Wiremock-based connector tests cover happy + error paths
- [ ] drive-connection-flow.md documents the full flow
- [ ] session-03-handoff.md states completed work and Session 04 inputs
