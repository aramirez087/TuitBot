# Session 04 Implementation Plan: Watchtower Provider Refactor

## Objective

Refactor the Google Drive provider to use linked-account OAuth credentials
from Session 03's connector infrastructure, replacing the service-account
JWT path as the default auth strategy. Ensure Watchtower polling is resilient
across token refresh, revocation, restart, and connection-not-found scenarios.

---

## Current State Analysis

### What exists today

1. **`GoogleDriveProvider`** (`source/google_drive.rs`): Uses a service-account
   JSON key file path (`service_account_key_path`) to build a JWT and exchange
   it for a short-lived access token. Caches tokens in `Mutex<Option<CachedToken>>`.
   ~680 lines including RSA and DER parsing (the JWT signing helpers are substantial).

2. **`ContentSourceEntry`** (`config/types.rs`): Already has `connection_id: Option<i64>`
   field, annotated as "When set, the Watchtower uses the linked account's
   credentials instead of `service_account_key`."

3. **Watchtower `run()` loop** (`automation/watchtower/mod.rs` lines 366-400):
   Filters for `source_type == "google_drive" && folder_id.is_some()`, reads
   `service_account_key` from config, and constructs `GoogleDriveProvider::new(folder_id, key_path)`.
   Remote sources are `(source_id, Box<dyn ContentSourceProvider>, patterns, Duration)`.

4. **Session 03 infrastructure**:
   - `RemoteConnector` trait with `refresh_access_token(encrypted_refresh, key)`
   - `GoogleDriveConnector` implementation (OAuth flows, not Drive API)
   - `connections` table with `encrypted_credentials` BLOB column
   - `read_encrypted_credentials()` and `store_encrypted_credentials()`
   - `ensure_connector_key()` for AES-256-GCM key management

### The gap

The `GoogleDriveProvider` (L1 toolkit / source layer) cannot currently obtain
an access token from the `connections` table. It only knows how to sign a
service-account JWT. There is no bridge between the **connector** (OAuth
lifecycle) and the **provider** (Drive API polling).

---

## Design Decisions

### KD1: Dual-auth strategy with enum dispatch

Add a `DriveAuthStrategy` enum to `GoogleDriveProvider`:

```rust
enum DriveAuthStrategy {
    /// Legacy: service-account JSON key file.
    ServiceAccount { key_path: String },
    /// New: linked-account credentials from connections table.
    LinkedAccount {
        connection_id: i64,
        pool: DbPool,
        connector_key: Vec<u8>,
        connector: GoogleDriveConnector,
    },
}
```

**Rationale**: This avoids a breaking change for existing `service_account_key`
users (hard constraint: "do not silently break existing configs"). The provider
dispatches `get_access_token()` based on which variant is active. The legacy
path is frozen -- no new code paths added to it. New installs and connection-
based configs use `LinkedAccount`.

### KD2: Token caching lives in the provider, not the connector

The `GoogleDriveConnector` (session 03) is stateless -- it takes encrypted
bytes and returns a `RefreshedToken`. The `GoogleDriveProvider` owns the
in-memory cache (`CachedToken`) with `Instant`-based expiry tracking. This
keeps the connector reusable and the provider responsible for its own I/O
cadence.

### KD3: SourceError gains a `ConnectionBroken` variant

When a refresh fails with a revocation or irrecoverable error, the provider
returns `SourceError::ConnectionBroken { connection_id, reason }`. The
Watchtower catches this and:
- Sets the source_context status to `"error"` with the reason.
- Sets the connection status to `"expired"` or `"revoked"`.
- Logs a warning and skips this source for the remainder of the poll cycle.
- Does NOT crash the loop or affect other sources.

### KD4: Watchtower source registration supports connection_id

The Watchtower's remote source registration loop gains a new branch:
if `connection_id` is set, it builds a `LinkedAccount`-backed provider
(loading the connector key and connector config from state). If neither
`service_account_key` nor `connection_id` is set, it logs a warning and
skips the source.

### KD5: Watchtower gets a pool reference for credential loading

Currently `WatchtowerLoop` holds `pool: DbPool` and `config: ContentSourcesConfig`.
The `LinkedAccount` strategy needs the `DbPool` to read encrypted credentials
at refresh time. Since the pool is already on `WatchtowerLoop`, we pass a
clone into each `GoogleDriveProvider` that uses linked-account auth.

### KD6: ConnectorConfig made available to Watchtower

The `WatchtowerLoop::new()` signature gains a `connector_config: ConnectorConfig`
parameter (or the full config is threaded through) so it can construct
`GoogleDriveConnector` instances for linked-account providers. This is a
small API change but necessary -- the Watchtower needs the OAuth app
credentials (client_id, client_secret) to refresh access tokens.

### KD7: No new storage functions needed for source_contexts

The `ensure_google_drive_source()` function matches by `folder_id` in
`config_json`. For connection-based sources, we include both `folder_id`
and `connection_id` in the config_json. The existing function works
unchanged -- it still deduplicates by folder_id. The `connection_id`
is metadata inside the JSON, not a new column.

---

## Files to Modify

### 1. `crates/tuitbot-core/src/source/mod.rs`
- Add `ConnectionBroken { connection_id: i64, reason: String }` variant to `SourceError`.

### 2. `crates/tuitbot-core/src/source/google_drive.rs` (major refactor)
- Add `DriveAuthStrategy` enum.
- Add `GoogleDriveProvider::from_connection()` constructor.
- Refactor `get_access_token()` to dispatch on auth strategy.
- Add `refresh_from_connection()` method (calls connector's `refresh_access_token`).
- Keep `fetch_new_token()` (legacy service-account path) unchanged but gate behind `ServiceAccount` variant.
- The `scan_for_changes()` and `read_content()` implementations stay identical -- they just call `get_access_token()`.
- Add test-only constructor `with_client_and_strategy()` for wiremock integration.

### 3. `crates/tuitbot-core/src/automation/watchtower/mod.rs`
- Update `WatchtowerLoop::new()` to accept `ConnectorConfig`.
- In the remote source registration block (lines 367-400), add a branch for `connection_id.is_some()`:
  - Load connector key via `ensure_connector_key(data_dir)`.
  - Construct `GoogleDriveConnector` from `ConnectorConfig.google_drive`.
  - Build `GoogleDriveProvider::from_connection(folder_id, connection_id, pool, key, connector)`.
- In `poll_remote_sources()`, catch `SourceError::ConnectionBroken` and:
  - Update `source_contexts.status` to `"error"`.
  - Update `connections.status` to match the failure reason.
  - Skip the source (continue loop).
- Extract `WatchtowerLoop` field additions: `connector_config`, `data_dir`.

### 4. `crates/tuitbot-server/src/main.rs`
- Extract `ConnectorConfig` from loaded config.
- Pass it to `WatchtowerLoop::new()`.
- Pass `data_dir` to `WatchtowerLoop::new()` (needed for `ensure_connector_key`).

### 5. `crates/tuitbot-core/src/source/tests/unit.rs`
- Add tests for `GoogleDriveProvider::from_connection()` construction.
- Test `get_access_token()` with linked-account strategy (wiremock token endpoint).
- Test cache hit / cache miss / cache expired flows.

### 6. `crates/tuitbot-core/src/source/tests/integration.rs`
- Add E2E test: connection-based Drive ingest through full pipeline.
- Add test: revoked connection produces ConnectionBroken, source degrades gracefully.
- Add test: restart recovery (provider rebuilds from persisted connection, cursor resumes).

### 7. `crates/tuitbot-core/src/automation/watchtower/tests.rs`
- Add test: Watchtower registers connection-based source correctly.
- Add test: Watchtower handles ConnectionBroken by marking source as error.
- Add test: Watchtower skips source with missing connection gracefully.
- Add test: Watchtower config with both legacy and connection-based sources.

### 8. `crates/tuitbot-server/src/state.rs`
- Add `connector_config: ConnectorConfig` to `AppState` (needed by routes and watchtower).

### 9. `crates/tuitbot-server/src/routes/connectors.rs` (minor)
- Reference `AppState.connector_config` instead of loading config from disk.
  (Currently the connector routes load config via `Config::load()` on each request;
  moving to AppState is cleaner and consistent.)

## Files to Create

### 10. `docs/roadmap/deployment-aware-content-source-setup/watchtower-sync-contract.md`
- Document the sync contract: how Watchtower builds providers from config entries,
  how connection-based auth works, token lifecycle, failure modes, cursor stability.

### 11. `docs/roadmap/deployment-aware-content-source-setup/session-04-handoff.md`
- Summary of completed work, design decisions, open issues, inputs for Session 05.

---

## Order of Operations

### Phase 1: SourceError + DriveAuthStrategy (provider layer)

**Step 1.1**: Add `ConnectionBroken` variant to `SourceError` in `source/mod.rs`.

**Step 1.2**: Add `DriveAuthStrategy` enum to `google_drive.rs`.

**Step 1.3**: Add `GoogleDriveProvider::from_connection()` constructor that takes
`folder_id`, `connection_id`, `pool`, `connector_key`, and `GoogleDriveConnector`.

**Step 1.4**: Refactor `get_access_token()` to dispatch:
- `ServiceAccount` -> existing `fetch_new_token()` (JWT path)
- `LinkedAccount` -> new `refresh_from_connection()` method

**Step 1.5**: Implement `refresh_from_connection()`:
1. Check in-memory cache -- return if valid (>60s remaining).
2. `read_encrypted_credentials(pool, connection_id)` -- if None, return `ConnectionBroken`.
3. Call `connector.refresh_access_token(encrypted, key)`.
4. On success: cache the new token, return it.
5. On `ConnectorError::TokenRefresh` with "revoked" in message: return
   `SourceError::ConnectionBroken`.
6. On other `ConnectorError`: return `SourceError::Auth`.

**Step 1.6**: Add `#[cfg(test)]` constructors for wiremock-based testing.

**Checkpoint**: `cargo check -p tuitbot-core` passes.

### Phase 2: Watchtower integration

**Step 2.1**: Extend `WatchtowerLoop` struct with `connector_config: ConnectorConfig`
and `data_dir: PathBuf` fields. Update `WatchtowerLoop::new()` signature.

**Step 2.2**: In the remote source registration block (`run()` method), add the
connection_id branch:
```
if connection_id is set:
    ensure_connector_key(data_dir)
    GoogleDriveConnector::new(connector_config.google_drive)
    GoogleDriveProvider::from_connection(...)
else if service_account_key is set:
    GoogleDriveProvider::new(folder_id, key_path)  -- legacy
else:
    warn and skip
```

**Step 2.3**: In `poll_remote_sources()`, add match arm for `ConnectionBroken`:
```
Err(SourceError::ConnectionBroken { connection_id, reason }) => {
    update_source_status(pool, source_id, "error", Some(&reason))
    update_connection_status(pool, connection_id, "expired")
    tracing::warn!(...)
}
```

**Checkpoint**: `cargo check -p tuitbot-core` passes.

### Phase 3: Server wiring

**Step 3.1**: Add `connector_config: ConnectorConfig` to `AppState`.

**Step 3.2**: Extract `ConnectorConfig` from loaded config in `main.rs`.
Pass it to `WatchtowerLoop::new()` along with `data_dir`.

**Step 3.3**: Update all `AppState` construction sites (main.rs + test helpers)
to include the new field.

**Step 3.4**: Update connector routes to use `state.connector_config` instead
of loading from disk.

**Checkpoint**: `cargo check --workspace` passes.

### Phase 4: Tests

**Step 4.1**: Provider unit tests in `source/tests/unit.rs`:
- `google_drive_provider_from_connection_gets_token` -- happy path with wiremock
  token endpoint returning valid access token.
- `google_drive_provider_connection_cache_hit` -- second call returns cached token.
- `google_drive_provider_connection_expired_refreshes` -- expired cache triggers refresh.
- `google_drive_provider_connection_revoked_returns_broken` -- 401 from token
  endpoint returns `ConnectionBroken`.
- `google_drive_provider_connection_missing_credentials_returns_broken` -- no
  encrypted creds in DB returns `ConnectionBroken`.

**Step 4.2**: Provider integration tests in `source/tests/integration.rs`:
- `e2e_connection_based_drive_ingest` -- connection + encrypted creds in DB,
  mock token endpoint, ingest content, verify nodes created.
- `e2e_connection_revoked_degrades_gracefully` -- mock returns 401, verify
  source status set to error, nodes from previous polls preserved.

**Step 4.3**: Watchtower tests in `watchtower/tests.rs`:
- `watchtower_registers_connection_based_source` -- config with connection_id
  is accepted, source_context created.
- `watchtower_skips_source_without_auth` -- config with neither service_account_key
  nor connection_id is skipped with warning.
- `watchtower_handles_broken_connection` -- mock provider returns ConnectionBroken,
  verify source marked as error.
- `watchtower_preserves_cursor_across_restart` -- write cursor, rebuild provider,
  verify cursor is passed to `scan_for_changes`.
- `watchtower_mixed_legacy_and_connection_sources` -- both auth strategies coexist.

**Checkpoint**: `cargo test -p tuitbot-core` passes.

### Phase 5: Full CI + Documentation

**Step 5.1**: Run full CI checklist:
```
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

**Step 5.2**: Write `watchtower-sync-contract.md`:
- Provider construction: config entry -> auth strategy resolution
- Token lifecycle: cache -> refresh -> ConnectionBroken
- Cursor stability: RFC 3339 timestamps, per-source, survive restarts
- Failure modes: table of error -> state transition -> user impact
- Migration: legacy service_account_key preserved, connection_id preferred

**Step 5.3**: Write `session-04-handoff.md`:
- Completed work
- Design decisions (KD1-KD7)
- Open issues
- Inputs for Session 05 (UI endpoints needed, connection status API)

---

## Risks and Mitigations

### R1: File size limit on `google_drive.rs`

**Risk**: The file is already ~680 lines. Adding `DriveAuthStrategy`,
`from_connection()`, and `refresh_from_connection()` could push it past
the 500-line limit.

**Mitigation**: Extract the legacy service-account JWT code (lines 298-683:
`build_jwt`, `rsa_sign_sha256`, `pem_to_der`, `BigUint`, DER parsing) into
a `google_drive/jwt.rs` submodule. Convert `google_drive.rs` into a module
directory `google_drive/mod.rs`. The JWT code is self-contained and only
used by the `ServiceAccount` path. This also makes it easy to deprecate
later.

Structure after refactor:
```
source/
  google_drive/
    mod.rs          -- GoogleDriveProvider, DriveAuthStrategy, ContentSourceProvider impl
    jwt.rs          -- build_jwt, rsa_sign_sha256, BigUint, DER parsing (legacy)
```

### R2: Test isolation for linked-account tests

**Risk**: Tests for `refresh_from_connection()` need a real SQLite pool
(for `read_encrypted_credentials`) AND a wiremock server (for the token
endpoint). Cross-cutting mocks are complex.

**Mitigation**: Use `init_test_db()` for the pool. Seed encrypted credentials
via `store_encrypted_credentials()`. Use wiremock for the HTTP endpoint.
The `GoogleDriveConnector::with_test_urls()` constructor already supports
this. Build the `GoogleDriveProvider` with a test-specific connector that
points at wiremock.

### R3: Thread-local URL overrides and parallel tests

**Risk**: The `thread_local! TEST_URLS` pattern in `GoogleDriveConnector`
can leak between tests in the same thread.

**Mitigation**: Each test sets its own thread-local URLs before creating
the connector. Since `#[tokio::test]` runs each test on its own task
(typically same thread for single-threaded runtime), this is safe. Use
`-- --test-threads=1` in CI for connector tests if needed (already the
pattern for env-var tests per CLAUDE.md).

### R4: `WatchtowerLoop::new()` signature change

**Risk**: Changing `new()` to accept `ConnectorConfig` and `data_dir`
breaks call sites in main.rs and tests.

**Mitigation**: Update all call sites in the same step. There are exactly
three: `main.rs`, `watchtower/tests.rs` `watcher_cancels_with_sources`,
and `watcher_respects_cancellation`. Test call sites can pass
`ConnectorConfig::default()` and a temp dir.

### R5: Missing GoogleDriveConnector config at Watchtower startup

**Risk**: If `connector_config.google_drive.client_id` is None, constructing
`GoogleDriveConnector::new()` returns `ConnectorError::NotConfigured`. A
connection-based source cannot be built.

**Mitigation**: In the Watchtower registration, if `GoogleDriveConnector::new()`
returns `NotConfigured`, log a warning and skip the source. The connection
exists in the DB but cannot be used without app credentials. This is a config
error, not a crash.

---

## Verification Steps

1. **After Phase 1**: `cargo check -p tuitbot-core` -- provider compiles.
2. **After Phase 2**: `cargo check -p tuitbot-core` -- watchtower compiles.
3. **After Phase 3**: `cargo check --workspace` -- server compiles.
4. **After Phase 4**: `cargo test --workspace` -- all tests pass.
5. **After Phase 5**: Full CI checklist passes:
   ```
   cargo fmt --all && cargo fmt --all --check
   RUSTFLAGS="-D warnings" cargo test --workspace
   cargo clippy --workspace -- -D warnings
   ```

---

## Estimated Test Count

| Location | New Tests | Description |
|----------|-----------|-------------|
| `source/tests/unit.rs` | 5 | Provider construction, cache, refresh, revoke, missing creds |
| `source/tests/integration.rs` | 2 | E2E connection ingest, E2E revocation degradation |
| `watchtower/tests.rs` | 5 | Registration, skip, broken connection, cursor restart, mixed |
| **Total** | **12** | |

---

## Dependency Changes

None. All needed crates (`aes-gcm`, `reqwest`, `wiremock`, `async_trait`,
`sha2`, `chrono`, `serde_json`, `sqlx`) are already in `tuitbot-core/Cargo.toml`.

---

## Migration Notes

- Existing `service_account_key` configs continue to work unchanged (legacy path).
- New `connection_id` configs are preferred when present.
- If both `service_account_key` and `connection_id` are set on the same entry,
  `connection_id` wins (documented in watchtower-sync-contract.md).
- The `connection_id` field was added to `ContentSourceEntry` in Session 02.
- No database migrations needed -- `connections` table and `source_contexts`
  table already have the required schema.

---

## Non-Goals for This Session

- Frontend UI changes (Session 05).
- Auto-disconnect/reconnect from the dashboard (Session 05).
- Drive folder picker or folder_id discovery API (Session 05).
- OneDrive or Dropbox connector stubs (future epic).
- Removing the legacy service-account path (future -- after migration period).
