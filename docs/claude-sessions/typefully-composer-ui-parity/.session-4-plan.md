# Session 04 Implementation Plan — Reorder, Media, Power Actions

**Date:** 2026-02-27
**Session:** 04 — Reorder & Media Placement
**Status:** Plan
**Inputs:** Session 03 handoff, charter (A-2, A-3), session execution map (Session 04)

---

## Objective

Deliver best-in-class structural control and media choreography that outperforms Typefully's thread editor. After this session, users can reorder tweet cards (drag + keyboard), perform power actions (duplicate/split/merge), and attach media per tweet card with inline validation.

---

## Current State Assessment

### ThreadComposer.svelte (351 lines)
- Card-based editor with per-card textarea, char counter, add/remove
- `.drag-handle-placeholder` exists with `GripVertical` icon (visual only, opacity 0.4, cursor: default)
- `block.order` fields wired; `sortedBlocks` derived sorts by order
- `emitChange()` notifies parent on every mutation
- `focusedBlockId` tracks which card has focus
- No DnD, no keyboard reorder, no power actions, no media slot

### ComposeModal.svelte (922 lines)
- Media attachment is modal-level only (tweet mode gated: line 444)
- `AttachedMedia` interface with `path`, `file`, `previewUrl`, `mediaType`
- Upload via `api.media.upload(file)` returning `{ path, media_type, size }`
- GIF/video exclusivity rule: 1 GIF/video OR up to 4 images
- Thread mode has NO media attachment UI — `canAttachMore` section hidden when `mode !== 'tweet'`
- `handleSubmit` builds `ComposeRequest` with `blocks` and `media_paths` (top-level)

### TweetPreview.svelte (171 lines)
- Already renders `mediaPaths` prop with 1/2/3/4 grid layout
- Uses `api.media.fileUrl(path)` for image URLs

### API Contract
- `ThreadBlock.media_paths: string[]` exists in both TS and Rust types
- Server validates max 4 media per block (`MAX_MEDIA_PER_BLOCK = 4`)
- Server validates GIF/video exclusivity is NOT per-block (only per-tweet modal-level)
- `ComposeRequest` sends both `blocks` (structured) and `media_paths` (top-level, legacy)
- `compose_thread_blocks_flow` flattens per-block media into top-level for approval queue

---

## Files to Create

| File | Purpose | Est. Lines |
|------|---------|-----------|
| `dashboard/src/lib/components/MediaSlot.svelte` | Per-tweet media attachment zone with upload, thumbnails, remove, drag-drop file receive | ~180 |

## Files to Modify

| File | Changes | Est. Lines Delta |
|------|---------|-----------------|
| `dashboard/src/lib/components/ThreadComposer.svelte` | +DnD reorder, +keyboard reorder, +power actions (duplicate/split/merge), +MediaSlot integration, +toolbar per card | +200 → ~550 total |
| `dashboard/src/lib/components/ComposeModal.svelte` | Wire per-block media upload in thread mode, remove thread-mode media gate, adapt `handleSubmit` to read per-block media | +30 → ~950 total |

## Files Unchanged

| File | Reason |
|------|--------|
| `dashboard/src/lib/components/TweetPreview.svelte` | Already supports `mediaPaths` rendering. No changes needed. |
| `dashboard/src/lib/api.ts` | `ThreadBlock.media_paths` already in the type. `ComposeRequest.blocks` already typed. |
| `crates/tuitbot-server/src/routes/content/compose.rs` | Per-block media already validated in `compose_thread_blocks_flow`. |
| Rust crates | No Rust changes expected this session — all changes are frontend. |

---

## Design Decisions

### D4-1: HTML5 Native Drag-and-Drop (not a library)

**Decision:** Use the browser's native HTML5 DnD API (`draggable`, `ondragstart`, `ondragover`, `ondrop`) on the grip handle element.

**Rationale:**
- Zero dependencies — no `svelte-dnd-action` or `@dnd-kit`
- Adequate for vertical list reorder within a single container
- ThreadComposer already has the visual handle (GripVertical icon)
- Tauri WebView supports HTML5 DnD fully
- Touch reorder (mobile) is out of scope for Session 04; Session 06 addresses touch targets

**Implementation:**
- Grip handle gets `draggable="true"`, `ondragstart`, `ondragend`
- Each `.tweet-card` gets `ondragover`, `ondrop`, `ondragenter`, `ondragleave`
- Visual feedback: dragging card gets `.dragging` class (opacity 0.5), drop target gets `.drop-target` class (blue border)
- State: `draggingBlockId: string | null` tracked in component state
- On drop: compute new order based on drop position, reassign `order` fields contiguously 0..N, emit change

### D4-2: Keyboard Reorder via Alt+ArrowUp/Alt+ArrowDown

**Decision:** When a textarea within a tweet card is focused, Alt+ArrowUp moves the card up, Alt+ArrowDown moves the card down. Focus follows the moved card.

**Rationale:**
- Alt+Arrow avoids conflict with browser text selection (Shift+Arrow), cursor movement (Arrow), and word-jump (Cmd/Ctrl+Arrow)
- Matches accessibility best practices for reorderable lists
- Works identically on Mac and Windows (Alt is Option on Mac)

**Implementation:**
- `onkeydown` handler on each card's `<textarea>`
- When `e.altKey && e.key === 'ArrowUp'`: swap with previous block (if exists), prevent default
- When `e.altKey && e.key === 'ArrowDown'`: swap with next block (if exists), prevent default
- After swap: reassign `order` fields, focus the moved card's textarea via `requestAnimationFrame` to wait for DOM update
- Use `aria-live="polite"` announcement: "Tweet moved to position N"

### D4-3: Power Actions Triggered from Card Toolbar

**Decision:** Each card gets a small toolbar (visible on hover/focus) with Duplicate, Split, and Merge buttons. Also accessible via keyboard shortcuts.

**Rationale:**
- Discoverable — buttons visible when working on a card
- Keyboard shortcuts as secondary access (Cmd+D, Cmd+Shift+S, Cmd+Shift+M per execution map)
- Toolbar positioned in card footer alongside char counter and remove button

**Duplicate:**
- Creates new block with `crypto.randomUUID()`, copies `text` and `media_paths` from source
- Inserts immediately after current card (increments order of all subsequent cards)
- Focus moves to the new card's textarea

**Split:**
- Reads `selectionStart` from the focused textarea
- If no cursor position or cursor at start/end, splits at midpoint of text (by word boundary)
- Creates two blocks: text before cursor → current block, text after cursor → new block
- Current block keeps its media; new block gets empty media_paths
- Both blocks get fresh contiguous order values
- Focus moves to the second (new) block

**Merge:**
- Combines current block's text with the NEXT block's text (joined by `\n`)
- Media from both blocks are combined (subject to max 4 validation)
- If combined media > 4: show inline error, abort merge
- Removes the next block; recomputes order
- Focus stays on merged card; cursor at the join point

### D4-4: MediaSlot as Self-Contained Component

**Decision:** Create `MediaSlot.svelte` as a reusable per-card media widget. ThreadComposer integrates one per card. Upload mechanics (API call, validation) are owned by MediaSlot. Parent only receives path callbacks.

**Rationale:**
- Isolates media complexity from ThreadComposer (keeping line count manageable)
- Reusable for future tweet-mode inline media
- Mirrors existing ComposeModal upload pattern but scoped to a single card

**Props:**
```typescript
{
  mediaPaths: string[];             // Current media for this block
  onmediachange: (paths: string[]) => void;  // Callback when media changes
  maxMedia?: number;                // Default 4
  disabled?: boolean;               // During upload or submitting
}
```

**Internal State:**
- `uploading: boolean`
- `error: string | null`
- `previews: { path: string; url: string; type: string }[]` built from mediaPaths

**Features:**
- "Attach" button opens file picker (same ACCEPTED_TYPES as ComposeModal)
- Drag-and-drop zone: files dropped onto the slot trigger upload
- Thumbnail grid (same layout as ComposeModal's `.media-preview-grid`)
- Remove button per thumbnail
- Size and type validation inline (error message below slot)
- GIF/video exclusivity enforced within the slot

### D4-5: Per-Block Media in Submit Payload

**Decision:** On thread submit, `ComposeRequest.blocks[i].media_paths` carries the per-block paths. The top-level `media_paths` field is set to the flattened union (for legacy compatibility).

**Rationale:**
- Server's `compose_thread_blocks_flow` already reads `block.media_paths` for validation
- Server flattens to `all_media` for approval queue `media_json` column
- Legacy `media_paths` keeps backward compat with approval display that reads top-level

**Implementation (ComposeModal.handleSubmit):**
```
threadBlocks already carry media_paths from ThreadComposer's onchange.
data.blocks = validBlocks (which include media_paths per block)
data.media_paths = validBlocks.flatMap(b => b.media_paths)
```

### D4-6: Order Normalization on Every Mutation

**Decision:** After every structural operation (add, remove, reorder, duplicate, split, merge), order fields are reassigned as a contiguous 0..N sequence matching the current visual sort.

**Rationale:**
- Server validation (`validate_thread_blocks`) requires contiguous order starting at 0
- Prevents gaps or duplicates that would cause API rejection
- Simple implementation: `blocks.sort((a,b) => a.order - b.order).map((b, i) => ({...b, order: i}))`

---

## Implementation Order

### Step 1: Reorder (DnD + Keyboard) in ThreadComposer

**Target file:** `dashboard/src/lib/components/ThreadComposer.svelte`

1. **Add DnD state variables:**
   ```typescript
   let draggingBlockId = $state<string | null>(null);
   let dropTargetBlockId = $state<string | null>(null);
   ```

2. **Convert `.drag-handle-placeholder` to functional drag handle:**
   - Add `draggable="true"` attribute
   - Rename class from `.drag-handle-placeholder` to `.drag-handle`
   - Change `cursor: default` → `cursor: grab` (and `cursor: grabbing` during drag)
   - Set `opacity: 1` (was 0.4)
   - Update title from "coming soon" to "Drag to reorder"

3. **Wire DnD event handlers on handle:**
   ```
   ondragstart: set draggingBlockId, set dataTransfer data
   ondragend: clear draggingBlockId and dropTargetBlockId
   ```

4. **Wire DnD event handlers on each `.tweet-card`:**
   ```
   ondragover: preventDefault (enable drop), set dropTargetBlockId
   ondragenter: set dropTargetBlockId
   ondragleave: clear dropTargetBlockId (only if leaving the card)
   ondrop: compute new position, reorder blocks, clear drag state
   ```

5. **Implement reorder logic (`moveBlock` function):**
   ```typescript
   function moveBlock(blockId: string, newIndex: number) {
     const sorted = [...blocks].sort((a, b) => a.order - b.order);
     const currentIndex = sorted.findIndex(b => b.id === blockId);
     if (currentIndex === -1 || currentIndex === newIndex) return;
     const [moved] = sorted.splice(currentIndex, 1);
     sorted.splice(newIndex, 0, moved);
     blocks = sorted.map((b, i) => ({ ...b, order: i }));
     emitChange();
   }
   ```

6. **Add CSS for DnD visual feedback:**
   ```css
   .tweet-card.dragging { opacity: 0.5; }
   .tweet-card.drop-target { border-color: var(--color-accent); border-style: dashed; }
   .drag-handle { cursor: grab; opacity: 0.6; }
   .drag-handle:hover { opacity: 1; }
   .drag-handle:active { cursor: grabbing; }
   ```

7. **Wire keyboard reorder on each `<textarea>`:**
   ```typescript
   function handleCardKeydown(e: KeyboardEvent, blockId: string) {
     if (e.altKey && e.key === 'ArrowUp') {
       e.preventDefault();
       const sorted = [...blocks].sort((a, b) => a.order - b.order);
       const idx = sorted.findIndex(b => b.id === blockId);
       if (idx > 0) {
         moveBlock(blockId, idx - 1);
         focusBlock(blockId);
       }
     }
     if (e.altKey && e.key === 'ArrowDown') {
       e.preventDefault();
       const sorted = [...blocks].sort((a, b) => a.order - b.order);
       const idx = sorted.findIndex(b => b.id === blockId);
       if (idx < sorted.length - 1) {
         moveBlock(blockId, idx + 1);
         focusBlock(blockId);
       }
     }
   }
   ```

8. **Implement `focusBlock` helper:**
   ```typescript
   function focusBlock(blockId: string) {
     requestAnimationFrame(() => {
       const textarea = document.querySelector(
         `[data-block-id="${blockId}"] textarea`
       ) as HTMLTextAreaElement | null;
       textarea?.focus();
     });
   }
   ```
   - Also add `data-block-id={block.id}` attribute on each `.tweet-card`

9. **Add ARIA live region for reorder announcements:**
   ```svelte
   <div class="sr-only" role="status" aria-live="polite" aria-atomic="true">
     {reorderAnnouncement}
   </div>
   ```
   With a `reorderAnnouncement` state variable set to "Tweet moved to position N" on reorder, cleared after 1 second.

### Step 2: Power Actions in ThreadComposer

**Target file:** `dashboard/src/lib/components/ThreadComposer.svelte`

1. **Add lucide-svelte imports for toolbar icons:**
   ```typescript
   import { Plus, Trash2, GripVertical, Copy, Scissors, Merge } from 'lucide-svelte';
   ```

2. **Implement `duplicateBlock(id: string)`:**
   ```typescript
   function duplicateBlock(id: string) {
     const sorted = [...blocks].sort((a, b) => a.order - b.order);
     const idx = sorted.findIndex(b => b.id === id);
     if (idx === -1) return;
     const source = sorted[idx];
     const newBlock: ThreadBlock = {
       id: crypto.randomUUID(),
       text: source.text,
       media_paths: [...source.media_paths],
       order: 0 // will be reassigned
     };
     sorted.splice(idx + 1, 0, newBlock);
     blocks = sorted.map((b, i) => ({ ...b, order: i }));
     emitChange();
     focusBlock(newBlock.id);
   }
   ```

3. **Implement `splitBlock(id: string)`:**
   ```typescript
   function splitBlock(id: string) {
     const sorted = [...blocks].sort((a, b) => a.order - b.order);
     const idx = sorted.findIndex(b => b.id === id);
     if (idx === -1) return;
     const source = sorted[idx];

     // Get cursor position from textarea
     const textarea = document.querySelector(
       `[data-block-id="${id}"] textarea`
     ) as HTMLTextAreaElement | null;
     let splitPos = textarea?.selectionStart ?? Math.floor(source.text.length / 2);

     // Snap to nearest word boundary if mid-word
     if (splitPos > 0 && splitPos < source.text.length) {
       const before = source.text.slice(0, splitPos);
       const lastSpace = before.lastIndexOf(' ');
       const nextSpace = source.text.indexOf(' ', splitPos);
       if (lastSpace > splitPos - 10) splitPos = lastSpace + 1;
       else if (nextSpace !== -1 && nextSpace < splitPos + 10) splitPos = nextSpace + 1;
     }

     // Guard: don't split if either side would be empty
     const textBefore = source.text.slice(0, splitPos).trim();
     const textAfter = source.text.slice(splitPos).trim();
     if (!textBefore || !textAfter) return;

     const newBlock: ThreadBlock = {
       id: crypto.randomUUID(),
       text: textAfter,
       media_paths: [],
       order: 0
     };

     sorted[idx] = { ...source, text: textBefore };
     sorted.splice(idx + 1, 0, newBlock);
     blocks = sorted.map((b, i) => ({ ...b, order: i }));
     emitChange();
     focusBlock(newBlock.id);
   }
   ```

4. **Implement `mergeWithNext(id: string)`:**
   ```typescript
   function mergeWithNext(id: string) {
     const sorted = [...blocks].sort((a, b) => a.order - b.order);
     const idx = sorted.findIndex(b => b.id === id);
     if (idx === -1 || idx >= sorted.length - 1) return;
     if (sorted.length <= 2) return; // Must keep at least 2 blocks

     const current = sorted[idx];
     const next = sorted[idx + 1];

     // Check combined media count
     const combinedMedia = [...current.media_paths, ...next.media_paths];
     if (combinedMedia.length > 4) {
       // Set inline error (handled via validation or temporary error state)
       return;
     }

     const joinPoint = current.text.length;
     const mergedText = current.text + (current.text.endsWith('\n') ? '' : '\n') + next.text;

     sorted[idx] = { ...current, text: mergedText, media_paths: combinedMedia };
     sorted.splice(idx + 1, 1);
     blocks = sorted.map((b, i) => ({ ...b, order: i }));
     emitChange();

     // Focus merged card and place cursor at join point
     requestAnimationFrame(() => {
       const textarea = document.querySelector(
         `[data-block-id="${current.id}"] textarea`
       ) as HTMLTextAreaElement | null;
       if (textarea) {
         textarea.focus();
         textarea.setSelectionRange(joinPoint + 1, joinPoint + 1);
       }
     });
   }
   ```

5. **Add card toolbar to template (inside `.card-footer`):**
   ```svelte
   <div class="card-actions">
     <button
       class="action-btn"
       onclick={() => duplicateBlock(block.id)}
       title="Duplicate (Cmd+D)"
       aria-label="Duplicate tweet {i + 1}"
     >
       <Copy size={12} />
     </button>
     <button
       class="action-btn"
       onclick={() => splitBlock(block.id)}
       title="Split at cursor (Cmd+Shift+S)"
       aria-label="Split tweet {i + 1}"
     >
       <Scissors size={12} />
     </button>
     {#if i < sortedBlocks.length - 1 && sortedBlocks.length > 2}
       <button
         class="action-btn"
         onclick={() => mergeWithNext(block.id)}
         title="Merge with next (Cmd+Shift+M)"
         aria-label="Merge tweet {i + 1} with tweet {i + 2}"
       >
         <Merge size={12} />
       </button>
     {/if}
   </div>
   ```

6. **Wire keyboard shortcuts on textarea `onkeydown`:**
   Extend `handleCardKeydown` to also handle:
   - `(e.metaKey || e.ctrlKey) && e.key === 'd'` → `duplicateBlock(blockId)`
   - `(e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 's'` → `splitBlock(blockId)` (note: prevent browser save dialog)
   - `(e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'm'` → `mergeWithNext(blockId)`

7. **Add CSS for card actions:**
   ```css
   .card-actions {
     display: flex;
     gap: 2px;
     opacity: 0;
     transition: opacity 0.15s ease;
   }
   .tweet-card:hover .card-actions,
   .tweet-card.focused .card-actions {
     opacity: 1;
   }
   .action-btn {
     display: flex;
     align-items: center;
     justify-content: center;
     width: 24px;
     height: 24px;
     border: none;
     border-radius: 4px;
     background: transparent;
     color: var(--color-text-subtle);
     cursor: pointer;
     transition: all 0.15s ease;
   }
   .action-btn:hover {
     background: var(--color-surface-hover);
     color: var(--color-text);
   }
   ```

### Step 3: Create MediaSlot.svelte

**Target file:** `dashboard/src/lib/components/MediaSlot.svelte` (new)

1. **Script section:**
   ```typescript
   import { api } from '$lib/api';
   import { Image, X, Film } from 'lucide-svelte';

   let {
     mediaPaths = [],
     onmediachange,
     maxMedia = 4,
     disabled = false
   }: {
     mediaPaths: string[];
     onmediachange: (paths: string[]) => void;
     maxMedia?: number;
     disabled?: boolean;
   } = $props();

   const ACCEPTED_TYPES = 'image/jpeg,image/png,image/webp,image/gif,video/mp4';
   const MAX_IMAGE_SIZE = 5 * 1024 * 1024;
   const MAX_GIF_SIZE = 15 * 1024 * 1024;
   const MAX_VIDEO_SIZE = 512 * 1024 * 1024;

   let uploading = $state(false);
   let error = $state<string | null>(null);
   let fileInput: HTMLInputElement | undefined = $state();
   let dragOver = $state(false);

   // Track preview URLs for thumbnails (paths → blob URLs for locally uploaded)
   // For paths from server, use api.media.fileUrl
   let localPreviews = $state<Map<string, { url: string; type: string }>>(new Map());

   const hasGifOrVideo = $derived(
     mediaPaths.some(p => {
       const preview = localPreviews.get(p);
       return preview && (preview.type === 'image/gif' || preview.type === 'video/mp4');
     })
   );
   const canAttachMore = $derived(
     !disabled && !hasGifOrVideo && mediaPaths.length < maxMedia
   );
   ```

2. **Upload handler (mirrors ComposeModal pattern):**
   ```typescript
   async function handleFiles(files: FileList) {
     error = null;
     for (const file of files) {
       if (mediaPaths.length >= maxMedia) {
         error = `Maximum ${maxMedia} media per tweet.`;
         break;
       }
       // GIF/video exclusivity checks (same as ComposeModal)
       // Size checks (same as ComposeModal)
       uploading = true;
       try {
         const result = await api.media.upload(file);
         localPreviews.set(result.path, {
           url: URL.createObjectURL(file),
           type: result.media_type
         });
         localPreviews = new Map(localPreviews); // trigger reactivity
         onmediachange([...mediaPaths, result.path]);
       } catch (err) {
         error = err instanceof Error ? err.message : 'Upload failed';
         break;
       } finally {
         uploading = false;
       }
     }
   }

   function removeMedia(path: string) {
     const preview = localPreviews.get(path);
     if (preview) URL.revokeObjectURL(preview.url);
     localPreviews.delete(path);
     localPreviews = new Map(localPreviews);
     onmediachange(mediaPaths.filter(p => p !== path));
   }

   function getPreviewUrl(path: string): string {
     return localPreviews.get(path)?.url ?? api.media.fileUrl(path);
   }

   function isVideo(path: string): boolean {
     const preview = localPreviews.get(path);
     return preview?.type === 'video/mp4' || path.endsWith('.mp4');
   }
   ```

3. **Drag-and-drop file zone handlers:**
   ```typescript
   function handleDragOver(e: DragEvent) {
     e.preventDefault();
     if (canAttachMore) dragOver = true;
   }
   function handleDragLeave() { dragOver = false; }
   function handleDrop(e: DragEvent) {
     e.preventDefault();
     dragOver = false;
     if (!canAttachMore || !e.dataTransfer?.files.length) return;
     handleFiles(e.dataTransfer.files);
   }
   function handleFileSelect(e: Event) {
     const input = e.target as HTMLInputElement;
     if (input.files?.length) handleFiles(input.files);
     input.value = '';
   }
   ```

4. **Template:**
   ```svelte
   <div class="media-slot"
     class:drag-over={dragOver}
     ondragover={handleDragOver}
     ondragleave={handleDragLeave}
     ondrop={handleDrop}
   >
     {#if mediaPaths.length > 0}
       <div class="media-thumbs">
         {#each mediaPaths as path}
           <div class="thumb">
             {#if isVideo(path)}
               <video src={getPreviewUrl(path)} class="thumb-img"></video>
               <span class="media-badge"><Film size={10} /> Video</span>
             {:else}
               <img src={getPreviewUrl(path)} alt="" class="thumb-img" />
             {/if}
             <button class="remove-btn" onclick={() => removeMedia(path)} aria-label="Remove media">
               <X size={10} />
             </button>
           </div>
         {/each}
       </div>
     {/if}
     {#if canAttachMore}
       <button class="attach-btn" onclick={() => fileInput?.click()} disabled={uploading}>
         <Image size={12} />
         {uploading ? 'Uploading...' : mediaPaths.length > 0 ? 'Add more' : 'Attach media'}
       </button>
       <input
         bind:this={fileInput}
         type="file"
         accept={ACCEPTED_TYPES}
         multiple
         class="hidden"
         onchange={handleFileSelect}
       />
     {/if}
     {#if error}
       <div class="slot-error" role="alert">{error}</div>
     {/if}
   </div>
   ```

5. **Styles:** Compact thumbnail grid (48x48px), consistent with ComposeModal's media styling but smaller to fit within a card. Drag-over state: dashed accent border + subtle accent background.

### Step 4: Integrate MediaSlot into ThreadComposer

**Target file:** `dashboard/src/lib/components/ThreadComposer.svelte`

1. **Import MediaSlot:**
   ```typescript
   import MediaSlot from './MediaSlot.svelte';
   ```

2. **Add `updateBlockMedia` function:**
   ```typescript
   function updateBlockMedia(id: string, paths: string[]) {
     blocks = blocks.map(b => b.id === id ? { ...b, media_paths: paths } : b);
     emitChange();
   }
   ```

3. **Add MediaSlot below each textarea in the template:**
   ```svelte
   <MediaSlot
     mediaPaths={block.media_paths}
     onmediachange={(paths) => updateBlockMedia(block.id, paths)}
   />
   ```
   Place inside `.card-body`, after the textarea, before `.card-footer`.

4. **Update `duplicateBlock` to clone media:** Already handled — `media_paths: [...source.media_paths]`

5. **Update `mergeWithNext` media merge:** Already handled — combines both blocks' media with >4 guard.

### Step 5: Wire Per-Block Media in ComposeModal Submit

**Target file:** `dashboard/src/lib/components/ComposeModal.svelte`

1. **Update `handleSubmit` thread branch:**
   The current code:
   ```typescript
   data.blocks = validBlocks;
   ```
   Already sends blocks with their `media_paths`. Add flattened top-level:
   ```typescript
   if (mode === 'thread') {
     // ... existing block building ...
     const allMedia = validBlocks.flatMap(b => b.media_paths);
     if (allMedia.length > 0) {
       data.media_paths = allMedia;
     }
   }
   ```

2. **Remove the thread-mode media restriction:**
   Currently, the media attach section is gated: `{#if mode === 'tweet' && canAttachMore}`. Since thread mode now uses per-block MediaSlot, this existing modal-level media section should remain tweet-only. No change needed — the gate is correct as-is.

3. **Update auto-save to include per-block media:**
   Auto-save already saves `threadBlocks` which contain `media_paths`. The `recoverDraft` function restores blocks including media. Preview URLs from localStorage recovery won't have blob URLs (those are transient), but paths survive and `api.media.fileUrl(path)` will render them if the upload was persisted server-side. This is acceptable behavior — recovery restores content and media references, though thumbnails may need server fetch.

### Step 6: Validation and Boundary Handling

**Target file:** `dashboard/src/lib/components/ThreadComposer.svelte`

1. **Extend `validationErrors` derived to include media-count violations:**
   ```typescript
   for (const block of blocks) {
     if (block.media_paths.length > 4) {
       const idx = sortedBlocks.findIndex(b => b.id === block.id);
       errors.push(`Tweet ${idx + 1} has too many media (max 4).`);
     }
   }
   ```

2. **Extend `canSubmit` to check media validity:**
   ```typescript
   const canSubmit = $derived(
     blocks.filter(b => b.text.trim().length > 0).length >= 2 &&
     blocks.every(b => tweetWeightedLen(b.text) <= MAX_TWEET_CHARS) &&
     blocks.every(b => b.media_paths.length <= 4)
   );
   ```

3. **Edge cases handled:**
   - Reorder with media: `moveBlock` moves entire block object including `media_paths` — no data loss
   - Duplicate with media: deep-copies `media_paths` array
   - Split: original keeps media, new block starts empty — stated in D4-3
   - Merge: combines media, guards >4
   - Remove block: media references are dropped with the block (cleanup is server-side)

---

## Risks and Mitigations

| # | Risk | Severity | Mitigation |
|---|------|----------|------------|
| R4-1 | HTML5 DnD doesn't provide smooth animation during drag | Low | Acceptable for v1. CSS transitions on `.dragging` and `.drop-target` provide visual feedback. SortableJS or animation can be added in a polish session. |
| R4-2 | Cmd+Shift+S may conflict with browser "Save As" in some browsers | Medium | `e.preventDefault()` in handler. In Tauri, there's no browser "Save As" dialog. For dev in Chrome, it may intercept — document this. Alternative: use Ctrl+Shift+Enter for split. |
| R4-3 | MediaSlot upload errors during submitting could leave orphan files on server | Low | Server media files are cleaned up by retention policy. Upload failures surface immediately in UI. |
| R4-4 | Auto-save doesn't persist blob preview URLs for per-block media | Low | Recovery restores block structure including `media_paths` strings. Server-side files still exist. Thumbnails fall back to `api.media.fileUrl(path)`. |
| R4-5 | Split at non-word boundary may produce awkward results | Low | Word-boundary snapping heuristic (search for nearest space within 10 chars). User can always undo via merge. |
| R4-6 | ThreadComposer exceeds 400-line guideline | Low | CLAUDE.md rule targets `+page.svelte`, not component files (confirmed by D-6 from Session 03). Still, aim for ~550 lines with clean function decomposition. |

---

## Verification Steps

### Quality Gate Commands

```bash
# Frontend type-check (primary gate)
cd dashboard && npm run check

# Frontend production build
cd dashboard && npm run build
```

No Rust changes expected → Rust CI gates are skipped.

### Manual Verification Checklist

1. **Drag-and-drop reorder:**
   - [ ] Grab grip handle on tweet card 2
   - [ ] Drag to position above tweet card 1
   - [ ] Drop — card 2 is now position 1
   - [ ] Preview pane updates to reflect new order
   - [ ] Submit thread — API receives correct block order

2. **Keyboard reorder:**
   - [ ] Focus textarea in tweet card 3
   - [ ] Press Alt+ArrowUp — card moves to position 2
   - [ ] Focus stays on the moved card
   - [ ] Press Alt+ArrowDown — card moves back to position 3
   - [ ] Alt+ArrowUp on first card: no-op
   - [ ] Alt+ArrowDown on last card: no-op

3. **Duplicate:**
   - [ ] Focus card 2, press Cmd+D (or click duplicate button)
   - [ ] New card appears at position 3 with same text
   - [ ] New card has different UUID
   - [ ] Media from source card is duplicated
   - [ ] Focus moves to new card

4. **Split:**
   - [ ] Type "Hello world this is a test" in card 1
   - [ ] Place cursor after "world"
   - [ ] Press Cmd+Shift+S (or click split button)
   - [ ] Card 1 becomes "Hello world", new card 2 becomes "this is a test"
   - [ ] Focus moves to card 2

5. **Merge:**
   - [ ] Cards: "Hello" (1), "world" (2), "!" (3)
   - [ ] Focus card 1, press Cmd+Shift+M (or click merge button)
   - [ ] Card 1 becomes "Hello\nworld", card 2 becomes "!"
   - [ ] Thread now has 2 cards
   - [ ] Merge button hidden when only 2 cards remain (can't go below 2)
   - [ ] Media from both cards combined (if total <= 4)

6. **Per-block media:**
   - [ ] Click "Attach media" on card 1
   - [ ] Select image file — uploads, thumbnail appears in card 1
   - [ ] Reorder card 1 to position 2 — media stays with card
   - [ ] Card 2 (original) has no media
   - [ ] Add 4 images to card 1 — "Attach media" button disappears
   - [ ] Add GIF to card 2 — no additional images allowed on that card
   - [ ] Preview pane shows media on correct cards
   - [ ] Submit — API receives correct per-block media_paths

7. **Payload persistence:**
   - [ ] Create thread: 3 cards, card 2 has 2 images, reorder to [3, 1, 2]
   - [ ] Submit — inspect network request
   - [ ] `blocks` array has order [0, 1, 2] matching visual order
   - [ ] `blocks[1].media_paths` is empty (was card 1, no media)
   - [ ] `blocks[2].media_paths` has 2 entries (was card 2)
   - [ ] `media_paths` top-level has the same 2 entries flattened

8. **Auto-save recovery:**
   - [ ] Add media to thread cards, type content
   - [ ] Close modal without submitting
   - [ ] Reopen — recovery prompt shows
   - [ ] Click "Recover" — text and media references restored

---

## Session 05 Preview (for Handoff)

Session 05 focuses on distraction-free mode and command palette:
- `ComposeModal` gets `focusMode` state (full-viewport layout via `Cmd+Shift+F`)
- `CommandPalette.svelte` — `Cmd+K` overlay with fuzzy action search
- `shortcuts.ts` utility — keyboard shortcut registry
- Inline AI assist — select text + `Cmd+J` to improve selection
- Tab/Shift+Tab card navigation

The handoff document will identify:
- Which power-action keyboard shortcuts from this session integrate into the shortcut registry
- How focus mode interacts with the two-pane layout
- Command palette action list (including reorder, duplicate, split, merge from this session)
