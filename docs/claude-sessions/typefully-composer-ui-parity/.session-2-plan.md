# Session 02 Implementation Plan: Data Model & API Contract

**Date:** 2026-02-27
**Goal:** Implement a typed thread payload schema with stable block IDs, update compose/draft endpoints for backwards-compatible validation, and update the dashboard API client types.

---

## Summary of Current State

### Existing compose infrastructure:

- **`POST /api/content/compose`** (`compose.rs:156-259`): Accepts `{content_type, content, scheduled_for, media_paths}`. For threads, `content` must be a JSON array of strings. Each tweet is validated against `MAX_TWEET_CHARS` (280). Routes to approval queue or scheduled_content table.
- **`POST /api/content/threads`** (`compose.rs:90-139`): Accepts `{tweets: Vec<String>, scheduled_for}`. Joins tweets with `\n---\n` for storage.
- **`POST /api/content/drafts`** (`drafts.rs:38-73`): Accepts `{content_type, content, source}`. Validates non-empty content and tweet length.
- **`PATCH /api/content/drafts/{id}`** (`drafts.rs:80-99`): Accepts `{content}` only. No type-specific validation.

### Storage layer:

- `scheduled_content` table stores all content in a single `content TEXT` column.
- Threads are stored as JSON array strings (`["tweet1","tweet2"]`).
- No `blocks` or structured metadata — just raw text.
- `ScheduledContent` struct (`scheduled_content.rs:11-43`) has `content_type`, `content`, `status`, `scheduled_for`, QA fields.

### Dashboard API client:

- `ComposeRequest` type (`api.ts:191-196`): `{content_type, content, scheduled_for?, media_paths?}`.
- `api.content.compose()` sends JSON to `/api/content/compose`.
- `api.drafts.create()` / `api.drafts.edit()` use separate types.

---

## Design Decisions

### D-1: ThreadBlock struct lives in `tuitbot-core`, not `tuitbot-server`

**Rationale:** Per the three-layer architecture, domain types belong in `tuitbot-core`. The `ThreadBlock` struct and its validation function (`validate_thread_blocks()`) should be in `crates/tuitbot-core/src/content/mod.rs` (or a new `thread.rs` submodule) so they can be reused by CLI, MCP, and server crates. The server just calls core validation.

### D-2: `blocks` serialized to JSON for storage, no DB migration

**Rationale:** Per Session 01 constraint #6, thread content continues to be stored in the existing `content` TEXT column. When `blocks` is present, the server serializes the blocks array to a JSON string with a wrapper format that distinguishes it from the legacy `["tweet1","tweet2"]` format. On read, the server detects the format and deserializes accordingly.

**Storage format for blocks:**
```json
{"version":1,"blocks":[{"id":"uuid","text":"tweet text","media_paths":[],"order":0}]}
```

This wrapper object with a `version` field is unambiguous — it's an object, not a string array — so the server can detect it on read simply by checking if the parsed JSON is an object with a `blocks` key vs. an array of strings.

### D-3: Validation in core, request parsing in server

**Rationale:** The `ThreadBlock` struct definition and `validate_thread_blocks()` function live in core. The Axum `Deserialize` request structs (with `serde` attributes like `#[serde(default)]`) stay in server. The server's compose handler deserializes, then calls `validate_thread_blocks()` from core.

### D-4: Per-block media validation is text-only for now

**Rationale:** Session 02 validates the structural constraints of per-block media (count limits, no mixed types per block). Actual file validation (file exists, correct MIME type) is not added here — that's an upload concern handled by the existing media upload endpoint. The `media_paths` in blocks are treated as opaque path strings at the API contract level.

### D-5: Draft edit endpoint gains optional `blocks` field

**Rationale:** The current `EditDraftRequest` only has `content: String`. To support thread editing via the new schema, the edit endpoint needs to accept `blocks` as an alternative. When `blocks` is present, the server serializes them to the storage format. When absent, raw `content` is stored as before.

---

## Files to Modify/Create

### 1. `crates/tuitbot-core/src/content/thread.rs` (CREATE)

New submodule for thread block types and validation.

**Contents:**
- `ThreadBlock` struct: `{id: String, text: String, media_paths: Vec<String>, order: u32}`
  - Derives: `Debug, Clone, Serialize, Deserialize, PartialEq`
- `ThreadBlocksPayload` struct: `{version: u8, blocks: Vec<ThreadBlock>}`
  - For serialized storage format
- `validate_thread_blocks(blocks: &[ThreadBlock]) -> Result<(), Vec<ThreadBlockError>>`
  - Validates:
    1. Non-empty blocks array (at least 1 block, at least 2 for a thread)
    2. All block IDs are unique (collect into HashSet, check len)
    3. Order fields form contiguous 0..N sequence (sort, compare with expected)
    4. Each block's text is non-empty after trim
    5. Each block's text is within `MAX_TWEET_CHARS` (using `tweet_weighted_len`)
    6. Each block's `media_paths` has at most 4 entries (image limit) — GIF/video distinction is a frontend concern for now
    7. Block IDs are valid (non-empty strings)
- `ThreadBlockError` enum:
  - `EmptyBlocks` — no blocks provided
  - `SingleBlock` — thread must have >= 2 blocks
  - `DuplicateBlockId { id: String }` — two blocks share the same ID
  - `NonContiguousOrder { expected: Vec<u32>, actual: Vec<u32> }` — order gaps
  - `EmptyBlockText { block_id: String }` — block has empty text
  - `BlockTextTooLong { block_id: String, length: usize, max: usize }` — over 280 chars
  - `TooManyMedia { block_id: String, count: usize, max: usize }` — > 4 media items
  - `InvalidBlockId { index: usize }` — empty block ID
- `serialize_blocks_for_storage(blocks: &[ThreadBlock]) -> String`
  - Wraps in `ThreadBlocksPayload { version: 1, blocks }` and serializes to JSON string
- `deserialize_blocks_from_content(content: &str) -> Option<Vec<ThreadBlock>>`
  - Tries to parse content as `ThreadBlocksPayload` (object with `blocks` key)
  - Returns `None` if content is a legacy format (plain string or string array)

**Estimated size:** ~120 lines (well under 500-line limit).

### 2. `crates/tuitbot-core/src/content/mod.rs` (MODIFY)

**Changes:**
- Add `pub mod thread;` declaration
- Add `pub use thread::{ThreadBlock, ThreadBlockError, validate_thread_blocks, serialize_blocks_for_storage, deserialize_blocks_from_content};`

**Impact:** 3 lines added. Re-exports make the types available as `tuitbot_core::content::ThreadBlock` etc.

### 3. `crates/tuitbot-server/src/routes/content/compose.rs` (MODIFY)

**Changes to `ComposeRequest` struct (line 142-153):**
- Add optional `blocks` field:
  ```rust
  #[serde(default)]
  pub blocks: Option<Vec<ThreadBlockRequest>>,
  ```
- Define `ThreadBlockRequest` as a local deserialization struct:
  ```rust
  #[derive(Deserialize)]
  pub struct ThreadBlockRequest {
      pub id: String,
      pub text: String,
      #[serde(default)]
      pub media_paths: Vec<String>,
      pub order: u32,
  }
  ```

**Changes to `compose()` handler (line 156-259):**
- Add a new code path: when `content_type == "thread"` and `blocks` is `Some`:
  1. Convert `ThreadBlockRequest` vec to `ThreadBlock` vec from core
  2. Call `validate_thread_blocks()` — map errors to `ApiError::BadRequest` with descriptive messages
  3. Call `serialize_blocks_for_storage()` to get the content string for DB storage
  4. Use the serialized blocks as the `content` value for `scheduled_content::insert_for()` or `approval_queue::enqueue_for()`
  5. Collect per-block media paths into a flat list for the `media_json` field in approval queue
- When `content_type == "thread"` and `blocks` is `None`:
  - Keep existing logic: parse `content` as JSON string array, validate each tweet
- When `content_type == "tweet"`:
  - Keep existing logic unchanged. Ignore `blocks` field if present.

**Key behavior: `blocks` takes precedence over `content` for threads.**

When both `blocks` and `content` are provided for a thread, use `blocks`. The `content` field is ignored in this case (per Session 01 constraint #2).

**Error responses for blocks validation failures:**
- `400 Bad Request` with `{"error": "thread blocks must not be empty"}`
- `400 Bad Request` with `{"error": "thread must contain at least 2 blocks"}`
- `400 Bad Request` with `{"error": "duplicate block ID: {id}"}`
- `400 Bad Request` with `{"error": "block order must be a contiguous sequence starting at 0"}`
- `400 Bad Request` with `{"error": "block {id} has empty text"}`
- `400 Bad Request` with `{"error": "block {id}: text exceeds 280 characters (length: {n})"}`
- `400 Bad Request` with `{"error": "block {id}: too many media attachments ({n}, max 4)"}`
- `400 Bad Request` with `{"error": "block at index {i} has an empty ID"}`

**Response format change:**
- When blocks are used, the response includes the block IDs for roundtrip verification:
  ```json
  {"status": "scheduled", "id": 42, "block_ids": ["uuid-1", "uuid-2"]}
  ```
- Legacy responses remain unchanged.

**Estimated diff:** ~80 lines added to compose.rs, keeping it well under 260 + 80 = 340 lines (under 500 limit).

### 4. `crates/tuitbot-server/src/routes/content/drafts.rs` (MODIFY)

**Changes to `CreateDraftRequest` (line 16-22):**
- Add optional `blocks` field:
  ```rust
  #[serde(default)]
  pub blocks: Option<Vec<ThreadBlockRequest>>,
  ```

**Changes to `create_draft()` handler (line 38-73):**
- When `content_type == "thread"` and `blocks` is `Some`:
  1. Convert to core `ThreadBlock` vec
  2. Call `validate_thread_blocks()` — map errors to `ApiError::BadRequest`
  3. Serialize blocks for storage
  4. Use serialized blocks as `content` for `insert_draft_for()`
- When `blocks` is `None`:
  - Keep existing logic (validate non-empty, check tweet length if tweet type)

**Changes to `EditDraftRequest` (line 75-78):**
- Add optional `blocks` field:
  ```rust
  #[serde(default)]
  pub blocks: Option<Vec<ThreadBlockRequest>>,
  ```
- Make `content` optional:
  ```rust
  pub content: Option<String>,
  ```

**Changes to `edit_draft()` handler (line 80-99):**
- When `blocks` is `Some`:
  1. Validate blocks via core
  2. Serialize blocks for storage
  3. Use serialized blocks as content for `update_draft_for()`
- When `blocks` is `None` and `content` is `Some`:
  - Keep existing logic
- When both `None`:
  - Return `400 Bad Request` — must provide either `content` or `blocks`

**Changes to `list_drafts()` handler (line 28-36):**
- No changes to the handler itself — the `ScheduledContent` struct already returns the `content` field as-is. The frontend will detect the storage format (object vs. string array) and parse accordingly.

**Estimated diff:** ~50 lines added to drafts.rs, keeping it under 187 + 50 = 237 lines (under 500 limit).

### 5. `crates/tuitbot-server/src/routes/content/mod.rs` (MODIFY)

**Changes:**
- Add `ThreadBlockRequest` to the re-exports from compose module:
  ```rust
  pub use compose::{ComposeRequest, ComposeThreadRequest, ComposeTweetRequest, ThreadBlockRequest};
  ```

**Estimated diff:** 1 line modified.

### 6. `dashboard/src/lib/api.ts` (MODIFY)

**New types (insert after `ComposeRequest` interface around line 196):**

```typescript
export interface ThreadBlock {
    id: string;
    text: string;
    media_paths: string[];
    order: number;
}

export interface ComposeRequest {
    content_type: string;
    content: string;
    scheduled_for?: string;
    media_paths?: string[];
    blocks?: ThreadBlock[];
}
```

**Changes to existing `ComposeRequest` (line 191-196):**
- Add optional `blocks` field

**New type for parsed thread content:**
```typescript
export interface ThreadBlocksPayload {
    version: number;
    blocks: ThreadBlock[];
}
```

**New helper functions:**
```typescript
export function parseThreadContent(content: string): ThreadBlock[] | string[] {
    try {
        const parsed = JSON.parse(content);
        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed) && parsed.blocks) {
            return parsed.blocks as ThreadBlock[];
        }
        if (Array.isArray(parsed)) {
            return parsed as string[];
        }
    } catch {
        // Not JSON — return as single-item array
    }
    return [content];
}

export function isBlocksPayload(content: string): boolean {
    try {
        const parsed = JSON.parse(content);
        return parsed && typeof parsed === 'object' && !Array.isArray(parsed) && 'blocks' in parsed;
    } catch {
        return false;
    }
}
```

**Update draft API methods:**
- `drafts.create`: Add optional `blocks` parameter
  ```typescript
  create: (contentType: string, content: string, source: string = 'manual', blocks?: ThreadBlock[]) =>
      request<{ id: number; status: string }>('/api/content/drafts', {
          method: 'POST',
          body: JSON.stringify({ content_type: contentType, content, source, ...(blocks && { blocks }) })
      }),
  ```
- `drafts.edit`: Add optional `blocks` parameter
  ```typescript
  edit: (id: number, content?: string, blocks?: ThreadBlock[]) =>
      request<{ id: number; status: string }>(`/api/content/drafts/${id}`, {
          method: 'PATCH',
          body: JSON.stringify({ ...(content !== undefined && { content }), ...(blocks && { blocks }) })
      }),
  ```

**Estimated diff:** ~50 lines added/modified in api.ts.

### 7. `crates/tuitbot-server/tests/compose_contract_tests.rs` (CREATE)

New test file following the established pattern from `api_tests.rs`.

**Test infrastructure:**
- Reuse `test_router()`, `post_json()`, `get_json()`, `patch_json()` helpers (copy from api_tests.rs or factor into a shared test_utils module — prefer copying for simplicity since these are test files).

**Test cases (organized by category):**

#### Legacy compatibility tests:
1. `legacy_compose_tweet_still_works` — POST `/api/content/compose` with `{content_type: "tweet", content: "hello"}` returns 200
2. `legacy_compose_thread_still_works` — POST `/api/content/compose` with `{content_type: "thread", content: "[\"t1\",\"t2\"]"}` returns 200
3. `legacy_compose_thread_empty_array_rejected` — POST with `{content_type: "thread", content: "[]"}` returns 400
4. `legacy_compose_tweet_over_limit_rejected` — POST with 281-char tweet returns 400
5. `legacy_compose_thread_single_tweet_over_limit_rejected` — Thread with one over-limit tweet returns 400

#### Blocks compose tests:
6. `compose_thread_with_blocks_accepted` — POST with valid `blocks` array returns 200 with `block_ids` in response
7. `compose_thread_blocks_precedence_over_content` — When both `blocks` and `content` present, blocks are used (verify storage)
8. `compose_thread_blocks_with_media_paths` — Blocks with per-block `media_paths` accepted and stored
9. `compose_thread_blocks_roundtrip` — Compose with blocks, then read via draft/scheduled content, verify block IDs survive

#### Blocks validation rejection tests:
10. `compose_blocks_empty_rejected` — Empty blocks array returns 400
11. `compose_blocks_single_block_rejected` — Single block (not a valid thread) returns 400
12. `compose_blocks_duplicate_ids_rejected` — Two blocks with same ID returns 400
13. `compose_blocks_non_contiguous_order_rejected` — Order [0, 2] (gap at 1) returns 400
14. `compose_blocks_order_not_starting_at_zero_rejected` — Order [1, 2] returns 400
15. `compose_blocks_empty_text_rejected` — Block with empty/whitespace text returns 400
16. `compose_blocks_text_over_limit_rejected` — Block with 281+ chars returns 400
17. `compose_blocks_too_many_media_rejected` — Block with 5+ media_paths returns 400
18. `compose_blocks_empty_id_rejected` — Block with empty string ID returns 400

#### Draft with blocks tests:
19. `create_draft_with_blocks_accepted` — POST `/api/content/drafts` with blocks returns 200
20. `edit_draft_with_blocks_accepted` — PATCH `/api/content/drafts/{id}` with blocks updates stored content
21. `edit_draft_content_or_blocks_required` — PATCH with neither content nor blocks returns 400
22. `list_drafts_returns_blocks_in_content` — List drafts returns content with blocks payload format

#### Edge cases:
23. `compose_tweet_ignores_blocks` — When `content_type` is "tweet", blocks field is ignored
24. `compose_blocks_with_urls_respects_weighted_length` — Block with long URL counts as 23 chars

**Estimated size:** ~350 lines (under 500 limit).

### 8. `docs/roadmap/typefully-composer-ui-parity/session-02-api-contract.md` (CREATE)

API contract documentation:
- New `ThreadBlock` schema with field descriptions
- Storage format specification
- Endpoint changes with request/response examples
- Backwards compatibility notes
- Migration notes for frontend

### 9. `docs/roadmap/typefully-composer-ui-parity/session-02-handoff.md` (CREATE)

Session handoff:
- What changed (files modified, types added)
- Decisions made (D-1 through D-5)
- Open risks
- Exact inputs for Session 03

---

## Implementation Order

### Step 1: Create `ThreadBlock` type and validation in core

**File:** `crates/tuitbot-core/src/content/thread.rs`

1. Define `ThreadBlock` struct with serde derives
2. Define `ThreadBlocksPayload` storage wrapper
3. Define `ThreadBlockError` enum with `thiserror`
4. Implement `validate_thread_blocks()` with all 7 validation rules
5. Implement `serialize_blocks_for_storage()` and `deserialize_blocks_from_content()`
6. Add unit tests for each validation rule in a `#[cfg(test)] mod tests` block

**File:** `crates/tuitbot-core/src/content/mod.rs`

7. Add `pub mod thread;` and re-exports

**Verify:**
```bash
cargo test -p tuitbot-core content::thread
```

### Step 2: Update compose endpoint

**File:** `crates/tuitbot-server/src/routes/content/compose.rs`

1. Add `use tuitbot_core::content::{ThreadBlock, validate_thread_blocks, serialize_blocks_for_storage, ThreadBlockError};`
2. Define `ThreadBlockRequest` deserialization struct
3. Add `blocks: Option<Vec<ThreadBlockRequest>>` to `ComposeRequest`
4. Add conversion from `ThreadBlockRequest` to `ThreadBlock` (a simple mapping)
5. In `compose()` handler, add the blocks code path in the `"thread"` match arm:
   - Check if `body.blocks.is_some()`
   - Convert to core types
   - Validate via `validate_thread_blocks()`
   - Serialize to storage format
   - Use as content for insert/enqueue
6. Keep the existing `content` parsing path as the else branch

**File:** `crates/tuitbot-server/src/routes/content/mod.rs`

7. Add `ThreadBlockRequest` to re-exports

**Verify:**
```bash
cargo clippy -p tuitbot-server -- -D warnings
```

### Step 3: Update draft endpoints

**File:** `crates/tuitbot-server/src/routes/content/drafts.rs`

1. Add same imports as compose.rs
2. Add `blocks: Option<Vec<ThreadBlockRequest>>` to `CreateDraftRequest`
3. Update `create_draft()` to handle blocks when content_type is "thread"
4. Make `EditDraftRequest.content` optional, add `blocks` field
5. Update `edit_draft()` to handle blocks, require at least one of content/blocks

**Verify:**
```bash
cargo clippy -p tuitbot-server -- -D warnings
```

### Step 4: Update dashboard API types

**File:** `dashboard/src/lib/api.ts`

1. Add `ThreadBlock` interface
2. Add `ThreadBlocksPayload` interface
3. Add `blocks?` field to `ComposeRequest`
4. Add `parseThreadContent()` and `isBlocksPayload()` helper functions
5. Update `drafts.create()` and `drafts.edit()` to accept optional blocks parameter

**Verify:**
```bash
cd dashboard && npm run check
```

### Step 5: Write contract tests

**File:** `crates/tuitbot-server/tests/compose_contract_tests.rs`

1. Copy test helpers from `api_tests.rs` (test_router, post_json, get_json, patch_json, delete_json)
2. Write all 24 test cases listed above
3. Run full test suite

**Verify:**
```bash
RUSTFLAGS="-D warnings" cargo test --workspace
```

### Step 6: Run all quality gates

```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
cd dashboard && npm run check
```

### Step 7: Write deliverable documents

1. `docs/roadmap/typefully-composer-ui-parity/session-02-api-contract.md`
2. `docs/roadmap/typefully-composer-ui-parity/session-02-handoff.md`

---

## Risks and Mitigations

### R-1: ThreadBlockRequest vs ThreadBlock type duplication

**Risk:** Having both `ThreadBlockRequest` (serde Deserialize, in server) and `ThreadBlock` (in core) creates duplication.

**Mitigation:** `ThreadBlockRequest` is intentionally separate — it's the API boundary type with Axum-specific serde configuration. The conversion from request type to domain type is a 4-field mapping. This keeps core free of web framework concerns. The conversion function is trivial and explicit.

### R-2: Storage format detection ambiguity

**Risk:** When reading content from the database, we need to distinguish between legacy format (`["tweet1","tweet2"]`) and new blocks format (`{"version":1,"blocks":[...]}`).

**Mitigation:** The version wrapper object is unambiguously distinguishable from a JSON string array. `deserialize_blocks_from_content()` tries to parse as object first — if it has a `blocks` key, it's new format. If it's an array of strings, it's legacy. If it's neither, it's a raw tweet text string. Three cases, no ambiguity.

### R-3: EditDraftRequest backwards compatibility

**Risk:** Making `content` optional in `EditDraftRequest` could break existing callers that always send `content`.

**Mitigation:** `content: Option<String>` with `#[serde(default)]` means existing JSON with `{"content": "..."}` still works — it just gets wrapped in `Some()`. Only the handler logic changes: it now checks `blocks` first, then `content`, and rejects if neither is present.

### R-4: Per-block media_paths vs top-level media_paths

**Risk:** When blocks have per-block media_paths and the top-level `media_paths` also exists, which takes precedence?

**Mitigation:** When `blocks` is present, per-block `media_paths` are the source of truth. Top-level `media_paths` is ignored for thread block payloads. For approval queue storage (which needs a flat `media_paths` JSON), we collect all per-block media into a single flat array. This is documented in the API contract.

### R-5: Test file size

**Risk:** 24 test cases could push `compose_contract_tests.rs` near the 500-line limit.

**Mitigation:** Each test is ~12-15 lines. 24 tests = ~300-360 lines + ~50 lines of helpers + imports = ~400 lines. Under the 500-line limit. If it grows, tests can be split into `compose_contract_tests/` module directory.

---

## Exit Criteria Checklist

- [ ] `ThreadBlock` struct defined in `tuitbot-core::content::thread`
- [ ] `validate_thread_blocks()` enforces all 7 rules
- [ ] `serialize_blocks_for_storage()` produces versioned JSON wrapper
- [ ] `deserialize_blocks_from_content()` detects format correctly
- [ ] `POST /api/content/compose` accepts `blocks` for threads
- [ ] `POST /api/content/compose` with `content` only (legacy) still works
- [ ] `POST /api/content/drafts` accepts `blocks` for threads
- [ ] `PATCH /api/content/drafts/{id}` accepts `blocks`
- [ ] Block IDs survive roundtrip (compose → read back)
- [ ] All 24 contract tests pass
- [ ] `cargo fmt --all --check` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
- [ ] `RUSTFLAGS="-D warnings" cargo test --workspace` passes
- [ ] `cd dashboard && npm run check` passes
- [ ] `session-02-api-contract.md` documents the contract
- [ ] `session-02-handoff.md` documents what changed, decisions, and Session 03 inputs

---

## Session 03 Integration Points (for handoff)

The following integration points will be documented in the handoff for Session 03:

1. **ThreadBlock TypeScript type** — `dashboard/src/lib/api.ts` exports `ThreadBlock` interface for use by `ThreadComposer.svelte`
2. **parseThreadContent()** — Helper to detect and parse blocks from draft content for pre-populating the thread editor
3. **blocks field on ComposeRequest** — ThreadComposer will construct `ThreadBlock[]` with client-generated UUIDs and send via `api.content.compose()`
4. **Draft editing with blocks** — ThreadComposer can save/load drafts with block structure preserved
5. **isBlocksPayload()** — Helper for ComposeModal to detect whether a draft uses the new block format when opening for editing
