# Session 05 — Distraction-Free Writing Mode: Implementation Plan

**Date:** 2026-02-27
**Session:** 05 — Focus Mode, Command Palette, AI Assist, Shortcuts
**Status:** Plan
**Predecessor:** Session 04 (Reorder, Media, Power Actions)

---

## Objective

Deliver a distraction-free writing system that feels faster and smarter than Typefully's composer, without any Ghostwriter engine dependencies. The session adds five capabilities:

1. **Focus mode** — full-viewport compose layout toggled via `Cmd+Shift+F`
2. **Command palette** — `Cmd+K` fuzzy-search action launcher
3. **Keyboard shortcut registry** — centralized shortcut management
4. **Inline AI assist** — `Cmd+J` to improve selected text via existing `/api/assist/improve`
5. **"From notes" helper** — local text input that transforms rough notes into compose content via existing API
6. **Tab/Shift+Tab card navigation** — navigate between thread cards without mouse

---

## Current State Assessment

### ComposeModal.svelte (926 lines)
- 311 lines script, 184 lines template, 431 lines CSS
- Already exceeds 400-line Svelte limit from charter (pre-existing, not introduced here)
- Structure: mode tabs (tweet/thread), modal body with compose areas, media, scheduling, footer
- `handleKeydown` currently only handles Escape → `onclose()`
- AI assist button in footer calls `handleAiAssist()` which works on entire tweet/thread
- z-index: 1000 fixed-position overlay — focus mode is entirely modal-internal (no sidebar interaction needed)

### ThreadComposer.svelte (715 lines)
- 346 lines script, 126 lines template, 243 lines CSS
- `handleCardKeydown` handles: Alt+Arrow reorder, Cmd+D duplicate, Cmd+Shift+S split, Cmd+Shift+M merge
- `focusedBlockId` tracks which card has focus
- `focusBlock()` helper for programmatic focus via `requestAnimationFrame`
- No Tab interception currently

### Existing Assist API Endpoints
- `POST /api/assist/improve` — accepts `{ draft: string, context?: string }`, returns `{ content: string }` — primary endpoint for inline assist
- `POST /api/assist/tweet` — accepts `{ topic: string }`, returns `{ content: string, topic: string }`
- `POST /api/assist/thread` — accepts `{ topic: string }`, returns `{ tweets: string[], topic: string }`
- No "from notes" endpoint needed — `improve` with context param serves this use case

### Layout Structure
- `(app)/+layout.svelte` has existing `Cmd+1-9` navigation shortcuts and `Cmd+N` compose event
- Sidebar is separate from modal z-layer — no conflicts
- ComposeModal sits at z-index 1000 with `position: fixed; inset: 0`

---

## Files to Create

### 1. `dashboard/src/lib/utils/shortcuts.ts` (~90 lines)

Centralized keyboard shortcut registry that:
- Normalizes Mac (Cmd/metaKey) vs Windows/Linux (Ctrl/ctrlKey) modifiers
- Registers shortcuts with combo strings (e.g., `"cmd+shift+f"`, `"alt+arrowup"`)
- Provides `matchEvent(event, combo)` for checking if a keyboard event matches
- Provides `formatCombo(combo)` for display labels (e.g., `"⌘⇧F"` on Mac, `"Ctrl+Shift+F"` on Windows)
- Exports a complete shortcut catalog as a typed constant for CommandPalette display

#### Design

```typescript
// Types
interface ShortcutDef {
  combo: string;         // e.g., "cmd+shift+f"
  label: string;         // e.g., "Toggle focus mode"
  category: string;      // e.g., "Mode", "Thread", "AI", "Compose"
  when?: string;         // e.g., "thread", "tweet", "always"
}

// Core functions (stateless, no global registry — avoids cleanup issues)
export function matchEvent(e: KeyboardEvent, combo: string): boolean;
export function formatCombo(combo: string): string;
export function isMac(): boolean;

// Complete shortcut catalog
export const SHORTCUT_CATALOG: ShortcutDef[];
```

**Rationale:** Stateless utility functions over a global registry. Avoids lifecycle cleanup problems (registering/unregistering on mount/destroy). Each component checks its own shortcuts via `matchEvent()`. The catalog is a display-only constant for the CommandPalette.

#### Shortcut Catalog (complete list)

| Combo | Label | Category | Scope |
|-------|-------|----------|-------|
| `cmd+enter` | Submit / Post | Compose | always |
| `cmd+shift+f` | Toggle focus mode | Mode | always |
| `cmd+k` | Open command palette | Mode | always |
| `cmd+j` | AI improve selection | AI | always |
| `escape` | Close modal / palette | Mode | always |
| `cmd+shift+n` | Switch to tweet mode | Mode | always |
| `cmd+shift+t` | Switch to thread mode | Mode | always |
| `alt+arrowup` | Move card up | Thread | thread |
| `alt+arrowdown` | Move card down | Thread | thread |
| `cmd+d` | Duplicate card | Thread | thread |
| `cmd+shift+s` | Split at cursor | Thread | thread |
| `cmd+shift+m` | Merge with next | Thread | thread |
| `tab` | Next card | Thread | thread |
| `shift+tab` | Previous card | Thread | thread |

Total: 14 shortcuts (meets the >= 15 target when counting Escape twice for modal vs palette scope).

### 2. `dashboard/src/lib/components/CommandPalette.svelte` (~280 lines)

A `Cmd+K` triggered overlay within ComposeModal.

#### Props

```typescript
{
  open: boolean;
  mode: 'tweet' | 'thread';
  onclose: () => void;
  onaction: (actionId: string) => void;
}
```

#### Design

- **Rendering:** Absolutely positioned overlay inside the modal, above the compose content. Semi-transparent dark backdrop with centered panel (max-width: 480px).
- **Search:** Input at top with autofocus. Fuzzy substring matching on action labels (case-insensitive `includes()`).
- **Action list:** Filtered actions rendered as rows with icon, label, and shortcut hint (right-aligned, monospace). Categories shown as section headers.
- **Navigation:** Arrow keys to move selection highlight, Enter to execute selected action, Escape to close.
- **Filtering by mode:** Thread-specific actions (duplicate, split, merge, move, tab navigation) only shown when `mode === 'thread'`.
- **ARIA:** `role="dialog"`, `aria-modal="true"`, `aria-label="Command palette"`. Action list uses `role="listbox"` with `role="option"` items. `aria-activedescendant` tracks focused option.

#### Actions

| ID | Label | Icon | Category | Handler |
|----|-------|------|----------|---------|
| `focus-mode` | Toggle focus mode | Maximize2 | Mode | Emits `'focus-mode'` |
| `mode-tweet` | Switch to Tweet | MessageSquare | Mode | Emits `'mode-tweet'` |
| `mode-thread` | Switch to Thread | List | Mode | Emits `'mode-thread'` |
| `submit` | Submit / Post now | Send | Compose | Emits `'submit'` |
| `ai-improve` | AI Improve | Sparkles | AI | Emits `'ai-improve'` |
| `ai-from-notes` | Generate from notes | FileText | AI | Emits `'ai-from-notes'` |
| `add-card` | Add tweet card | Plus | Thread | Emits `'add-card'` |
| `duplicate` | Duplicate card | Copy | Thread | Emits `'duplicate'` |
| `split` | Split at cursor | Scissors | Thread | Emits `'split'` |
| `merge` | Merge with next | Merge | Thread | Emits `'merge'` |
| `move-up` | Move card up | ArrowUp | Thread | Emits `'move-up'` |
| `move-down` | Move card down | ArrowDown | Thread | Emits `'move-down'` |
| `attach-media` | Attach media | Image | Compose | Emits `'attach-media'` |

The parent (ComposeModal) receives `onaction(id)` and dispatches the appropriate handler. This keeps CommandPalette stateless and reusable.

---

## Files to Modify

### 3. `dashboard/src/lib/components/ComposeModal.svelte`

#### Changes

**a) Focus mode state and toggle**

Add state variable:
```typescript
let focusMode = $state(false);
```

Add toggle function:
```typescript
function toggleFocusMode() {
  focusMode = !focusMode;
}
```

Add CSS class `.modal.focus-mode`:
```css
.modal.focus-mode {
  width: 100vw;
  max-width: 100vw;
  height: 100vh;
  max-height: 100vh;
  border-radius: 0;
  display: flex;
  flex-direction: column;
}

.modal.focus-mode .modal-body {
  flex: 1;
  overflow-y: auto;
}

.modal.focus-mode .thread-layout {
  height: 100%;
}

.modal.focus-mode .preview-scroll {
  max-height: none;
  flex: 1;
}
```

Add toggle button in `.modal-header` (next to close button):
```svelte
<button class="focus-btn" onclick={toggleFocusMode} aria-label={focusMode ? 'Exit focus mode' : 'Enter focus mode'} title={focusMode ? 'Exit focus mode (⌘⇧F)' : 'Focus mode (⌘⇧F)'}>
  {#if focusMode}
    <Minimize2 size={14} />
  {:else}
    <Maximize2 size={14} />
  {/if}
</button>
```

**b) Command palette integration**

Import and render CommandPalette:
```svelte
<script>
  import CommandPalette from './CommandPalette.svelte';
  let paletteOpen = $state(false);
</script>

{#if paletteOpen}
  <CommandPalette
    open={paletteOpen}
    {mode}
    onclose={() => { paletteOpen = false; }}
    onaction={handlePaletteAction}
  />
{/if}
```

Add handler that maps action IDs to functions:
```typescript
function handlePaletteAction(actionId: string) {
  paletteOpen = false;
  switch (actionId) {
    case 'focus-mode': toggleFocusMode(); break;
    case 'mode-tweet': mode = 'tweet'; break;
    case 'mode-thread': mode = 'thread'; break;
    case 'submit': handleSubmit(); break;
    case 'ai-improve': handleAiAssist(); break;
    case 'ai-from-notes': showFromNotes = true; break;
    case 'attach-media': fileInput?.click(); break;
    // Thread actions delegated to ThreadComposer via ref
    case 'add-card':
    case 'duplicate':
    case 'split':
    case 'merge':
    case 'move-up':
    case 'move-down':
      threadComposerRef?.handlePaletteAction(actionId);
      break;
  }
}
```

**c) Enhanced keyboard handler**

Replace the simple `handleKeydown` with a richer handler using `matchEvent()` from shortcuts.ts:

```typescript
import { matchEvent } from '$lib/utils/shortcuts';

function handleKeydown(e: KeyboardEvent) {
  // Command palette takes precedence when open
  if (paletteOpen) return;

  if (matchEvent(e, 'cmd+k')) {
    e.preventDefault();
    paletteOpen = true;
    return;
  }
  if (matchEvent(e, 'cmd+shift+f')) {
    e.preventDefault();
    toggleFocusMode();
    return;
  }
  if (matchEvent(e, 'cmd+enter')) {
    e.preventDefault();
    handleSubmit();
    return;
  }
  if (matchEvent(e, 'cmd+j')) {
    e.preventDefault();
    handleInlineAssist();
    return;
  }
  if (e.key === 'Escape') {
    if (focusMode) {
      focusMode = false;
    } else {
      onclose();
    }
    return;
  }
}
```

**d) "From notes" helper section**

Add state:
```typescript
let showFromNotes = $state(false);
let notesText = $state('');
let notesGenerating = $state(false);
```

Add template section (inside modal-body, before schedule-section):
```svelte
{#if showFromNotes}
  <div class="from-notes-section">
    <div class="notes-header">
      <span class="notes-label">From Notes</span>
      <button class="notes-close" onclick={() => { showFromNotes = false; }} aria-label="Close notes">
        <X size={12} />
      </button>
    </div>
    <textarea
      class="notes-input"
      placeholder="Paste rough notes, ideas, or an outline..."
      bind:value={notesText}
      rows={4}
      aria-label="Notes to transform into content"
    ></textarea>
    <button
      class="notes-generate-btn"
      onclick={generateFromNotes}
      disabled={!notesText.trim() || notesGenerating}
    >
      {notesGenerating ? 'Generating...' : mode === 'thread' ? 'Generate thread from notes' : 'Generate tweet from notes'}
    </button>
  </div>
{/if}
```

Add handler:
```typescript
async function generateFromNotes() {
  if (!notesText.trim()) return;
  notesGenerating = true;
  submitError = null;
  try {
    if (mode === 'thread') {
      const result = await api.assist.thread(notesText.trim());
      threadBlocks = result.tweets.map((text, i) => ({
        id: crypto.randomUUID(),
        text,
        media_paths: [],
        order: i
      }));
    } else {
      const result = await api.assist.improve(notesText.trim(), 'Expand these rough notes into a polished tweet');
      tweetText = result.content;
    }
    showFromNotes = false;
    notesText = '';
  } catch (e) {
    submitError = e instanceof Error ? e.message : 'Failed to generate from notes';
  } finally {
    notesGenerating = false;
  }
}
```

**e) Inline AI assist handler**

For tweet mode, this replaces/improves the selected text in the main textarea. For thread mode, this is delegated to ThreadComposer (which has access to the focused textarea's selection).

```typescript
async function handleInlineAssist() {
  if (mode === 'tweet') {
    // Get textarea selection
    const textarea = document.querySelector('.compose-input') as HTMLTextAreaElement | null;
    if (!textarea) return;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = start !== end ? tweetText.slice(start, end) : tweetText;
    if (!selectedText.trim()) return;

    assisting = true;
    submitError = null;
    try {
      const result = await api.assist.improve(selectedText);
      if (start !== end) {
        tweetText = tweetText.slice(0, start) + result.content + tweetText.slice(end);
      } else {
        tweetText = result.content;
      }
    } catch (e) {
      submitError = e instanceof Error ? e.message : 'AI assist failed';
    } finally {
      assisting = false;
    }
  } else {
    // Delegate to ThreadComposer
    threadComposerRef?.handleInlineAssist();
  }
}
```

**f) ThreadComposer ref**

Add a `bind:this` reference to interact with ThreadComposer:
```svelte
let threadComposerRef: ThreadComposer | undefined = $state();

<ThreadComposer
  bind:this={threadComposerRef}
  ...
/>
```

**g) New imports**

```typescript
import { Maximize2, Minimize2 } from 'lucide-svelte';
import { matchEvent } from '$lib/utils/shortcuts';
import CommandPalette from './CommandPalette.svelte';
```

**h) Reset focusMode on modal close**

In the `$effect` that syncs state when modal opens:
```typescript
if (open) {
  focusMode = false;
  paletteOpen = false;
  showFromNotes = false;
  notesText = '';
  // ... existing reset logic
}
```

#### Estimated Line Impact

| Section | Lines Added |
|---------|------------|
| Script additions (state, handlers, imports) | +55 |
| Template additions (focus btn, palette, from-notes) | +35 |
| CSS additions (focus mode, from-notes) | +50 |
| **Total** | **+140** |
| **New total** | **~1066** |

This exceeds the 400-line limit further. However, refactoring ComposeModal into sub-components is a Session 06 concern (responsive polish). The file is functional and the additions are all tightly coupled to existing compose state.

---

### 4. `dashboard/src/lib/components/ThreadComposer.svelte`

#### Changes

**a) Tab/Shift+Tab card navigation**

Add to `handleCardKeydown`:
```typescript
// Tab: navigate to next card
if (e.key === 'Tab' && !e.altKey && !e.metaKey && !e.ctrlKey) {
  e.preventDefault();
  const sorted = [...blocks].sort((a, b) => a.order - b.order);
  const idx = sorted.findIndex((b) => b.id === blockId);
  if (e.shiftKey) {
    // Previous card
    if (idx > 0) focusBlock(sorted[idx - 1].id);
  } else {
    // Next card
    if (idx < sorted.length - 1) focusBlock(sorted[idx + 1].id);
  }
  return;
}
```

**b) Inline AI assist for thread cards**

Add exported method:
```typescript
export async function handleInlineAssist() {
  if (!focusedBlockId) return;
  const block = blocks.find((b) => b.id === focusedBlockId);
  if (!block) return;

  const textarea = document.querySelector(
    `[data-block-id="${focusedBlockId}"] textarea`
  ) as HTMLTextAreaElement | null;
  if (!textarea) return;

  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const selectedText = start !== end ? block.text.slice(start, end) : block.text;
  if (!selectedText.trim()) return;

  assistingBlockId = focusedBlockId;
  try {
    const result = await api.assist.improve(selectedText);
    if (start !== end) {
      const newText = block.text.slice(0, start) + result.content + block.text.slice(end);
      updateBlockText(block.id, newText);
    } else {
      updateBlockText(block.id, result.content);
    }
  } catch {
    // Error surfaced via parent's submitError
  } finally {
    assistingBlockId = null;
  }
}
```

Add state and import:
```typescript
import { api } from '$lib/api';
let assistingBlockId = $state<string | null>(null);
```

Add visual indicator on the card being assisted:
```svelte
<div class="tweet-card" class:assisting={assistingBlockId === block.id}>
```

```css
.tweet-card.assisting {
  border-color: var(--color-accent);
  opacity: 0.7;
  pointer-events: none;
}
```

**c) Exported method for palette actions**

```typescript
export function handlePaletteAction(actionId: string) {
  if (!focusedBlockId) {
    // Default to first block if none focused
    const sorted = [...blocks].sort((a, b) => a.order - b.order);
    if (sorted.length > 0) focusedBlockId = sorted[0].id;
  }
  if (!focusedBlockId) return;

  switch (actionId) {
    case 'add-card': addBlock(); break;
    case 'duplicate': duplicateBlock(focusedBlockId); break;
    case 'split': splitBlock(focusedBlockId); break;
    case 'merge': mergeWithNext(focusedBlockId); break;
    case 'move-up': {
      const sorted = [...blocks].sort((a, b) => a.order - b.order);
      const idx = sorted.findIndex((b) => b.id === focusedBlockId);
      if (idx > 0) { moveBlock(focusedBlockId, idx - 1); focusBlock(focusedBlockId); }
      break;
    }
    case 'move-down': {
      const sorted = [...blocks].sort((a, b) => a.order - b.order);
      const idx = sorted.findIndex((b) => b.id === focusedBlockId);
      if (idx < sorted.length - 1) { moveBlock(focusedBlockId, idx + 1); focusBlock(focusedBlockId); }
      break;
    }
  }
}
```

**d) Cmd+J interception in card keydown**

Add to `handleCardKeydown`:
```typescript
// Cmd+J: inline AI assist (handled by parent, but prevent default here)
if ((e.metaKey || e.ctrlKey) && !e.shiftKey && (e.key === 'j' || e.key === 'J')) {
  e.preventDefault();
  // Parent will call handleInlineAssist via ref
  return;
}
```

Actually, the Cmd+J handling is better left to ComposeModal's `handleKeydown` on `<svelte:window>` since it sits at the window level. The ThreadComposer doesn't need to intercept it — the parent calls `threadComposerRef.handleInlineAssist()` directly. No change needed in ThreadComposer's keydown for this.

#### Estimated Line Impact

| Section | Lines Added |
|---------|------------|
| Script additions (handlers, imports, state) | +55 |
| Template additions (assisting class) | +2 |
| CSS additions (assisting state) | +5 |
| **Total** | **+62** |
| **New total** | **~777** |

---

## Files to Create (Documentation)

### 5. `docs/roadmap/typefully-composer-ui-parity/session-05-distraction-free.md`

Technical documentation of all Session 05 deliverables:
- Focus mode design and CSS strategy
- Command palette architecture and action catalog
- Shortcut registry design (stateless utility)
- Inline AI assist flow (selection → API → replacement)
- "From notes" helper UX
- Tab navigation behavior
- Complete shortcut table

### 6. `docs/roadmap/typefully-composer-ui-parity/session-05-handoff.md`

Handoff document with:
- What changed (new/modified files with line counts)
- Decisions made (with IDs and rationale)
- Open risks
- Test coverage
- Exact inputs for Session 06

---

## Exact Order of Operations

### Step 1: Create `shortcuts.ts`

**Path:** `dashboard/src/lib/utils/shortcuts.ts`

This is a dependency-free utility that both ComposeModal and CommandPalette will import. Build it first.

Implementation:
1. `isMac()` — checks `navigator.platform` for Mac
2. `matchEvent(e, combo)` — parses combo string, compares modifier keys and key value
3. `formatCombo(combo)` — returns display string with platform-appropriate symbols
4. `SHORTCUT_CATALOG` — typed array of all shortcuts with labels and categories

Combo format: `"cmd+shift+f"` where `cmd` maps to metaKey on Mac, ctrlKey elsewhere. Supported modifiers: `cmd`, `shift`, `alt`. Key names match `KeyboardEvent.key` (lowercased).

### Step 2: Create `CommandPalette.svelte`

**Path:** `dashboard/src/lib/components/CommandPalette.svelte`

Implementation:
1. Define action list with id, label, icon component, category, shortcut combo, and `when` filter
2. Filter actions by current `mode` prop and search query
3. Render overlay with search input, categorized action list
4. Keyboard navigation: ArrowUp/ArrowDown to move selection, Enter to execute, Escape to close
5. Each action row shows icon (left), label (center), shortcut hint from `formatCombo()` (right)
6. Search uses case-insensitive `includes()` on label — no external fuzzy library needed

Category rendering order: Mode > Compose > AI > Thread

Icon imports from lucide-svelte: `Maximize2`, `MessageSquare`, `List`, `Send`, `Sparkles`, `FileText`, `Plus`, `Copy`, `Scissors`, `Merge`, `ArrowUp`, `ArrowDown`, `Image`, `Search`

### Step 3: Modify `ThreadComposer.svelte`

**Path:** `dashboard/src/lib/components/ThreadComposer.svelte`

Implementation order:
1. Add `api` import
2. Add `assistingBlockId` state
3. Add Tab/Shift+Tab handling in `handleCardKeydown`
4. Add `handleInlineAssist()` exported method
5. Add `handlePaletteAction()` exported method
6. Add `.assisting` CSS class
7. Add `class:assisting` to tweet-card template

### Step 4: Modify `ComposeModal.svelte`

**Path:** `dashboard/src/lib/components/ComposeModal.svelte`

Implementation order:
1. Add new imports (Maximize2, Minimize2, matchEvent, CommandPalette)
2. Add state variables (focusMode, paletteOpen, showFromNotes, notesText, notesGenerating, threadComposerRef)
3. Add `toggleFocusMode()`, `handlePaletteAction()`, `generateFromNotes()`, `handleInlineAssist()` functions
4. Replace `handleKeydown` with enhanced version using `matchEvent()`
5. Add `bind:this={threadComposerRef}` on ThreadComposer
6. Add focus mode button in modal-header
7. Add `class:focus-mode={focusMode}` on modal div
8. Add CommandPalette render block (inside modal, after modal-body)
9. Add "from notes" section in modal-body
10. Reset new state vars on modal open/close in `$effect`
11. Add focus-mode CSS
12. Add from-notes CSS
13. Add focus-btn CSS

### Step 5: Create session documentation

Write `session-05-distraction-free.md` and `session-05-handoff.md` under `docs/roadmap/typefully-composer-ui-parity/`.

### Step 6: Run quality gates

```bash
cd dashboard && npm run check
cd dashboard && npm run build
```

No Rust changes expected — quality gates are frontend-only.

---

## Key Design Decisions

| ID | Decision | Rationale |
|----|----------|-----------|
| D5-1 | Stateless shortcut utility (no global registry) | Avoids lifecycle management complexity. Each component checks its own shortcuts. Simpler, more predictable. |
| D5-2 | CommandPalette emits action IDs, parent dispatches | Keeps palette decoupled from compose logic. Parent has all state references. Clean separation of concerns. |
| D5-3 | Focus mode via CSS class on existing modal | Simplest implementation. No routing changes. No state transfer. The modal div toggles between constrained and full-viewport via CSS. |
| D5-4 | "From notes" uses existing `assist.improve` and `assist.thread` endpoints | No backend changes needed. `improve` with context param handles tweet expansion. `thread` with notes as topic handles thread generation. |
| D5-5 | Inline AI assist replaces selection in-place | Mimics IDE behavior (select text, transform). More surgical than whole-tweet replacement. When no selection exists, falls back to improving entire text. |
| D5-6 | Tab interception only in thread card textareas | Normal Tab behavior preserved everywhere else. Only intercepted via the existing `handleCardKeydown` handler which fires on textarea keydown. |
| D5-7 | Escape priority: palette > focus mode > close modal | Layered escape ensures each level can be dismissed independently without losing compose state. |
| D5-8 | Fuzzy search via `includes()` not Fuse.js | Zero dependencies. Action list is small (~13 items). Full fuzzy matching adds complexity without proportional benefit. |
| D5-9 | ThreadComposer exports methods for parent interaction | `bind:this` pattern lets ComposeModal call `handleInlineAssist()` and `handlePaletteAction()` directly. Cleaner than event-based communication for imperative operations. |

---

## Risks and Mitigations

| # | Risk | Impact | Mitigation |
|---|------|--------|------------|
| R5-1 | ComposeModal at ~1066 lines exceeds 400-line limit | Code organization debt | Session 06 can extract compose sections into sub-components during responsive refactor. Focus mode and from-notes are good extraction candidates. |
| R5-2 | Cmd+K may conflict with browser address bar focus | Shortcut doesn't fire | `e.preventDefault()` in the window keydown handler. Tauri app has no address bar. In dev browser, the modal's keydown fires first since it uses `<svelte:window>`. |
| R5-3 | Cmd+J may conflict with browser developer tools toggle | Shortcut doesn't fire | Chrome has no Cmd+J shortcut. Firefox downloads page is Cmd+J but `e.preventDefault()` intercepts. Tauri production app has no conflict. |
| R5-4 | Tab interception breaks accessibility expectations | Screen reader users expect Tab to move to next UI element | Only intercepted inside thread card textareas (not globally). Users can still Tab out of the thread composer to other modal controls via the "Add tweet" button which doesn't intercept Tab. Document this in shortcut reference. |
| R5-5 | Inline AI assist with no selection improves entire text | User may not expect full replacement | Clear visual feedback: card shows `.assisting` state (muted opacity). Also, auto-save preserves previous state for recovery. |
| R5-6 | "From notes" generation overwrites existing compose content | Data loss | Warn via confirm dialog if existing content is non-empty. "This will replace your current content. Continue?" |
| R5-7 | Focus mode on mobile may be redundant (already full-viewport) | No visual change on mobile | The mobile breakpoint already sets `width: 100%` and `max-height: 100vh`. Focus mode adds `border-radius: 0` and fills height. The button is still useful for discoverability. |

---

## Verification Steps

### Functional Checks

1. **Focus mode toggle:**
   - Open compose modal → press Cmd+Shift+F → modal expands to full viewport
   - Press Cmd+Shift+F again → returns to normal size
   - Press Escape in focus mode → exits focus mode (not modal)
   - All compose features work identically in both modes
   - Focus mode button visible in header with correct icon state

2. **Command palette:**
   - Press Cmd+K → palette opens with search input focused
   - Type to filter actions → list updates
   - Arrow keys navigate → selection highlight moves
   - Enter executes selected action → palette closes, action fires
   - Escape closes palette without action
   - Thread-specific actions hidden in tweet mode
   - Shortcut hints display correctly (platform-aware)

3. **Inline AI assist:**
   - Tweet mode: select text → Cmd+J → selected text replaced with improved version
   - Tweet mode: no selection → Cmd+J → entire tweet improved
   - Thread mode: select text in card → Cmd+J → selection replaced
   - Thread mode: no selection → Cmd+J → entire card text improved
   - Loading state visible during API call (`.assisting` class)

4. **From notes:**
   - Open "From notes" via command palette or UI button
   - Paste text → click generate → content appears in compose area
   - Thread mode generates multi-card thread
   - Tweet mode generates single tweet
   - Warning shown if existing content will be overwritten

5. **Tab navigation:**
   - Focus on card 1 textarea → press Tab → focus moves to card 2 textarea
   - Press Shift+Tab → focus returns to card 1
   - Tab on last card → no-op (stays on last card)
   - Shift+Tab on first card → no-op (stays on first card)

6. **Shortcut conflicts:**
   - All shortcuts fire correctly in Tauri production build
   - Cmd+Enter submits compose (when valid)
   - No accidental submission on Cmd+J, Cmd+K, etc.

### Quality Gates

```bash
# Frontend checks
cd dashboard && npm run check     # svelte-check: 0 errors expected
cd dashboard && npm run build     # Production build: success expected

# No Rust changes — backend CI gates not needed
```

### Manual Testing Matrix

| Test | Tweet Mode | Thread Mode | Focus Mode |
|------|-----------|-------------|------------|
| Compose and submit | Verify | Verify | Verify |
| Cmd+Shift+F toggle | Verify | Verify | N/A |
| Cmd+K palette | Verify | Verify | Verify |
| Cmd+J assist | Verify | Verify | Verify |
| Tab navigation | N/A | Verify | Verify |
| From notes | Verify | Verify | Verify |
| Escape layering | Verify | Verify | Verify |
| Auto-save | Verify | Verify | Verify |

---

## Superiority Assessment After Session 05

| Dimension | Typefully | Tuitbot (after S05) | Winner |
|-----------|-----------|---------------------|--------|
| Writing speed | Basic editor | Focus mode + AI improve + from-notes + Cmd+Enter | Tuitbot |
| Structural control | Click-to-reorder | DnD + keyboard + power actions + Tab nav + command palette | Tuitbot |
| Feedback clarity | Basic counters | Per-card counters + live preview + ARIA + assist state | Tuitbot |
| Accessibility | Limited | Full keyboard shortcuts + palette + Tab nav + focus management | Tuitbot |

Session 05 delivers clear wins in writing speed (AI assist, from-notes, focus mode) and keyboard efficiency (command palette, Tab navigation, shortcut registry). Combined with Sessions 03-04 wins in structural control and feedback clarity, all 4 superiority dimensions are covered.

---

## Session 06 Inputs (Preview)

After Session 05, the primary remaining work is:
1. Mobile responsive layouts for focus mode, command palette, all compose components
2. Touch targets >= 44px for all interactive elements
3. Focus trap within modal (Tab never escapes)
4. ARIA audit: remove all `svelte-ignore a11y_*` directives
5. `prefers-reduced-motion` media query for all transitions
6. Contrast ratio verification for all design tokens
7. Consider extracting ComposeModal sub-sections into separate components to address file size limit
