# Session 03 — Thread Composer Foundation UI: Implementation Plan

**Date:** 2026-02-27
**Goal:** Build a premium WYSIWYG thread composer with two-pane editing and per-card validation that clearly exceeds the Typefully baseline UX.

---

## Table of Contents

1. [Current State Analysis](#1-current-state-analysis)
2. [Files to Create](#2-files-to-create)
3. [Files to Modify](#3-files-to-modify)
4. [Key Design Decisions](#4-key-design-decisions)
5. [Detailed Implementation Steps](#5-detailed-implementation-steps)
6. [Risks and Mitigations](#6-risks-and-mitigations)
7. [Verification Steps](#7-verification-steps)
8. [Exit Criteria Checklist](#8-exit-criteria-checklist)

---

## 1. Current State Analysis

### ComposeModal.svelte (787 lines)
- Lines 1-251: Script block containing all state and logic for both tweet and thread modes.
- Lines 252-394: Template with a single `<div class="modal">` layout — tweet mode and thread mode are `{#if}`-toggled inline.
- Lines 396-786: Scoped CSS for the entire modal.
- Thread mode currently uses `threadParts: string[]` — flat string array with no IDs, no preview, no blocks API integration.
- Media attachment is modal-level only (not per-tweet-card).
- No accessibility semantics: backdrop uses `svelte-ignore a11y_click_events_have_key_events a11y_no_static_element_interactions` (line 256).

### API Integration (api.ts)
- Session 02 added `ThreadBlock`, `ThreadBlocksPayload`, `parseThreadContent()`, `isBlocksPayload()`.
- `ComposeRequest` has optional `blocks` field.
- `api.drafts.create()` and `api.drafts.edit()` accept optional `blocks` parameter.
- `api.content.compose()` accepts `ComposeRequest` with blocks.

### Content Page (+page.svelte, 407 lines)
- Mounts `<ComposeModal>` at bottom of template.
- `handleCompose()` calls `composeContent()` from calendar store, then closes modal.
- `onsubmit` callback expects `{content_type, content, scheduled_for?, media_paths?}`.

### Drafts Page (+page.svelte, 529 lines)
- Has its own inline create/edit flow (not using ComposeModal).
- Displays `draft.content` raw — will show JSON wrapper for blocks-format drafts (risk R-2 from session 02).
- `startEdit()` sets `editContent = d.content` directly — needs to detect blocks format.

### tweetLength.ts
- Exports `tweetWeightedLen(text)` and `MAX_TWEET_CHARS` (280).
- URL-aware: replaces URLs with 23-char t.co equivalent.
- ThreadComposer will use this per-card.

### Design Tokens (app.css)
- Dark theme default. Light theme via `[data-theme='light']`.
- Key tokens: `--color-surface`, `--color-base`, `--color-border`, `--color-border-subtle`, `--color-accent`, `--color-danger`, `--color-text`, `--color-text-muted`, `--color-text-subtle`.
- Font families: `--font-sans`, `--font-mono`.

### Store Pattern
- Stores use `svelte/store` (writable/derived) — not Svelte 5 runes.
- Components use Svelte 5 runes (`$state`, `$derived`, `$effect`, `$props`).
- Calendar store exports `composeContent(data: ComposeRequest)` that calls `api.content.compose()`.

---

## 2. Files to Create

### 2a. `dashboard/src/lib/components/ThreadComposer.svelte` (NEW, ~380 lines)

Card-based thread editor component with:
- Props via `$props()`: initial blocks, mode callbacks, schedule/media state hooks.
- Per-card textarea with character counter, card number label, remove button.
- "Add tweet" button at bottom.
- Drag handle placeholder (visual only — Session 04 adds DnD).
- Emits block changes to parent for submit and auto-save.

### 2b. `dashboard/src/lib/components/TweetPreview.svelte` (NEW, ~180 lines)

Read-only tweet card render for the side panel:
- Props: `text`, `media_paths`, `index`, `total`, `handle` (optional).
- Renders: avatar placeholder circle, handle/username, text with line wrapping, media grid (1-4 images), relative card numbering ("1/5").
- Purely presentational — no backend calls, no internal state beyond props.

---

## 3. Files to Modify

### 3a. `dashboard/src/lib/components/ComposeModal.svelte`

**Target:** Reduce from 787 lines to ~350 lines by extracting thread mode to ThreadComposer.

Changes:
- Import `ThreadComposer` and `TweetPreview`.
- Import `ThreadBlock`, `parseThreadContent`, `isBlocksPayload` from `$lib/api`.
- Add thread blocks state: `let blocks = $state<ThreadBlock[]>([...])` — initialized from `createDefaultBlocks()`.
- When `mode === 'thread'`, render `<ThreadComposer>` + `<TweetPreview>` side panel instead of the inline `{#each threadParts}` block.
- The modal width expands from 520px to ~900px when in thread mode to accommodate the two-pane layout.
- `handleSubmit()` updated to construct `ComposeRequest` with `blocks` when in thread mode.
- `onsubmit` callback type updated to accept optional `blocks` field.
- Add localStorage auto-save with 500ms debounce via `$effect`.
- Add recovery prompt on modal open if unsaved content exists.
- Remove `threadParts: string[]` state — replaced by `blocks: ThreadBlock[]`.
- Replace `a11y_click_events_have_key_events a11y_no_static_element_interactions` with proper `role="dialog"`, `aria-modal="true"`, `aria-label` on the backdrop/modal.
- Add `onkeydown` handler to backdrop for Enter/Space accessibility.

### 3b. `dashboard/src/routes/(app)/content/+page.svelte`

**Minimal changes:**
- Update `handleCompose` callback type to accept the extended data shape with optional `blocks` field.
- Pass blocks through to `composeContent()` if present in data.

### 3c. `dashboard/src/routes/(app)/drafts/+page.svelte`

**Changes:**
- In the draft display section, detect blocks format using `isBlocksPayload(draft.content)` and display a formatted preview instead of raw JSON.
- When editing a blocks-format draft, parse blocks via `parseThreadContent()` and open them in a format the UI can understand.
- Import `parseThreadContent`, `isBlocksPayload` from `$lib/api`.

---

## 4. Key Design Decisions

### D-1: Two-Pane Layout via CSS Grid (Not Separate Routes)

**Decision:** Thread mode renders editor (left) and preview (right) side-by-side within the same modal using CSS grid. Single-column fallback for widths < 768px.

**Rationale:** Avoids routing complexity. Modal already manages backdrop/focus/escape. The grid approach is simple CSS:
```css
.modal.thread-mode { width: 900px; }
.two-pane { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
```

### D-2: ThreadComposer Owns Block State, Parent Owns Submit

**Decision:** ThreadComposer manages its own reactive `blocks` array internally (add/remove/edit/reorder). It exposes the current blocks to the parent via a callback `onchange: (blocks: ThreadBlock[]) => void` on every mutation.

**Rationale:** Keeps ThreadComposer self-contained and testable. ComposeModal reads the latest blocks when the user hits Submit. ThreadComposer doesn't know about submit/schedule/media-upload — those remain in ComposeModal.

### D-3: Client-Generated Block UUIDs via crypto.randomUUID()

**Decision:** Each new block gets `id = crypto.randomUUID()`. IDs are stable across edits (only generated on add, not on every render).

**Rationale:** Matches the API contract from Session 02. `crypto.randomUUID()` is available in all modern browsers and Tauri WebView.

### D-4: Auto-Save to localStorage with Namespaced Keys

**Decision:** Auto-save uses `localStorage.setItem('tuitbot:compose:draft', JSON.stringify({mode, blocks, tweetText, timestamp}))` debounced at 500ms. Cleared on successful submit. Recovery prompt on open if stale data exists (< 7 days old).

**Rationale:** Per charter A-7, localStorage is zero-backend-cost and instant. Namespaced key avoids collisions. 7-day TTL prevents stale recovery prompts.

### D-5: TweetPreview is Stateless and Props-Only

**Decision:** TweetPreview renders a single tweet card. The side panel maps over `blocks` and renders one TweetPreview per block. It receives text, media, index, and total as props.

**Rationale:** Keeps preview dead-simple. No internal state, no API calls. Parent controls what to show. Easy to test visually.

### D-6: Minimum 2 Blocks Enforced in UI

**Decision:** Thread mode always starts with 2 empty blocks. Remove button is disabled/hidden when exactly 2 blocks remain. Submit button disabled when fewer than 2 blocks have non-empty text.

**Rationale:** Matches API validation rule ("thread must contain at least 2 blocks"). Prevents the user from submitting invalid payloads.

### D-7: Modal Width Responsive to Mode

**Decision:** Tweet mode: 520px (unchanged). Thread mode: min(900px, 90vw). Below 768px: full viewport, single-column stacked layout (editor then preview toggle).

**Rationale:** Two-pane needs horizontal space. On mobile, side-by-side is not viable, so we switch to stacked with a toggle button. 900px is comfortable for two 420px panes + 16px gap + 44px padding.

### D-8: Preserve Existing Submit Callback Contract

**Decision:** `onsubmit` callback signature changes from `(data: {content_type, content, scheduled_for?, media_paths?})` to `(data: ComposeRequest)`. `ComposeRequest` from api.ts already includes optional `blocks`. This is backwards-compatible: tweet-mode payloads omit `blocks`.

**Rationale:** Content page and drafts page callers just pass the data through to the API. No downstream changes needed beyond typing.

---

## 5. Detailed Implementation Steps

### Step 1: Create TweetPreview.svelte

**File:** `dashboard/src/lib/components/TweetPreview.svelte`
**Lines:** ~180

Structure:
```
<script lang="ts">
  Props: { text, mediaPaths, index, total, handle? }
  Derived: formattedText (preserve newlines)
</script>

<article class="tweet-preview" aria-label="Tweet {index + 1} of {total}">
  <div class="preview-header">
    <div class="avatar-placeholder" />
    <div class="preview-meta">
      <span class="handle">{handle || '@you'}</span>
      <span class="preview-index">{index + 1}/{total}</span>
    </div>
  </div>
  <div class="preview-text">{formattedText}</div>
  {#if mediaPaths.length > 0}
    <div class="preview-media-grid" class:single={mediaPaths.length === 1} ...>
      {#each mediaPaths as path}
        <div class="preview-media-item">
          <img src={mediaFileUrl(path)} alt="" />
        </div>
      {/each}
    </div>
  {/if}
  {#if index < total - 1}
    <div class="thread-connector" />
  {/if}
</article>
```

Styles use design tokens. Thread connector is a vertical line between cards (visual thread indicator). Media grid adapts layout: 1 image = full width, 2 = 50/50, 3 = 2+1, 4 = 2x2 grid.

### Step 2: Create ThreadComposer.svelte

**File:** `dashboard/src/lib/components/ThreadComposer.svelte`
**Lines:** ~380

Props interface:
```typescript
{
  initialBlocks?: ThreadBlock[];
  onchange: (blocks: ThreadBlock[]) => void;
}
```

Internal state:
```typescript
let blocks = $state<ThreadBlock[]>(initialBlocks ?? createDefaultBlocks());
let focusedBlockId = $state<string | null>(null);
```

Functions:
- `createDefaultBlocks()`: Returns 2 empty blocks with `crypto.randomUUID()` IDs, order 0 and 1.
- `addBlock()`: Appends a new block at end, increments order.
- `removeBlock(id: string)`: Removes block, reindexes order fields. Disabled if only 2 blocks remain.
- `updateBlockText(id: string, text: string)`: Updates text on the matching block. Calls `onchange(blocks)`.
- `getCharCount(text: string)`: Returns `tweetWeightedLen(text)`.
- `isOverLimit(text: string)`: Returns `getCharCount(text) > MAX_TWEET_CHARS`.

Template structure:
```html
<div class="thread-composer" role="region" aria-label="Thread editor">
  {#each sortedBlocks as block, i (block.id)}
    <div class="tweet-card" class:focused={focusedBlockId === block.id}
         class:over-limit={isOverLimit(block.text)}>
      <div class="card-gutter">
        <div class="card-number">{i + 1}</div>
        <div class="drag-handle-placeholder" title="Drag to reorder (coming soon)">
          <!-- GripVertical icon placeholder -->
        </div>
      </div>
      <div class="card-body">
        <textarea
          class="card-textarea"
          class:over-limit={isOverLimit(block.text)}
          placeholder={i === 0 ? 'Start your thread...' : `Tweet ${i + 1}...`}
          value={block.text}
          oninput={(e) => updateBlockText(block.id, e.currentTarget.value)}
          onfocus={() => focusedBlockId = block.id}
          rows={3}
          aria-label={`Tweet ${i + 1} of ${sortedBlocks.length}`}
        ></textarea>
        <div class="card-footer">
          <div class="char-counter"
               class:over-limit={isOverLimit(block.text)}
               class:warning={getCharCount(block.text) > 260}
               aria-live="polite"
               aria-label="Character count">
            {getCharCount(block.text)}/{MAX_TWEET_CHARS}
          </div>
          {#if sortedBlocks.length > 2}
            <button class="remove-card-btn"
                    onclick={() => removeBlock(block.id)}
                    aria-label={`Remove tweet ${i + 1}`}>
              <Trash2 size={12} />
            </button>
          {/if}
        </div>
      </div>
      {#if i < sortedBlocks.length - 1}
        <div class="thread-line" />
      {/if}
    </div>
  {/each}

  <button class="add-card-btn" onclick={addBlock}
          aria-label="Add another tweet to thread">
    <Plus size={14} />
    Add tweet
  </button>

  {#if validationErrors.length > 0}
    <div class="validation-summary" role="alert">
      {#each validationErrors as err}
        <p class="validation-error">{err}</p>
      {/each}
    </div>
  {/if}
</div>
```

Key derived values:
```typescript
const sortedBlocks = $derived(
  [...blocks].sort((a, b) => a.order - b.order)
);

const validationErrors = $derived(() => {
  const errors: string[] = [];
  const nonEmpty = blocks.filter(b => b.text.trim().length > 0);
  if (nonEmpty.length < 2) {
    errors.push('Thread needs at least 2 tweets with content.');
  }
  for (const block of blocks) {
    if (isOverLimit(block.text)) {
      errors.push(`Tweet ${block.order + 1} exceeds 280 characters.`);
    }
  }
  return errors;
});

const canSubmit = $derived(
  blocks.filter(b => b.text.trim().length > 0).length >= 2 &&
  blocks.every(b => !isOverLimit(b.text))
);
```

The `canSubmit` derived value is exposed via a callback or prop binding so the parent (ComposeModal) can disable the submit button.

Style: Each tweet card has a left gutter (card number + drag handle placeholder), a body (textarea + footer with char counter and remove button), and an optional thread connector line between cards. Cards use a light elevated surface (`--color-surface`) with `--color-border-subtle` border, slightly rounded (8px). Focused card gets `--color-accent` left border accent.

### Step 3: Refactor ComposeModal.svelte

**Target:** ~350 lines (down from 787).

#### 3a. Update imports
```typescript
import ThreadComposer from './ThreadComposer.svelte';
import TweetPreview from './TweetPreview.svelte';
import { type ThreadBlock, type ComposeRequest, parseThreadContent, isBlocksPayload } from '$lib/api';
```

#### 3b. Replace thread state
Remove:
```typescript
let threadParts = $state<string[]>(['', '']);
```
Add:
```typescript
let threadBlocks = $state<ThreadBlock[]>([]);
```

Remove functions: `addThreadPart`, `removeThreadPart`, `updateThreadPart`.

#### 3c. Update onsubmit callback type
Change the `onsubmit` prop type from the inline object type to `ComposeRequest`:
```typescript
onsubmit: (data: ComposeRequest) => void;
```

#### 3d. Update handleSubmit
```typescript
async function handleSubmit() {
  if (!canSubmit || submitting) return;
  submitting = true;
  submitError = null;

  try {
    const data: ComposeRequest = {
      content_type: mode,
      content: ''
    };

    if (mode === 'tweet') {
      data.content = tweetText.trim();
    } else {
      // Build blocks payload for API
      const validBlocks = threadBlocks
        .filter(b => b.text.trim().length > 0)
        .map((b, i) => ({ ...b, text: b.text.trim(), order: i }));
      data.content = JSON.stringify(validBlocks.map(b => b.text));
      data.blocks = validBlocks;
    }

    if (selectedTime) {
      const scheduled = new Date(targetDate);
      const [h, m] = selectedTime.split(':').map(Number);
      scheduled.setHours(h, m, 0, 0);
      data.scheduled_for = scheduled.toISOString().replace('Z', '');
    }

    if (attachedMedia.length > 0) {
      data.media_paths = attachedMedia.map(m => m.path);
    }

    clearAutoSave();
    onsubmit(data);
  } catch (e) {
    submitError = e instanceof Error ? e.message : 'Failed to submit';
    submitting = false;
  }
}
```

#### 3e. Update canSubmitThread
Remove old `canSubmitThread` derived. ThreadComposer exposes a validation state via `onvalidchange` callback:
```typescript
let threadValid = $state(false);

// In template: <ThreadComposer ... onvalidchange={(v) => threadValid = v} />
const canSubmitThread = $derived(threadValid);
```

#### 3f. Add auto-save with debounce
```typescript
const AUTOSAVE_KEY = 'tuitbot:compose:draft';
const AUTOSAVE_DEBOUNCE_MS = 500;
const AUTOSAVE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

let autoSaveTimer: ReturnType<typeof setTimeout> | null = null;
let recoveryData = $state<{ mode: string; tweetText: string; blocks: ThreadBlock[]; timestamp: number } | null>(null);
let showRecovery = $state(false);

function autoSave() {
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(() => {
    const payload = {
      mode,
      tweetText,
      blocks: threadBlocks,
      timestamp: Date.now()
    };
    try {
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
    } catch { /* quota exceeded — silent fail */ }
  }, AUTOSAVE_DEBOUNCE_MS);
}

function clearAutoSave() {
  localStorage.removeItem(AUTOSAVE_KEY);
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
}

function checkRecovery() {
  try {
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (Date.now() - data.timestamp > AUTOSAVE_TTL_MS) {
      localStorage.removeItem(AUTOSAVE_KEY);
      return;
    }
    const hasContent = data.tweetText?.trim() || data.blocks?.some((b: ThreadBlock) => b.text.trim());
    if (hasContent) {
      recoveryData = data;
      showRecovery = true;
    }
  } catch {
    localStorage.removeItem(AUTOSAVE_KEY);
  }
}

function recoverDraft() {
  if (!recoveryData) return;
  mode = recoveryData.mode as 'tweet' | 'thread';
  tweetText = recoveryData.tweetText || '';
  threadBlocks = recoveryData.blocks || [];
  showRecovery = false;
  clearAutoSave();
}

function dismissRecovery() {
  showRecovery = false;
  clearAutoSave();
}
```

Trigger auto-save in `$effect`:
```typescript
$effect(() => {
  // Track reactive dependencies
  const _mode = mode;
  const _text = tweetText;
  const _blocks = threadBlocks;
  if (open) autoSave();
});
```

Check recovery on modal open (in existing `$effect` that resets state when `open` changes):
```typescript
$effect(() => {
  if (open) {
    checkRecovery();
    // ... existing reset only if no recovery
  }
});
```

#### 3g. Update modal template for two-pane layout

Replace the thread `{:else}` block (lines 292-321) with:
```html
{:else}
  <div class="thread-layout">
    <div class="thread-editor-pane">
      <ThreadComposer
        initialBlocks={threadBlocks}
        onchange={(b) => { threadBlocks = b; }}
        onvalidchange={(v) => { threadValid = v; }}
      />
    </div>
    <div class="thread-preview-pane">
      <div class="preview-header-label">Preview</div>
      <div class="preview-scroll">
        {#each sortedPreviewBlocks as block, i (block.id)}
          <TweetPreview
            text={block.text}
            mediaPaths={block.media_paths}
            index={i}
            total={sortedPreviewBlocks.length}
          />
        {/each}
      </div>
    </div>
  </div>
{/if}
```

Where:
```typescript
const sortedPreviewBlocks = $derived(
  [...threadBlocks].sort((a, b) => a.order - b.order).filter(b => b.text.trim().length > 0)
);
```

#### 3h. Add recovery prompt banner
```html
{#if showRecovery}
  <div class="recovery-banner" role="alert">
    <span>Unsaved draft found. Recover it?</span>
    <button class="recovery-btn" onclick={recoverDraft}>Recover</button>
    <button class="recovery-dismiss" onclick={dismissRecovery}>Discard</button>
  </div>
{/if}
```

#### 3i. Accessibility improvements
- Replace `<!-- svelte-ignore a11y_click_events_have_key_events a11y_no_static_element_interactions -->` with proper semantics:
```html
<div class="backdrop" onclick={handleBackdropClick}
     onkeydown={handleBackdropKeydown}
     role="presentation">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Compose content">
```
- Add `handleBackdropKeydown` that calls `onclose()` on Escape.

#### 3j. CSS updates
- Add `.modal.thread-mode` width override (900px max).
- Add `.thread-layout` grid: `display: grid; grid-template-columns: 1fr 1fr; gap: 16px;`
- Add `.thread-preview-pane` styles: scrollable, max-height matching editor.
- Add `.recovery-banner` styles.
- Add responsive breakpoint: `@media (max-width: 768px)` for single-column thread layout.
- Remove old `.thread-compose`, `.thread-part`, `.thread-part-header`, `.thread-num`, `.remove-part-btn`, `.thread-input` styles (moved to ThreadComposer).

### Step 4: Update Content Page (+page.svelte)

**Minimal change** — update the `handleCompose` function and `onsubmit` callback type:

```typescript
async function handleCompose(data: ComposeRequest) {
  await composeContent(data);
  composeOpen = false;
}
```

Update the `ComposeModal` usage:
```html
<ComposeModal
  open={composeOpen}
  ...
  onsubmit={handleCompose}
/>
```

Import `ComposeRequest` type from `$lib/api`.

### Step 5: Update Drafts Page (+page.svelte)

**Changes for blocks-format draft display:**

Add import:
```typescript
import { parseThreadContent, isBlocksPayload, type ThreadBlock } from '$lib/api';
```

Update the draft content display section to detect and format blocks:
```html
{#if isBlocksPayload(draft.content)}
  {@const blocks = parseThreadContent(draft.content)}
  <div class="thread-preview-compact">
    {#if Array.isArray(blocks) && blocks.length > 0 && typeof blocks[0] === 'object'}
      {#each blocks as block, i}
        <p class="draft-content thread-block-preview">
          <span class="block-num">{i + 1}.</span> {block.text}
        </p>
      {/each}
    {/if}
  </div>
{:else}
  <p class="draft-content">{draft.content}</p>
{/if}
```

The `startEdit` function needs to detect blocks format but for now just sets the raw content. Full blocks-aware editing in the drafts page inline editor is deferred to when we integrate ComposeModal into drafts (thread editing via modal rather than inline textarea). For this session, the edit falls back to raw content editing for blocks-format drafts with a note.

Add CSS for `.thread-block-preview` and `.block-num`.

### Step 6: Write Handoff Documents

**Files:**
- `docs/roadmap/typefully-composer-ui-parity/session-03-ui-foundation.md`
- `docs/roadmap/typefully-composer-ui-parity/session-03-handoff.md`

---

## 6. Risks and Mitigations

| # | Risk | Impact | Mitigation |
|---|------|--------|------------|
| R-1 | ComposeModal exceeds 400-line limit after changes | Violates file-size rule | Aggressively extract: all thread CSS lives in ThreadComposer, preview CSS in TweetPreview. ComposeModal only has modal chrome styles. Thread state management lives in ThreadComposer. |
| R-2 | Auto-save localStorage conflicts between tabs | Duplicate recovery prompts | Namespace with `tuitbot:compose:draft`. Single key — last write wins. Acceptable for single-user desktop app. |
| R-3 | `crypto.randomUUID()` unavailable in older WebViews | Runtime error on block creation | Tauri ships Chromium 114+ (supports `randomUUID`). For safety, add a fallback: `crypto.randomUUID?.() ?? self.crypto.randomUUID()`. Both paths resolve to the same native API. |
| R-4 | Two-pane layout causes horizontal scroll on smaller screens | Poor UX on laptops < 1024px | Media query at 768px collapses to single-column. At 900px viewport, modal caps at 90vw. Preview pane scrolls independently. |
| R-5 | Draft list showing raw JSON for blocks-format content (inherited R-2 from Session 02) | Confusing display | Step 5 adds blocks-format detection in drafts page. `parseThreadContent()` handles the parsing. |
| R-6 | `$effect` for auto-save may fire too eagerly | Performance degradation with many blocks | Debounce at 500ms means at most 2 saves/second. localStorage writes are fast (~1ms). Blocks are small JSON. |
| R-7 | Thread preview shows empty state when all cards are empty | Confusing preview | Show placeholder in preview pane: "Start typing to see preview..." when no blocks have content. |

---

## 7. Verification Steps

### Quality Gate Commands

```bash
# Frontend type-check (primary gate for this session)
cd dashboard && npm run check

# Frontend build (validates no import/export errors)
cd dashboard && npm run build

# No Rust changes expected this session, but if any touched:
# cargo fmt --all && cargo fmt --all --check
# RUSTFLAGS="-D warnings" cargo test --workspace
# cargo clippy --workspace -- -D warnings
```

### Manual Verification Checklist

1. **Tweet mode unchanged**: Open compose modal in tweet mode. Type text, see character counter, attach media, schedule, submit. All behavior identical to before.
2. **Thread mode — card editor**: Switch to thread mode. See two empty cards. Type in each. Character counter updates per-card. Add a third card. Remove the middle card. Verify ordering updates.
3. **Thread mode — live preview**: Side panel shows rendered tweet cards for each non-empty card. Preview updates as you type.
4. **Thread mode — validation**: Try to submit with only 1 non-empty card — button disabled. Type past 280 chars in a card — counter turns red, submit disabled. Fix the text — submit re-enables.
5. **Thread mode — blocks API**: Submit a 3-tweet thread. Inspect network request — payload includes `blocks` array with UUIDs, text, and order fields.
6. **Auto-save**: Start typing in tweet mode, close the browser tab. Reopen, open compose — see recovery prompt. Click "Recover" — content restored. Click "Discard" on another test — content cleared.
7. **Accessibility**: Tab through all interactive elements in the modal. Verify focus order is logical. Screen reader announces card numbers and character counts.
8. **Two-pane responsive**: Resize browser below 768px. Verify layout collapses to single column.
9. **Drafts page**: Create a thread via compose modal. View it in drafts list. Verify it shows formatted block text, not raw JSON.
10. **Content page**: Compose a thread from the content calendar. Verify it appears in the calendar after submission.

---

## 8. Exit Criteria Checklist

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | Users can compose in cards while seeing live rendered output side-by-side | Manual: open thread mode, type in cards, see preview panel update |
| 2 | Per-card character counters with URL-weighted counting | Manual: type a URL in a card, verify counter shows 23 chars for it |
| 3 | Validation prevents invalid submit payloads | Manual: try 1-card thread, over-limit card, empty cards — submit stays disabled |
| 4 | Existing tweet compose mode unchanged | Manual: full tweet compose flow works identically |
| 5 | ComposeModal under 400 lines | `wc -l dashboard/src/lib/components/ComposeModal.svelte` |
| 6 | Auto-save fires on keystroke, recovery works | Manual: type, close tab, reopen, see recovery prompt |
| 7 | Accessibility semantics present | Inspect: `role="dialog"`, `aria-modal`, `aria-label` on modal; `aria-live` on counters |
| 8 | `cd dashboard && npm run check` passes | Run command |
| 9 | Drafts page handles blocks-format content display | Manual: create blocks thread, view in drafts |
| 10 | Handoff documents written with Session 04 inputs | File exists: `session-03-handoff.md` |

---

## Exact Order of Operations

1. **Create `TweetPreview.svelte`** — Pure presentational component, no dependencies on other new code. Can be created and verified in isolation.

2. **Create `ThreadComposer.svelte`** — Depends on `TweetPreview` only for reference (not imported). Uses `ThreadBlock` from `api.ts`, `tweetWeightedLen` from `tweetLength.ts`.

3. **Refactor `ComposeModal.svelte`** — The big change. Import both new components. Extract thread mode. Add auto-save. Add accessibility. This is the riskiest step. Do it incrementally:
   - 3a. First: update imports and add new state variables.
   - 3b. Replace thread template block with ThreadComposer + TweetPreview two-pane.
   - 3c. Update handleSubmit for blocks API.
   - 3d. Add auto-save/recovery logic.
   - 3e. Fix accessibility (remove svelte-ignore, add ARIA).
   - 3f. Clean up removed CSS.
   - 3g. Run `npm run check` after each sub-step.

4. **Update content/+page.svelte** — Type the `onsubmit` callback to accept `ComposeRequest`.

5. **Update drafts/+page.svelte** — Add blocks-format detection for display.

6. **Run full quality gates** — `cd dashboard && npm run check && npm run build`.

7. **Write session-03-ui-foundation.md** — Document what was built, design decisions.

8. **Write session-03-handoff.md** — Include: what changed, decisions, risks, Session 04 inputs (reorder, media, power actions).

---

## Session 04 Requirements to Document in Handoff

The handoff must include clear inputs for Session 04:

1. **Drag-and-drop reorder**: ThreadComposer already has `drag-handle-placeholder`. Session 04 adds HTML5 native DnD on the handle, updating `block.order` fields.
2. **Keyboard reorder**: Alt+Up / Alt+Down to move focused card.
3. **Per-tweet media**: Each card gets a `MediaSlot` component. Currently, media is modal-level only. Session 04 wires per-block `media_paths` in ThreadComposer.
4. **Power actions**: Duplicate (copy block, new UUID), Split (at cursor position, two new blocks), Merge (combine text with next block).
5. **File paths**: `ThreadComposer.svelte` (modify), `ComposeModal.svelte` (wire media per-block), new `MediaSlot.svelte`.
